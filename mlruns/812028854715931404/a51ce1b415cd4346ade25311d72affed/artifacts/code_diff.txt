diff --git a/github/examples/benchmarks/LightGBM/workflow_config_lightgbm_Alpha1582.yaml b/github/examples/benchmarks/LightGBM/workflow_config_lightgbm_Alpha1582.yaml
index 8b4e7bf..7a5eee7 100644
--- a/github/examples/benchmarks/LightGBM/workflow_config_lightgbm_Alpha1582.yaml
+++ b/github/examples/benchmarks/LightGBM/workflow_config_lightgbm_Alpha1582.yaml
@@ -1,5 +1,5 @@
 qlib_init:
-    provider_uri: "D:/project/tradenote/qlib_data/cn_data"
+    provider_uri: "D:/sync/qlib/qlib_data/cn_data"
     region: cn
 market: &market csi300
 benchmark: &benchmark SH000300
diff --git a/test/README_MA_Strategy.md b/test/README_MA_Strategy.md
deleted file mode 100644
index 5facaf7..0000000
--- a/test/README_MA_Strategy.md
+++ /dev/null
@@ -1,197 +0,0 @@
-# 均线交叉策略 (Moving Average Crossover Strategy)
-
-## 策略概述
-
-这是一个基于qlib框架实现的均线交叉策略，核心逻辑是：
-- **金叉买入**：短期均线上穿长期均线时买入
-- **死叉卖出**：短期均线下穿长期均线时卖出
-
-## 文件说明
-
-### 1. `ma_cross_strategy.py`
-完整的策略实现，包含：
-- `MACrossStrategy` 类：继承自qlib的TopkDropoutStrategy
-- 完整的回测框架
-- 结果分析和保存
-
-### 2. `ma_cross_strategy_improved.py`
-改进版本，包含：
-- 更完善的数据获取逻辑
-- 错误处理机制
-- 简化版回测功能
-
-### 3. `simple_ma_strategy.py` ⭐ **推荐使用**
-简单实用的版本，包含：
-- 清晰的数据获取和处理
-- 均线信号计算
-- 收益计算和分析
-- 可视化图表生成
-- 结果保存功能
-
-## 使用方法
-
-### 环境准备
-
-1. 确保已安装qlib：
-```bash
-pip install pyqlib
-```
-
-2. 下载qlib数据（如果还没有）：
-```bash
-# 下载中国股票数据
-python -m qlib.data.dump_bin --csv_path ~/.qlib/qlib_data/cn_data --include_fields close,open,high,low,volume
-```
-
-### 运行策略
-
-#### 方法1：运行简单版本（推荐）
-```bash
-cd test
-python simple_ma_strategy.py
-```
-
-#### 方法2：运行完整版本
-```bash
-cd test
-python ma_cross_strategy.py
-```
-
-#### 方法3：运行改进版本
-```bash
-cd test
-python ma_cross_strategy_improved.py
-```
-
-## 策略参数
-
-可以在代码中修改以下参数：
-
-```python
-# 均线周期
-short_window = 5    # 短期均线周期
-long_window = 20    # 长期均线周期
-
-# 回测时间
-start_date = "2020-01-01"
-end_date = "2023-12-31"
-
-# 初始资金
-initial_capital = 100000
-
-# 股票池
-instruments = "csi300"  # 沪深300成分股
-```
-
-## 输出结果
-
-运行策略后会生成以下文件：
-
-1. **CSV文件**：
-   - `ma_cross_signals.csv`：买卖信号数据
-   - `ma_cross_cumulative_returns.csv`：累计收益数据
-   - `ma_cross_capital_curve.csv`：资金曲线数据
-
-2. **图表文件**：
-   - `ma_cross_strategy_results.png`：策略结果可视化图表
-
-3. **控制台输出**：
-   - 策略分析结果
-   - 收益统计
-   - 风险指标
-
-## 策略分析指标
-
-### 收益指标
-- 总收益率
-- 年化收益率
-- 最终资金
-
-### 风险指标
-- 年化波动率
-- 夏普比率
-- 胜率
-- 最大回撤
-
-### 交易统计
-- 买入信号数量
-- 卖出信号数量
-- 总交易次数
-
-## 策略逻辑详解
-
-### 1. 均线计算
-```python
-# 计算短期和长期均线
-short_ma = price_data.rolling(window=short_window).mean()
-long_ma = price_data.rolling(window=long_window).mean()
-```
-
-### 2. 交叉信号判断
-```python
-# 计算均线差值
-diff = short_ma - long_ma
-
-# 金叉：短期均线从下方穿越长期均线
-if diff.iloc[i-1] < 0 and diff.iloc[i] > 0:
-    signal = 1  # 买入信号
-
-# 死叉：短期均线从上方穿越长期均线
-elif diff.iloc[i-1] > 0 and diff.iloc[i] < 0:
-    signal = -1  # 卖出信号
-```
-
-### 3. 收益计算
-```python
-# 策略收益（简化处理）
-strategy_returns = signals * 0.01
-
-# 累计收益
-cumulative_returns = strategy_returns.sum(axis=1).cumsum()
-```
-
-## 注意事项
-
-1. **数据依赖**：确保qlib数据已正确下载和配置
-2. **参数调优**：可以根据不同市场环境调整均线周期
-3. **风险控制**：实际交易中需要加入止损和仓位管理
-4. **交易成本**：当前版本未考虑交易费用，实际应用需要考虑
-
-## 扩展功能
-
-可以基于此策略进行以下扩展：
-
-1. **多均线策略**：使用多条均线进行更复杂的信号判断
-2. **量价配合**：结合成交量指标优化信号
-3. **止损机制**：添加动态止损策略
-4. **仓位管理**：根据信号强度调整仓位大小
-5. **多股票组合**：构建股票组合分散风险
-
-## 常见问题
-
-### Q: 如何修改股票池？
-A: 在代码中修改 `instruments` 参数，例如：
-```python
-instruments = "csi500"  # 中证500
-instruments = ["000001.SZ", "000002.SZ"]  # 指定股票列表
-```
-
-### Q: 如何调整均线周期？
-A: 修改 `short_window` 和 `long_window` 参数：
-```python
-short_window = 10  # 10日均线
-long_window = 30   # 30日均线
-```
-
-### Q: 如何查看详细的交易记录？
-A: 查看生成的 `ma_cross_signals.csv` 文件，其中包含每日的买卖信号。
-
-## 联系方式
-
-如有问题或建议，请通过以下方式联系：
-- 提交Issue到项目仓库
-- 发送邮件到项目维护者
-
----
-
-**免责声明**：本策略仅供学习和研究使用，不构成投资建议。实际投资请谨慎决策，并承担相应风险。 
\ No newline at end of file
diff --git a/test/damo1.py b/test/damo1.py
index 03102e1..afa2886 100644
--- a/test/damo1.py
+++ b/test/damo1.py
@@ -1,9 +1,35 @@
-# python scripts/get_data.py qlib_data --target_dir ../qlib_data/cn_data --region cn
-
 import qlib
-# region in [REG_CN, REG_US]
-from qlib.constant import REG_CN
-provider_uri = "D:/project/tradenote/qlib_data/cn_data"  # target_dir
-qlib.init(provider_uri=provider_uri, region=REG_CN)
+from qlib.data import D
+
+# 初始化 Qlib
+qlib.init(provider_uri="D:/sync/qlib/qlib_data/cn_data", region="cn")
+
+# 检查目标股票和基准
+stock_code = "SZ000858"  # 你的BuyHold策略用的股票代码
+benchmark = "SH000300"
+
+print("--- 检查可用股票列表（前10只） ---")
+print(list(D.instruments(market="all"))[:10])
+
+print("--- 检查交易日（2017-01-01 ~ 2020-08-01，前10天） ---")
+print(D.calendar(start_time="2017-01-01", end_time="2020-08-01")[:10])
+
+print(f"--- 检查目标股票 {stock_code} 是否在股票池 ---")
+print(stock_code in D.instruments(market="all"))
+
+print(f"--- 检查基准 {benchmark} 是否在股票池 ---")
+print(benchmark in D.instruments(market="all"))
+
+print(f"--- 检查目标股票 {stock_code} 的行情数据（前5行） ---")
+try:
+    df = D.features([stock_code], ["$close", "$open", "$high", "$low", "$volume"], start_time="2017-01-01", end_time="2020-08-01")
+    print(df.head())
+except Exception as e:
+    print(f"获取行情数据失败: {e}")
 
-# qrun benchmarks/LightGBM/workflow_config_lightgbm_Alpha1582.yaml
+print(f"--- 检查基准 {benchmark} 的行情数据（前5行） ---")
+try:
+    df_bench = D.features([benchmark], ["$close"], start_time="2017-01-01", end_time="2020-08-01")
+    print(df_bench.head())
+except Exception as e:
+    print(f"获取基准行情数据失败: {e}")
diff --git a/test/demo2.ipynb b/test/demo2.ipynb
index 66a0215..842a49e 100644
--- a/test/demo2.ipynb
+++ b/test/demo2.ipynb
@@ -2,7 +2,7 @@
  "cells": [
   {
    "cell_type": "code",
-   "execution_count": 4,
+   "execution_count": 12,
    "id": "6acb4a77",
    "metadata": {},
    "outputs": [
@@ -10,39 +10,205 @@
      "name": "stderr",
      "output_type": "stream",
      "text": [
-      "[5344:MainThread](2025-06-18 14:41:03,895) INFO - qlib.Initialization - [config.py:420] - default_conf: client.\n",
-      "[5344:MainThread](2025-06-18 14:41:03,900) INFO - qlib.Initialization - [__init__.py:74] - qlib successfully initialized based on client settings.\n",
-      "[5344:MainThread](2025-06-18 14:41:03,903) INFO - qlib.Initialization - [__init__.py:76] - data_path={'__DEFAULT_FREQ': WindowsPath('D:/sync/qlib/qlib_data/cn_data')}\n"
+      "[13736:MainThread](2025-06-19 15:30:19,504) INFO - qlib.Initialization - [config.py:420] - default_conf: client.\n",
+      "[13736:MainThread](2025-06-19 15:30:19,506) INFO - qlib.Initialization - [__init__.py:74] - qlib successfully initialized based on client settings.\n",
+      "[13736:MainThread](2025-06-19 15:30:19,508) INFO - qlib.Initialization - [__init__.py:76] - data_path={'__DEFAULT_FREQ': WindowsPath('D:/sync/qlib/qlib_data/cn_data')}\n"
      ]
     }
    ],
    "source": [
     "import qlib\n",
-    "qlib.init(provider_uri=\"D:/sync/qlib/qlib_data/cn_data\", region=\"cn\")"
+    "qlib.init(provider_uri=r\"D:\\sync\\qlib\\qlib_data\\cn_data\", region=\"cn\")"
    ]
   },
   {
    "cell_type": "code",
-   "execution_count": 12,
+   "execution_count": 14,
    "id": "295df9af",
    "metadata": {},
    "outputs": [
     {
      "data": {
       "text/plain": [
-       "array([Timestamp('2020-09-21 00:00:00'), Timestamp('2020-09-22 00:00:00'),\n",
-       "       Timestamp('2020-09-23 00:00:00'), Timestamp('2020-09-24 00:00:00'),\n",
-       "       Timestamp('2020-09-25 00:00:00')], dtype=object)"
+       "array([Timestamp('2017-01-03 00:00:00'), Timestamp('2017-01-04 00:00:00'),\n",
+       "       Timestamp('2017-01-05 00:00:00'), Timestamp('2017-01-06 00:00:00'),\n",
+       "       Timestamp('2017-01-09 00:00:00')], dtype=object)"
       ]
      },
-     "execution_count": 12,
+     "execution_count": 14,
      "metadata": {},
      "output_type": "execute_result"
     }
    ],
    "source": [
     "from qlib.data import D\n",
-    "D.calendar(start_time='2020-09-21', end_time='2020-10-30', freq='day')"
+    "D.calendar(start_time=\"2017-01-01\", end_time=\"2020-08-01\",freq=\"day\")[:5]"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": 24,
+   "id": "da009afa",
+   "metadata": {},
+   "outputs": [
+    {
+     "data": {
+      "text/html": [
+       "<div>\n",
+       "<style scoped>\n",
+       "    .dataframe tbody tr th:only-of-type {\n",
+       "        vertical-align: middle;\n",
+       "    }\n",
+       "\n",
+       "    .dataframe tbody tr th {\n",
+       "        vertical-align: top;\n",
+       "    }\n",
+       "\n",
+       "    .dataframe thead th {\n",
+       "        text-align: right;\n",
+       "    }\n",
+       "</style>\n",
+       "<table border=\"1\" class=\"dataframe\">\n",
+       "  <thead>\n",
+       "    <tr style=\"text-align: right;\">\n",
+       "      <th></th>\n",
+       "      <th></th>\n",
+       "      <th>$close</th>\n",
+       "      <th>$open</th>\n",
+       "      <th>$high</th>\n",
+       "      <th>$low</th>\n",
+       "      <th>$volume</th>\n",
+       "    </tr>\n",
+       "    <tr>\n",
+       "      <th>instrument</th>\n",
+       "      <th>datetime</th>\n",
+       "      <th></th>\n",
+       "      <th></th>\n",
+       "      <th></th>\n",
+       "      <th></th>\n",
+       "      <th></th>\n",
+       "    </tr>\n",
+       "  </thead>\n",
+       "  <tbody>\n",
+       "    <tr>\n",
+       "      <th rowspan=\"11\" valign=\"top\">SZ000858</th>\n",
+       "      <th>2017-01-03</th>\n",
+       "      <td>11.301954</td>\n",
+       "      <td>11.243259</td>\n",
+       "      <td>11.373693</td>\n",
+       "      <td>11.184565</td>\n",
+       "      <td>47640796.0</td>\n",
+       "    </tr>\n",
+       "    <tr>\n",
+       "      <th>2017-01-04</th>\n",
+       "      <td>11.706295</td>\n",
+       "      <td>11.301954</td>\n",
+       "      <td>11.722599</td>\n",
+       "      <td>11.266086</td>\n",
+       "      <td>141233984.0</td>\n",
+       "    </tr>\n",
+       "    <tr>\n",
+       "      <th>2017-01-05</th>\n",
+       "      <td>11.716078</td>\n",
+       "      <td>11.748685</td>\n",
+       "      <td>11.817163</td>\n",
+       "      <td>11.641079</td>\n",
+       "      <td>79170360.0</td>\n",
+       "    </tr>\n",
+       "    <tr>\n",
+       "      <th>2017-01-06</th>\n",
+       "      <td>11.771510</td>\n",
+       "      <td>11.716077</td>\n",
+       "      <td>11.934550</td>\n",
+       "      <td>11.660643</td>\n",
+       "      <td>103201592.0</td>\n",
+       "    </tr>\n",
+       "    <tr>\n",
+       "      <th>2017-01-09</th>\n",
+       "      <td>11.885638</td>\n",
+       "      <td>11.738902</td>\n",
+       "      <td>11.999766</td>\n",
+       "      <td>11.716077</td>\n",
+       "      <td>81857808.0</td>\n",
+       "    </tr>\n",
+       "    <tr>\n",
+       "      <th>...</th>\n",
+       "      <td>...</td>\n",
+       "      <td>...</td>\n",
+       "      <td>...</td>\n",
+       "      <td>...</td>\n",
+       "      <td>...</td>\n",
+       "    </tr>\n",
+       "    <tr>\n",
+       "      <th>2020-07-27</th>\n",
+       "      <td>71.358727</td>\n",
+       "      <td>71.110489</td>\n",
+       "      <td>72.302719</td>\n",
+       "      <td>70.418228</td>\n",
+       "      <td>69948368.0</td>\n",
+       "    </tr>\n",
+       "    <tr>\n",
+       "      <th>2020-07-28</th>\n",
+       "      <td>74.816528</td>\n",
+       "      <td>71.984558</td>\n",
+       "      <td>75.847931</td>\n",
+       "      <td>71.558014</td>\n",
+       "      <td>108913296.0</td>\n",
+       "    </tr>\n",
+       "    <tr>\n",
+       "      <th>2020-07-29</th>\n",
+       "      <td>75.173149</td>\n",
+       "      <td>74.942398</td>\n",
+       "      <td>75.337471</td>\n",
+       "      <td>73.075386</td>\n",
+       "      <td>85012816.0</td>\n",
+       "    </tr>\n",
+       "    <tr>\n",
+       "      <th>2020-07-30</th>\n",
+       "      <td>75.704582</td>\n",
+       "      <td>74.820023</td>\n",
+       "      <td>76.236015</td>\n",
+       "      <td>74.470398</td>\n",
+       "      <td>71618128.0</td>\n",
+       "    </tr>\n",
+       "    <tr>\n",
+       "      <th>2020-07-31</th>\n",
+       "      <td>76.054207</td>\n",
+       "      <td>75.697586</td>\n",
+       "      <td>77.270905</td>\n",
+       "      <td>74.917923</td>\n",
+       "      <td>74252152.0</td>\n",
+       "    </tr>\n",
+       "  </tbody>\n",
+       "</table>\n",
+       "<p>871 rows × 5 columns</p>\n",
+       "</div>"
+      ],
+      "text/plain": [
+       "                          $close      $open      $high       $low      $volume\n",
+       "instrument datetime                                                           \n",
+       "SZ000858   2017-01-03  11.301954  11.243259  11.373693  11.184565   47640796.0\n",
+       "           2017-01-04  11.706295  11.301954  11.722599  11.266086  141233984.0\n",
+       "           2017-01-05  11.716078  11.748685  11.817163  11.641079   79170360.0\n",
+       "           2017-01-06  11.771510  11.716077  11.934550  11.660643  103201592.0\n",
+       "           2017-01-09  11.885638  11.738902  11.999766  11.716077   81857808.0\n",
+       "...                          ...        ...        ...        ...          ...\n",
+       "           2020-07-27  71.358727  71.110489  72.302719  70.418228   69948368.0\n",
+       "           2020-07-28  74.816528  71.984558  75.847931  71.558014  108913296.0\n",
+       "           2020-07-29  75.173149  74.942398  75.337471  73.075386   85012816.0\n",
+       "           2020-07-30  75.704582  74.820023  76.236015  74.470398   71618128.0\n",
+       "           2020-07-31  76.054207  75.697586  77.270905  74.917923   74252152.0\n",
+       "\n",
+       "[871 rows x 5 columns]"
+      ]
+     },
+     "execution_count": 24,
+     "metadata": {},
+     "output_type": "execute_result"
+    }
+   ],
+   "source": [
+    "D.features([\"SZ000858\"], [\"$close\", \"$open\", \"$high\", \"$low\", \"$volume\"], start_time=\"2017-01-01\", end_time=\"2020-08-01\")"
    ]
   }
  ],
diff --git a/test/ma_cross_strategy.py b/test/ma_cross_strategy.py
deleted file mode 100644
index 719d849..0000000
--- a/test/ma_cross_strategy.py
+++ /dev/null
@@ -1,274 +0,0 @@
-"""
-均线交叉策略：金叉买入，死叉卖出
-使用qlib框架实现
-"""
-
-import qlib
-from qlib.constant import REG_CN
-from qlib.utils import init_instance_by_config
-from qlib.workflow import R
-from qlib.workflow.record_temp import SignalRecord, PortAnaRecord
-from qlib.contrib.evaluate import backtest_daily
-from qlib.contrib.strategy import TopkDropoutStrategy
-import pandas as pd
-import numpy as np
-from typing import Dict, List, Tuple
-
-
-class MACrossStrategy(TopkDropoutStrategy):
-    """
-    均线交叉策略
-    金叉（短期均线上穿长期均线）买入
-    死叉（短期均线下穿长期均线）卖出
-    """
-    
-    def __init__(self, 
-                 short_window: int = 5,
-                 long_window: int = 20,
-                 topk: int = 50,
-                 n_drop: int = 5,
-                 **kwargs):
-        """
-        初始化策略参数
-        
-        Args:
-            short_window: 短期均线周期
-            long_window: 长期均线周期
-            topk: 选择前k只股票
-            n_drop: 剔除前n只股票
-        """
-        super().__init__(topk=topk, n_drop=n_drop, **kwargs)
-        self.short_window = short_window
-        self.long_window = long_window
-        
-    def generate_trade_decision(self, score: pd.Series, trade_step: int) -> pd.Series:
-        """
-        生成交易决策
-        
-        Args:
-            score: 股票评分
-            trade_step: 交易步骤
-            
-        Returns:
-            交易决策，1表示买入，-1表示卖出，0表示持有
-        """
-        # 获取当前持仓
-        current_pos = self.get_current_position()
-        
-        # 计算均线信号
-        signal = self._calculate_ma_signal(score.index.tolist(), trade_step)
-        
-        # 生成交易决策
-        decision = pd.Series(0, index=score.index)
-        
-        # 金叉买入信号
-        buy_signal = signal == 1
-        decision[buy_signal] = 1
-        
-        # 死叉卖出信号
-        sell_signal = signal == -1
-        decision[sell_signal] = -1
-        
-        return decision
-    
-    def _calculate_ma_signal(self, instruments: List[str], trade_step: int) -> pd.Series:
-        """
-        计算均线交叉信号
-        
-        Args:
-            instruments: 股票代码列表
-            trade_step: 交易步骤
-            
-        Returns:
-            信号序列：1表示金叉买入，-1表示死叉卖出，0表示无信号
-        """
-        # 获取历史数据
-        data = self._get_historical_data(instruments, trade_step)
-        
-        signals = pd.Series(0, index=instruments)
-        
-        for instrument in instruments:
-            if instrument in data.index:
-                # 计算短期和长期均线
-                short_ma = data.loc[instrument].rolling(window=self.short_window).mean()
-                long_ma = data.loc[instrument].rolling(window=self.long_window).mean()
-                
-                # 计算交叉信号
-                if len(short_ma) >= 2 and len(long_ma) >= 2:
-                    # 当前和前一个时间点的均线差值
-                    current_diff = short_ma.iloc[-1] - long_ma.iloc[-1]
-                    prev_diff = short_ma.iloc[-2] - long_ma.iloc[-2]
-                    
-                    # 金叉：短期均线从下方穿越长期均线
-                    if prev_diff < 0 and current_diff > 0:
-                        signals[instrument] = 1
-                    # 死叉：短期均线从上方穿越长期均线
-                    elif prev_diff > 0 and current_diff < 0:
-                        signals[instrument] = -1
-        
-        return signals
-    
-    def _get_historical_data(self, instruments: List[str], trade_step: int) -> pd.DataFrame:
-        """
-        获取历史价格数据
-        
-        Args:
-            instruments: 股票代码列表
-            trade_step: 交易步骤
-            
-        Returns:
-            历史价格数据
-        """
-        # 这里简化处理，实际应该从qlib数据源获取
-        # 在实际应用中，您需要使用qlib的数据接口
-        try:
-            # 获取最近的数据用于计算均线
-            # 这里使用模拟数据，实际应该从qlib获取
-            dates = pd.date_range(end=pd.Timestamp.now(), periods=50, freq='D')
-            data = pd.DataFrame(
-                np.random.randn(len(dates), len(instruments)) * 0.02 + 1.0,
-                index=dates,
-                columns=instruments
-            )
-            return data
-        except Exception as e:
-            print(f"获取历史数据失败: {e}")
-            return pd.DataFrame()
-
-
-def create_ma_cross_strategy_config():
-    """
-    创建均线交叉策略配置
-    """
-    strategy_config = {
-        "class": "MACrossStrategy",
-        "module_path": "test.ma_cross_strategy",
-        "kwargs": {
-            "short_window": 5,
-            "long_window": 20,
-            "topk": 50,
-            "n_drop": 5,
-        }
-    }
-    
-    return strategy_config
-
-
-def run_backtest():
-    """
-    运行回测
-    """
-    # 初始化qlib
-    qlib.init(provider_uri='~/.qlib/qlib_data/cn_data', region=REG_CN)
-    
-    # 策略配置
-    strategy_config = create_ma_cross_strategy_config()
-    
-    # 回测配置
-    backtest_config = {
-        "start_time": "2020-01-01",
-        "end_time": "2023-12-31",
-        "benchmark": "SH000300",  # 沪深300作为基准
-        "account": 100000000,     # 初始资金1亿
-        "exchange_kwargs": {
-            "freq": "day",
-            "limit_threshold": 0.095,
-            "deal_price": "close",
-            "open_cost": 0.0005,
-            "close_cost": 0.0015,
-            "min_cost": 5,
-        }
-    }
-    
-    # 创建策略实例
-    strategy = init_instance_by_config(strategy_config)
-    
-    # 运行回测
-    with R.start(experiment_name="ma_cross_strategy"):
-        # 记录信号
-        sr = SignalRecord(model=strategy, dataset=None, recorder=R.get_recorder())
-        sr.generate()
-        
-        # 记录投资组合分析
-        par = PortAnaRecord(recorder=R.get_recorder(), config=backtest_config, strategy=strategy)
-        par.generate()
-        
-        # 获取回测结果
-        report_normal, positions_normal = backtest_daily(
-            account=backtest_config["account"],
-            benchmark=backtest_config["benchmark"],
-            start_time=backtest_config["start_time"],
-            end_time=backtest_config["end_time"],
-            strategy=strategy,
-            exchange_kwargs=backtest_config["exchange_kwargs"]
-        )
-        
-        return report_normal, positions_normal
-
-
-def analyze_results(report: pd.DataFrame, positions: pd.DataFrame):
-    """
-    分析回测结果
-    
-    Args:
-        report: 回测报告
-        positions: 持仓信息
-    """
-    print("=" * 50)
-    print("均线交叉策略回测结果")
-    print("=" * 50)
-    
-    # 基本统计信息
-    print(f"总收益率: {report['return'].sum():.2%}")
-    print(f"年化收益率: {report['return'].mean() * 252:.2%}")
-    print(f"最大回撤: {report['drawdown'].min():.2%}")
-    print(f"夏普比率: {report['sharpe'].iloc[-1]:.2f}")
-    print(f"胜率: {(report['return'] > 0).mean():.2%}")
-    
-    # 风险指标
-    volatility = report['return'].std() * np.sqrt(252)
-    print(f"年化波动率: {volatility:.2%}")
-    
-    # 最大回撤期间
-    max_drawdown_idx = report['drawdown'].idxmin()
-    print(f"最大回撤发生时间: {max_drawdown_idx}")
-    
-    # 收益分布
-    print("\n收益分布统计:")
-    print(f"平均日收益: {report['return'].mean():.2%}")
-    print(f"收益标准差: {report['return'].std():.2%}")
-    print(f"最小日收益: {report['return'].min():.2%}")
-    print(f"最大日收益: {report['return'].max():.2%}")
-    
-    # 交易统计
-    if 'trade_count' in report.columns:
-        print(f"\n总交易次数: {report['trade_count'].sum()}")
-        print(f"平均每日交易次数: {report['trade_count'].mean():.1f}")
-
-
-def main():
-    """
-    主函数
-    """
-    print("开始运行均线交叉策略回测...")
-    
-    try:
-        # 运行回测
-        report, positions = run_backtest()
-        
-        # 分析结果
-        analyze_results(report, positions)
-        
-        # 保存结果
-        report.to_csv("ma_cross_strategy_report.csv")
-        positions.to_csv("ma_cross_strategy_positions.csv")
-        
-        print("\n回测完成！结果已保存到CSV文件。")
-        
-    except Exception as e:
-        print(f"回测过程中出现错误: {e}")
-        print("请确保已正确安装qlib并下载了相应的数据。")
-
-
-if __name__ == "__main__":
-    main() 
\ No newline at end of file
diff --git a/test/ma_cross_strategy_improved.py b/test/ma_cross_strategy_improved.py
deleted file mode 100644
index d166c68..0000000
--- a/test/ma_cross_strategy_improved.py
+++ /dev/null
@@ -1,443 +0,0 @@
-"""
-改进的均线交叉策略：金叉买入，死叉卖出
-使用qlib框架实现，包含完整的数据获取和信号计算
-"""
-
-import qlib
-from qlib.constant import REG_CN
-from qlib.utils import init_instance_by_config
-from qlib.workflow import R
-from qlib.workflow.record_temp import SignalRecord, PortAnaRecord
-from qlib.contrib.evaluate import backtest_daily
-from qlib.contrib.strategy import TopkDropoutStrategy
-from qlib.data import D
-from qlib.data.dataset import DatasetH
-from qlib.data.dataset.handler import DataHandlerLP
-import pandas as pd
-import numpy as np
-from typing import Dict, List, Tuple
-import warnings
-warnings.filterwarnings('ignore')
-
-
-class MACrossStrategyImproved(TopkDropoutStrategy):
-    """
-    改进的均线交叉策略
-    金叉（短期均线上穿长期均线）买入
-    死叉（短期均线下穿长期均线）卖出
-    """
-    
-    def __init__(self, 
-                 short_window: int = 5,
-                 long_window: int = 20,
-                 topk: int = 50,
-                 n_drop: int = 5,
-                 universe: str = "csi300",
-                 **kwargs):
-        """
-        初始化策略参数
-        
-        Args:
-            short_window: 短期均线周期
-            long_window: 长期均线周期
-            topk: 选择前k只股票
-            n_drop: 剔除前n只股票
-            universe: 股票池
-        """
-        super().__init__(topk=topk, n_drop=n_drop, **kwargs)
-        self.short_window = short_window
-        self.long_window = long_window
-        self.universe = universe
-        self.instruments = None
-        self.price_cache = {}
-        
-    def generate_trade_decision(self, score: pd.Series, trade_step: int) -> pd.Series:
-        """
-        生成交易决策
-        
-        Args:
-            score: 股票评分
-            trade_step: 交易步骤
-            
-        Returns:
-            交易决策，1表示买入，-1表示卖出，0表示持有
-        """
-        # 获取当前持仓
-        current_pos = self.get_current_position()
-        
-        # 计算均线信号
-        signal = self._calculate_ma_signal(score.index.tolist(), trade_step)
-        
-        # 生成交易决策
-        decision = pd.Series(0, index=score.index)
-        
-        # 金叉买入信号
-        buy_signal = signal == 1
-        decision[buy_signal] = 1
-        
-        # 死叉卖出信号
-        sell_signal = signal == -1
-        decision[sell_signal] = -1
-        
-        return decision
-    
-    def _calculate_ma_signal(self, instruments: List[str], trade_step: int) -> pd.Series:
-        """
-        计算均线交叉信号
-        
-        Args:
-            instruments: 股票代码列表
-            trade_step: 交易步骤
-            
-        Returns:
-            信号序列：1表示金叉买入，-1表示死叉卖出，0表示无信号
-        """
-        signals = pd.Series(0, index=instruments)
-        
-        # 获取当前日期
-        current_date = self._get_current_date(trade_step)
-        
-        for instrument in instruments:
-            try:
-                # 获取历史价格数据
-                price_data = self._get_price_data(instrument, current_date)
-                
-                if price_data is not None and len(price_data) >= self.long_window:
-                    # 计算短期和长期均线
-                    short_ma = price_data['close'].rolling(window=self.short_window).mean()
-                    long_ma = price_data['close'].rolling(window=self.long_window).mean()
-                    
-                    # 计算交叉信号
-                    if len(short_ma) >= 2 and len(long_ma) >= 2:
-                        # 当前和前一个时间点的均线差值
-                        current_diff = short_ma.iloc[-1] - long_ma.iloc[-1]
-                        prev_diff = short_ma.iloc[-2] - long_ma.iloc[-2]
-                        
-                        # 金叉：短期均线从下方穿越长期均线
-                        if prev_diff < 0 and current_diff > 0:
-                            signals[instrument] = 1
-                        # 死叉：短期均线从上方穿越长期均线
-                        elif prev_diff > 0 and current_diff < 0:
-                            signals[instrument] = -1
-                            
-            except Exception as e:
-                print(f"计算{instrument}均线信号时出错: {e}")
-                continue
-        
-        return signals
-    
-    def _get_price_data(self, instrument: str, current_date: str) -> pd.DataFrame:
-        """
-        获取股票价格数据
-        
-        Args:
-            instrument: 股票代码
-            current_date: 当前日期
-            
-        Returns:
-            价格数据DataFrame
-        """
-        try:
-            # 计算开始日期（获取足够的历史数据来计算均线）
-            start_date = pd.Timestamp(current_date) - pd.Timedelta(days=self.long_window * 2)
-            
-            # 从qlib获取数据
-            data = D.features(
-                instruments=[instrument],
-                start_time=start_date.strftime('%Y-%m-%d'),
-                end_time=current_date,
-                freq='day',
-                fields=['$close', '$open', '$high', '$low', '$volume']
-            )
-            
-            if data is not None and not data.empty:
-                # 重命名列
-                data.columns = ['close', 'open', 'high', 'low', 'volume']
-                return data
-            else:
-                return None
-                
-        except Exception as e:
-            print(f"获取{instrument}价格数据失败: {e}")
-            return None
-    
-    def _get_current_date(self, trade_step: int) -> str:
-        """
-        根据交易步骤获取当前日期
-        
-        Args:
-            trade_step: 交易步骤
-            
-        Returns:
-            当前日期字符串
-        """
-        # 这里简化处理，实际应该从qlib的日历获取
-        # 假设从2020-01-01开始，每个trade_step代表一天
-        start_date = pd.Timestamp('2020-01-01')
-        current_date = start_date + pd.Timedelta(days=trade_step)
-        return current_date.strftime('%Y-%m-%d')
-
-
-def create_dataset_config():
-    """
-    创建数据集配置
-    """
-    dataset_config = {
-        "class": "DatasetH",
-        "module_path": "qlib.data.dataset",
-        "kwargs": {
-            "handler": {
-                "class": "DataHandlerLP",
-                "module_path": "qlib.data.dataset.handler",
-                "kwargs": {
-                    "start_time": "2020-01-01",
-                    "end_time": "2023-12-31",
-                    "fit_start_time": "2020-01-01",
-                    "fit_end_time": "2023-12-31",
-                    "instruments": "csi300",
-                    "infer_processors": [
-                        {
-                            "class": "RobustZScoreNorm",
-                            "module_path": "qlib.data.dataset.processor",
-                            "kwargs": {
-                                "fields_group": "feature",
-                                "clip_outlier": True,
-                            },
-                        },
-                        {
-                            "class": "Fillna",
-                            "module_path": "qlib.data.dataset.processor",
-                            "kwargs": {
-                                "fields_group": "feature",
-                            },
-                        },
-                    ],
-                    "learn_processors": [
-                        {
-                            "class": "DropnaLabel",
-                            "module_path": "qlib.data.dataset.processor",
-                        },
-                        {
-                            "class": "CSRankNorm",
-                            "module_path": "qlib.data.dataset.processor",
-                            "kwargs": {
-                                "fields_group": "label",
-                            },
-                        },
-                    ],
-                    "instruments": "csi300",
-                },
-            },
-            "segments": {
-                "train": ("2020-01-01", "2022-12-31"),
-                "valid": ("2023-01-01", "2023-06-30"),
-                "test": ("2023-07-01", "2023-12-31"),
-            },
-        },
-    }
-    
-    return dataset_config
-
-
-def create_ma_cross_strategy_config():
-    """
-    创建均线交叉策略配置
-    """
-    strategy_config = {
-        "class": "MACrossStrategyImproved",
-        "module_path": "test.ma_cross_strategy_improved",
-        "kwargs": {
-            "short_window": 5,
-            "long_window": 20,
-            "topk": 50,
-            "n_drop": 5,
-            "universe": "csi300",
-        }
-    }
-    
-    return strategy_config
-
-
-def run_backtest():
-    """
-    运行回测
-    """
-    # 初始化qlib
-    qlib.init(provider_uri='~/.qlib/qlib_data/cn_data', region=REG_CN)
-    
-    # 策略配置
-    strategy_config = create_ma_cross_strategy_config()
-    
-    # 回测配置
-    backtest_config = {
-        "start_time": "2020-01-01",
-        "end_time": "2023-12-31",
-        "benchmark": "SH000300",  # 沪深300作为基准
-        "account": 100000000,     # 初始资金1亿
-        "exchange_kwargs": {
-            "freq": "day",
-            "limit_threshold": 0.095,
-            "deal_price": "close",
-            "open_cost": 0.0005,
-            "close_cost": 0.0015,
-            "min_cost": 5,
-        }
-    }
-    
-    # 创建策略实例
-    strategy = init_instance_by_config(strategy_config)
-    
-    # 运行回测
-    with R.start(experiment_name="ma_cross_strategy_improved"):
-        # 记录信号
-        sr = SignalRecord(model=strategy, dataset=None, recorder=R.get_recorder())
-        sr.generate()
-        
-        # 记录投资组合分析
-        par = PortAnaRecord(recorder=R.get_recorder(), config=backtest_config, strategy=strategy)
-        par.generate()
-        
-        # 获取回测结果
-        report_normal, positions_normal = backtest_daily(
-            account=backtest_config["account"],
-            benchmark=backtest_config["benchmark"],
-            start_time=backtest_config["start_time"],
-            end_time=backtest_config["end_time"],
-            strategy=strategy,
-            exchange_kwargs=backtest_config["exchange_kwargs"]
-        )
-        
-        return report_normal, positions_normal
-
-
-def analyze_results(report: pd.DataFrame, positions: pd.DataFrame):
-    """
-    分析回测结果
-    
-    Args:
-        report: 回测报告
-        positions: 持仓信息
-    """
-    print("=" * 50)
-    print("均线交叉策略回测结果")
-    print("=" * 50)
-    
-    # 基本统计信息
-    print(f"总收益率: {report['return'].sum():.2%}")
-    print(f"年化收益率: {report['return'].mean() * 252:.2%}")
-    print(f"最大回撤: {report['drawdown'].min():.2%}")
-    
-    if 'sharpe' in report.columns:
-        print(f"夏普比率: {report['sharpe'].iloc[-1]:.2f}")
-    
-    print(f"胜率: {(report['return'] > 0).mean():.2%}")
-    
-    # 风险指标
-    volatility = report['return'].std() * np.sqrt(252)
-    print(f"年化波动率: {volatility:.2%}")
-    
-    # 最大回撤期间
-    max_drawdown_idx = report['drawdown'].idxmin()
-    print(f"最大回撤发生时间: {max_drawdown_idx}")
-    
-    # 收益分布
-    print("\n收益分布统计:")
-    print(f"平均日收益: {report['return'].mean():.2%}")
-    print(f"收益标准差: {report['return'].std():.2%}")
-    print(f"最小日收益: {report['return'].min():.2%}")
-    print(f"最大日收益: {report['return'].max():.2%}")
-    
-    # 交易统计
-    if 'trade_count' in report.columns:
-        print(f"\n总交易次数: {report['trade_count'].sum()}")
-        print(f"平均每日交易次数: {report['trade_count'].mean():.1f}")
-
-
-def create_simple_backtest():
-    """
-    创建简化版回测，用于演示
-    """
-    print("创建简化版均线交叉策略回测...")
-    
-    # 初始化qlib
-    qlib.init(provider_uri='~/.qlib/qlib_data/cn_data', region=REG_CN)
-    
-    # 获取股票列表
-    instruments = D.list_instruments(instruments="csi300", start_time="2020-01-01", end_time="2023-12-31")
-    
-    print(f"获取到 {len(instruments)} 只股票")
-    
-    # 选择前10只股票进行演示
-    demo_instruments = instruments[:10]
-    
-    # 获取价格数据
-    data = D.features(
-        instruments=demo_instruments,
-        start_time="2020-01-01",
-        end_time="2023-12-31",
-        freq='day',
-        fields=['$close']
-    )
-    
-    print(f"获取到价格数据，形状: {data.shape}")
-    
-    # 计算均线
-    short_ma = data.rolling(window=5).mean()
-    long_ma = data.rolling(window=20).mean()
-    
-    # 计算交叉信号
-    signals = pd.DataFrame(0, index=data.index, columns=data.columns)
-    
-    for col in data.columns:
-        # 计算均线差值
-        diff = short_ma[col] - long_ma[col]
-        
-        # 计算交叉信号
-        for i in range(1, len(diff)):
-            if diff.iloc[i-1] < 0 and diff.iloc[i] > 0:
-                signals.iloc[i, signals.columns.get_loc(col)] = 1  # 金叉买入
-            elif diff.iloc[i-1] > 0 and diff.iloc[i] < 0:
-                signals.iloc[i, signals.columns.get_loc(col)] = -1  # 死叉卖出
-    
-    # 统计信号
-    buy_signals = (signals == 1).sum().sum()
-    sell_signals = (signals == -1).sum().sum()
-    
-    print(f"\n信号统计:")
-    print(f"买入信号数量: {buy_signals}")
-    print(f"卖出信号数量: {sell_signals}")
-    
-    # 计算简单收益（假设每次信号都产生1%的收益）
-    returns = signals * 0.01
-    cumulative_returns = returns.sum(axis=1).cumsum()
-    
-    print(f"\n累计收益: {cumulative_returns.iloc[-1]:.2%}")
-    
-    return signals, cumulative_returns
-
-
-def main():
-    """
-    主函数
-    """
-    print("开始运行均线交叉策略回测...")
-    
-    try:
-        # 运行简化版回测
-        signals, cumulative_returns = create_simple_backtest()
-        
-        # 保存简化版结果
-        signals.to_csv("ma_cross_signals.csv")
-        cumulative_returns.to_csv("ma_cross_cumulative_returns.csv")
-        
-        print("\n简化版回测完成！")
-        print("信号数据已保存到 ma_cross_signals.csv")
-        print("累计收益已保存到 ma_cross_cumulative_returns.csv")
-        
-    except Exception as e:
-        print(f"回测过程中出现错误: {e}")
-        print("请确保已正确安装qlib并下载了相应的数据。")
-
-
-if __name__ == "__main__":
-    main() 
\ No newline at end of file
diff --git a/test/ma_strategy_demo.py b/test/ma_strategy_demo.py
deleted file mode 100644
index 1fa4fb4..0000000
Binary files a/test/ma_strategy_demo.py and /dev/null differ
diff --git a/test/simple_ma_strategy.py b/test/simple_ma_strategy.py
deleted file mode 100644
index 8d03f6b..0000000
--- a/test/simple_ma_strategy.py
+++ /dev/null
@@ -1,298 +0,0 @@
-"""
-简单实用的均线交叉策略
-金叉买入，死叉卖出
-"""
-
-import qlib
-from qlib.constant import REG_CN
-from qlib.data import D
-import pandas as pd
-import numpy as np
-import matplotlib.pyplot as plt
-from datetime import datetime, timedelta
-
-
-def init_qlib():
-    """初始化qlib"""
-    try:
-        qlib.init(provider_uri='~/.qlib/qlib_data/cn_data', region=REG_CN)
-        print("qlib初始化成功")
-        return True
-    except Exception as e:
-        print(f"qlib初始化失败: {e}")
-        print("请确保已安装qlib并下载了数据")
-        return False
-
-
-def get_stock_data(instruments, start_date, end_date):
-    """
-    获取股票数据
-    
-    Args:
-        instruments: 股票代码列表
-        start_date: 开始日期
-        end_date: 结束日期
-    
-    Returns:
-        股票价格数据
-    """
-    try:
-        data = D.features(
-            instruments=instruments,
-            start_time=start_date,
-            end_time=end_date,
-            freq='day',
-            fields=['$close', '$open', '$high', '$low', '$volume']
-        )
-        
-        if data is not None and not data.empty:
-            # 重命名列
-            data.columns = ['close', 'open', 'high', 'low', 'volume']
-            return data
-        else:
-            print("未获取到数据")
-            return None
-            
-    except Exception as e:
-        print(f"获取数据失败: {e}")
-        return None
-
-
-def calculate_ma_signals(data, short_window=5, long_window=20):
-    """
-    计算均线交叉信号
-    
-    Args:
-        data: 价格数据
-        short_window: 短期均线周期
-        long_window: 长期均线周期
-    
-    Returns:
-        信号DataFrame，1表示买入，-1表示卖出，0表示无信号
-    """
-    signals = pd.DataFrame(0, index=data.index, columns=data.columns)
-    
-    for col in data.columns:
-        if col == 'close':
-            continue
-            
-        # 计算均线
-        short_ma = data[col].rolling(window=short_window).mean()
-        long_ma = data[col].rolling(window=long_window).mean()
-        
-        # 计算均线差值
-        diff = short_ma - long_ma
-        
-        # 计算交叉信号
-        for i in range(1, len(diff)):
-            if pd.notna(diff.iloc[i-1]) and pd.notna(diff.iloc[i]):
-                # 金叉：短期均线从下方穿越长期均线
-                if diff.iloc[i-1] < 0 and diff.iloc[i] > 0:
-                    signals.iloc[i, signals.columns.get_loc(col)] = 1
-                # 死叉：短期均线从上方穿越长期均线
-                elif diff.iloc[i-1] > 0 and diff.iloc[i] < 0:
-                    signals.iloc[i, signals.columns.get_loc(col)] = -1
-    
-    return signals
-
-
-def calculate_returns(data, signals, initial_capital=100000):
-    """
-    计算策略收益
-    
-    Args:
-        data: 价格数据
-        signals: 信号数据
-        initial_capital: 初始资金
-    
-    Returns:
-        收益数据
-    """
-    # 计算日收益率
-    returns = data.pct_change()
-    
-    # 策略收益（假设每次信号产生1%的收益）
-    strategy_returns = signals * 0.01
-    
-    # 累计收益
-    cumulative_returns = strategy_returns.sum(axis=1).cumsum()
-    
-    # 资金曲线
-    capital_curve = initial_capital * (1 + cumulative_returns)
-    
-    return {
-        'strategy_returns': strategy_returns,
-        'cumulative_returns': cumulative_returns,
-        'capital_curve': capital_curve
-    }
-
-
-def analyze_strategy(signals, returns_data):
-    """
-    分析策略表现
-    
-    Args:
-        signals: 信号数据
-        returns_data: 收益数据
-    """
-    print("=" * 50)
-    print("均线交叉策略分析结果")
-    print("=" * 50)
-    
-    # 信号统计
-    buy_signals = (signals == 1).sum().sum()
-    sell_signals = (signals == -1).sum().sum()
-    
-    print(f"买入信号数量: {buy_signals}")
-    print(f"卖出信号数量: {sell_signals}")
-    print(f"总信号数量: {buy_signals + sell_signals}")
-    
-    # 收益统计
-    cumulative_returns = returns_data['cumulative_returns']
-    capital_curve = returns_data['capital_curve']
-    
-    total_return = cumulative_returns.iloc[-1]
-    annual_return = total_return / (len(cumulative_returns) / 252)
-    
-    print(f"\n收益统计:")
-    print(f"总收益率: {total_return:.2%}")
-    print(f"年化收益率: {annual_return:.2%}")
-    print(f"最终资金: {capital_curve.iloc[-1]:,.0f}")
-    
-    # 风险统计
-    daily_returns = returns_data['strategy_returns'].sum(axis=1)
-    volatility = daily_returns.std() * np.sqrt(252)
-    sharpe_ratio = annual_return / volatility if volatility > 0 else 0
-    
-    print(f"\n风险统计:")
-    print(f"年化波动率: {volatility:.2%}")
-    print(f"夏普比率: {sharpe_ratio:.2f}")
-    print(f"胜率: {(daily_returns > 0).mean():.2%}")
-
-
-def plot_results(data, signals, returns_data, stock_code):
-    """
-    绘制结果图表
-    
-    Args:
-        data: 价格数据
-        signals: 信号数据
-        returns_data: 收益数据
-        stock_code: 股票代码
-    """
-    fig, axes = plt.subplots(3, 1, figsize=(12, 10))
-    
-    # 绘制价格和均线
-    axes[0].plot(data.index, data[stock_code], label='收盘价', alpha=0.7)
-    short_ma = data[stock_code].rolling(window=5).mean()
-    long_ma = data[stock_code].rolling(window=20).mean()
-    axes[0].plot(data.index, short_ma, label='5日均线', alpha=0.8)
-    axes[0].plot(data.index, long_ma, label='20日均线', alpha=0.8)
-    
-    # 标记买卖信号
-    buy_signals = signals[stock_code] == 1
-    sell_signals = signals[stock_code] == -1
-    
-    axes[0].scatter(data.index[buy_signals], data.loc[buy_signals, stock_code], 
-                   color='red', marker='^', s=100, label='买入信号', alpha=0.8)
-    axes[0].scatter(data.index[sell_signals], data.loc[sell_signals, stock_code], 
-                   color='green', marker='v', s=100, label='卖出信号', alpha=0.8)
-    
-    axes[0].set_title(f'{stock_code} 价格走势与均线交叉信号')
-    axes[0].legend()
-    axes[0].grid(True, alpha=0.3)
-    
-    # 绘制累计收益
-    axes[1].plot(returns_data['cumulative_returns'].index, 
-                returns_data['cumulative_returns'].values, 
-                label='累计收益', color='blue')
-    axes[1].set_title('策略累计收益')
-    axes[1].legend()
-    axes[1].grid(True, alpha=0.3)
-    
-    # 绘制资金曲线
-    axes[2].plot(returns_data['capital_curve'].index, 
-                returns_data['capital_curve'].values, 
-                label='资金曲线', color='green')
-    axes[2].set_title('资金曲线')
-    axes[2].legend()
-    axes[2].grid(True, alpha=0.3)
-    
-    plt.tight_layout()
-    plt.savefig('ma_cross_strategy_results.png', dpi=300, bbox_inches='tight')
-    plt.show()
-
-
-def main():
-    """
-    主函数
-    """
-    print("开始运行均线交叉策略...")
-    
-    # 初始化qlib
-    if not init_qlib():
-        return
-    
-    # 策略参数
-    start_date = "2020-01-01"
-    end_date = "2023-12-31"
-    short_window = 5
-    long_window = 20
-    initial_capital = 100000
-    
-    # 获取股票列表
-    try:
-        instruments = D.list_instruments(instruments="csi300", start_time=start_date, end_time=end_date)
-        print(f"获取到 {len(instruments)} 只股票")
-        
-        # 选择前5只股票进行演示
-        demo_instruments = instruments[:5]
-        print(f"选择演示股票: {demo_instruments}")
-        
-    except Exception as e:
-        print(f"获取股票列表失败: {e}")
-        # 使用默认股票列表
-        demo_instruments = ['000001.SZ', '000002.SZ', '000858.SZ', '002415.SZ', '600036.SH']
-        print(f"使用默认股票列表: {demo_instruments}")
-    
-    # 获取价格数据
-    data = get_stock_data(demo_instruments, start_date, end_date)
-    
-    if data is None:
-        print("无法获取数据，程序退出")
-        return
-    
-    print(f"获取到价格数据，形状: {data.shape}")
-    
-    # 计算均线信号
-    signals = calculate_ma_signals(data, short_window, long_window)
-    
-    # 计算收益
-    returns_data = calculate_returns(data, signals, initial_capital)
-    
-    # 分析策略
-    analyze_strategy(signals, returns_data)
-    
-    # 保存结果
-    signals.to_csv("ma_cross_signals.csv")
-    returns_data['cumulative_returns'].to_csv("ma_cross_cumulative_returns.csv")
-    returns_data['capital_curve'].to_csv("ma_cross_capital_curve.csv")
-    
-    print("\n结果已保存到CSV文件:")
-    print("- ma_cross_signals.csv: 买卖信号")
-    print("- ma_cross_cumulative_returns.csv: 累计收益")
-    print("- ma_cross_capital_curve.csv: 资金曲线")
-    
-    # 绘制图表（选择第一只股票）
-    if len(demo_instruments) > 0:
-        try:
-            plot_results(data, signals, returns_data, demo_instruments[0])
-            print("图表已保存为 ma_cross_strategy_results.png")
-        except Exception as e:
-            print(f"绘制图表失败: {e}")
-    
-    print("\n策略回测完成！")
-
-
-if __name__ == "__main__":
-    main() 
\ No newline at end of file
diff --git a/test/two_ema_stragety.py b/test/two_ema_stragety.py
index a72e7e8..a9890c7 100644
--- a/test/two_ema_stragety.py
+++ b/test/two_ema_stragety.py
@@ -1,2 +1,98 @@
-from qlib.contrib.strategy import 
-from qlib.backtest import backtest
\ No newline at end of file
+import pandas as pd
+
+from abc import ABC
+from typing import Dict, List, Text, Tuple, Union
+from qlib.data.dataset import Dataset
+from qlib.model.base import BaseModel
+from qlib.backtest.signal import Signal, create_signal_from
+from qlib.strategy.base import BaseStrategy
+from qlib.backtest.decision import Order, OrderDir, OrderHelper, TradeDecisionWO
+# from qlib.strategy import 
+# from qlib.backtest import backtest
+
+class InnerStrategy(BaseStrategy):
+    """
+    Inner strategy for order execution:
+    - Buy: if price < 200, buy all cash; else buy 200,000 worth.
+    - Sell: if price > 200, sell all; else sell half.
+    """
+    STOCK_CODE = "000858.SZ"
+
+    def generate_trade_decision(self, execute_result: list = None, action: str = None, amount: float = None):
+        # action: 'buy' or 'sell', amount: suggested amount (shares) from outer
+        position = self.trade_position
+        trade_step = self.trade_calendar.get_trade_step()
+        trade_start_time, trade_end_time = self.trade_calendar.get_step_time(trade_step)
+        order_helper = self.trade_exchange.get_order_helper()
+        orders = []
+        price = self.trade_exchange.get_deal_price(self.STOCK_CODE, trade_start_time, trade_end_time)
+        if action == 'buy':
+            cash = position.get_cash()
+            if price <= 0:
+                return TradeDecisionWO([], self)
+            if price < 200:
+                buy_amount = cash // price
+            else:
+                buy_amount = min(cash // price, 200000 // price)
+            buy_amount = int(buy_amount)
+            if buy_amount > 0:
+                order = order_helper.create(
+                    code=self.STOCK_CODE,
+                    amount=buy_amount,
+                    direction=OrderDir.BUY,
+                    start_time=trade_start_time,
+                    end_time=trade_end_time,
+                )
+                orders.append(order)
+        elif action == 'sell':
+            held_amount = position.get_stock_amount(self.STOCK_CODE)
+            if held_amount <= 0 or price <= 0:
+                return TradeDecisionWO([], self)
+            if price > 200:
+                sell_amount = held_amount
+            else:
+                sell_amount = held_amount // 2
+            sell_amount = int(sell_amount)
+            if sell_amount > 0:
+                order = order_helper.create(
+                    code=self.STOCK_CODE,
+                    amount=sell_amount,
+                    direction=OrderDir.SELL,
+                    start_time=trade_start_time,
+                    end_time=trade_end_time,
+                )
+                orders.append(order)
+        return TradeDecisionWO(orders, self)
+
+class OuterStrategy(BaseStrategy):
+    """
+    Outer strategy:
+    - If not holding Wuliangye, issues a buy order via inner strategy.
+    - If holding, checks if held for 25 days, if so, issues a sell order via inner strategy.
+    - Otherwise, holds.
+    """
+    STOCK_CODE = "000858.SZ"
+    HOLD_DAYS = 25
+    BAR = "day"
+
+    def __init__(self, *args, **kwargs):
+        super().__init__(*args, **kwargs)
+        self.inner_strategy = InnerStrategy()
+
+    def generate_trade_decision(self, execute_result: list = None):
+        position = self.trade_position
+        stock_list = position.get_stock_list()
+        trade_step = self.trade_calendar.get_trade_step()
+        trade_start_time, trade_end_time = self.trade_calendar.get_step_time(trade_step)
+        # Pass infra to inner strategy
+        self.inner_strategy.reset(level_infra=self.level_infra, common_infra=self.common_infra)
+        if self.STOCK_CODE in stock_list:
+            hold_days = position.get_stock_count(self.STOCK_CODE, self.BAR)
+            if hold_days >= self.HOLD_DAYS:
+                # Sell via inner strategy
+                return self.inner_strategy.generate_trade_decision(action='sell')
+        else:
+            # Buy via inner strategy
+            return self.inner_strategy.generate_trade_decision(action='buy')
+        # Otherwise, hold
+        return TradeDecisionWO([], self)
\ No newline at end of file
