diff --git a/github/examples/mlruns/881301994755452456/157579a2201241aaafcff94e93d7da0e/artifacts/code_cached.txt b/github/examples/mlruns/881301994755452456/157579a2201241aaafcff94e93d7da0e/artifacts/code_cached.txt
new file mode 100644
index 0000000..e69de29
diff --git a/github/examples/mlruns/881301994755452456/157579a2201241aaafcff94e93d7da0e/artifacts/code_diff.txt b/github/examples/mlruns/881301994755452456/157579a2201241aaafcff94e93d7da0e/artifacts/code_diff.txt
new file mode 100644
index 0000000..9f92fc1
--- /dev/null
+++ b/github/examples/mlruns/881301994755452456/157579a2201241aaafcff94e93d7da0e/artifacts/code_diff.txt
@@ -0,0 +1,1473 @@
+diff --git a/github/examples/benchmarks/LightGBM/workflow_config_lightgbm_Alpha1582.yaml b/github/examples/benchmarks/LightGBM/workflow_config_lightgbm_Alpha1582.yaml
+index 8b4e7bf..7a5eee7 100644
+--- a/github/examples/benchmarks/LightGBM/workflow_config_lightgbm_Alpha1582.yaml
++++ b/github/examples/benchmarks/LightGBM/workflow_config_lightgbm_Alpha1582.yaml
+@@ -1,5 +1,5 @@
+ qlib_init:
+-    provider_uri: "D:/project/tradenote/qlib_data/cn_data"
++    provider_uri: "D:/sync/qlib/qlib_data/cn_data"
+     region: cn
+ market: &market csi300
+ benchmark: &benchmark SH000300
+diff --git a/test/README_MA_Strategy.md b/test/README_MA_Strategy.md
+deleted file mode 100644
+index 5facaf7..0000000
+--- a/test/README_MA_Strategy.md
++++ /dev/null
+@@ -1,197 +0,0 @@
+-# 均线交叉策略 (Moving Average Crossover Strategy)
+-
+-## 策略概述
+-
+-这是一个基于qlib框架实现的均线交叉策略，核心逻辑是：
+-- **金叉买入**：短期均线上穿长期均线时买入
+-- **死叉卖出**：短期均线下穿长期均线时卖出
+-
+-## 文件说明
+-
+-### 1. `ma_cross_strategy.py`
+-完整的策略实现，包含：
+-- `MACrossStrategy` 类：继承自qlib的TopkDropoutStrategy
+-- 完整的回测框架
+-- 结果分析和保存
+-
+-### 2. `ma_cross_strategy_improved.py`
+-改进版本，包含：
+-- 更完善的数据获取逻辑
+-- 错误处理机制
+-- 简化版回测功能
+-
+-### 3. `simple_ma_strategy.py` ⭐ **推荐使用**
+-简单实用的版本，包含：
+-- 清晰的数据获取和处理
+-- 均线信号计算
+-- 收益计算和分析
+-- 可视化图表生成
+-- 结果保存功能
+-
+-## 使用方法
+-
+-### 环境准备
+-
+-1. 确保已安装qlib：
+-```bash
+-pip install pyqlib
+-```
+-
+-2. 下载qlib数据（如果还没有）：
+-```bash
+-# 下载中国股票数据
+-python -m qlib.data.dump_bin --csv_path ~/.qlib/qlib_data/cn_data --include_fields close,open,high,low,volume
+-```
+-
+-### 运行策略
+-
+-#### 方法1：运行简单版本（推荐）
+-```bash
+-cd test
+-python simple_ma_strategy.py
+-```
+-
+-#### 方法2：运行完整版本
+-```bash
+-cd test
+-python ma_cross_strategy.py
+-```
+-
+-#### 方法3：运行改进版本
+-```bash
+-cd test
+-python ma_cross_strategy_improved.py
+-```
+-
+-## 策略参数
+-
+-可以在代码中修改以下参数：
+-
+-```python
+-# 均线周期
+-short_window = 5    # 短期均线周期
+-long_window = 20    # 长期均线周期
+-
+-# 回测时间
+-start_date = "2020-01-01"
+-end_date = "2023-12-31"
+-
+-# 初始资金
+-initial_capital = 100000
+-
+-# 股票池
+-instruments = "csi300"  # 沪深300成分股
+-```
+-
+-## 输出结果
+-
+-运行策略后会生成以下文件：
+-
+-1. **CSV文件**：
+-   - `ma_cross_signals.csv`：买卖信号数据
+-   - `ma_cross_cumulative_returns.csv`：累计收益数据
+-   - `ma_cross_capital_curve.csv`：资金曲线数据
+-
+-2. **图表文件**：
+-   - `ma_cross_strategy_results.png`：策略结果可视化图表
+-
+-3. **控制台输出**：
+-   - 策略分析结果
+-   - 收益统计
+-   - 风险指标
+-
+-## 策略分析指标
+-
+-### 收益指标
+-- 总收益率
+-- 年化收益率
+-- 最终资金
+-
+-### 风险指标
+-- 年化波动率
+-- 夏普比率
+-- 胜率
+-- 最大回撤
+-
+-### 交易统计
+-- 买入信号数量
+-- 卖出信号数量
+-- 总交易次数
+-
+-## 策略逻辑详解
+-
+-### 1. 均线计算
+-```python
+-# 计算短期和长期均线
+-short_ma = price_data.rolling(window=short_window).mean()
+-long_ma = price_data.rolling(window=long_window).mean()
+-```
+-
+-### 2. 交叉信号判断
+-```python
+-# 计算均线差值
+-diff = short_ma - long_ma
+-
+-# 金叉：短期均线从下方穿越长期均线
+-if diff.iloc[i-1] < 0 and diff.iloc[i] > 0:
+-    signal = 1  # 买入信号
+-
+-# 死叉：短期均线从上方穿越长期均线
+-elif diff.iloc[i-1] > 0 and diff.iloc[i] < 0:
+-    signal = -1  # 卖出信号
+-```
+-
+-### 3. 收益计算
+-```python
+-# 策略收益（简化处理）
+-strategy_returns = signals * 0.01
+-
+-# 累计收益
+-cumulative_returns = strategy_returns.sum(axis=1).cumsum()
+-```
+-
+-## 注意事项
+-
+-1. **数据依赖**：确保qlib数据已正确下载和配置
+-2. **参数调优**：可以根据不同市场环境调整均线周期
+-3. **风险控制**：实际交易中需要加入止损和仓位管理
+-4. **交易成本**：当前版本未考虑交易费用，实际应用需要考虑
+-
+-## 扩展功能
+-
+-可以基于此策略进行以下扩展：
+-
+-1. **多均线策略**：使用多条均线进行更复杂的信号判断
+-2. **量价配合**：结合成交量指标优化信号
+-3. **止损机制**：添加动态止损策略
+-4. **仓位管理**：根据信号强度调整仓位大小
+-5. **多股票组合**：构建股票组合分散风险
+-
+-## 常见问题
+-
+-### Q: 如何修改股票池？
+-A: 在代码中修改 `instruments` 参数，例如：
+-```python
+-instruments = "csi500"  # 中证500
+-instruments = ["000001.SZ", "000002.SZ"]  # 指定股票列表
+-```
+-
+-### Q: 如何调整均线周期？
+-A: 修改 `short_window` 和 `long_window` 参数：
+-```python
+-short_window = 10  # 10日均线
+-long_window = 30   # 30日均线
+-```
+-
+-### Q: 如何查看详细的交易记录？
+-A: 查看生成的 `ma_cross_signals.csv` 文件，其中包含每日的买卖信号。
+-
+-## 联系方式
+-
+-如有问题或建议，请通过以下方式联系：
+-- 提交Issue到项目仓库
+-- 发送邮件到项目维护者
+-
+----
+-
+-**免责声明**：本策略仅供学习和研究使用，不构成投资建议。实际投资请谨慎决策，并承担相应风险。 
+\ No newline at end of file
+diff --git a/test/damo1.py b/test/damo1.py
+index 03102e1..7142dd1 100644
+--- a/test/damo1.py
++++ b/test/damo1.py
+@@ -1,5 +1,5 @@
+-# python scripts/get_data.py qlib_data --target_dir ../qlib_data/cn_data --region cn
+-
++# python github/scripts/get_data.py qlib_data --target_dir D:/sync/qlib/qlib_data/cn_data --region cn
++D:/sync/qlib/qlib_data/cn_data
+ import qlib
+ # region in [REG_CN, REG_US]
+ from qlib.constant import REG_CN
+diff --git a/test/demo2.ipynb b/test/demo2.ipynb
+index 66a0215..ad02df5 100644
+--- a/test/demo2.ipynb
++++ b/test/demo2.ipynb
+@@ -2,7 +2,7 @@
+  "cells": [
+   {
+    "cell_type": "code",
+-   "execution_count": 4,
++   "execution_count": 12,
+    "id": "6acb4a77",
+    "metadata": {},
+    "outputs": [
+@@ -10,39 +10,75 @@
+      "name": "stderr",
+      "output_type": "stream",
+      "text": [
+-      "[5344:MainThread](2025-06-18 14:41:03,895) INFO - qlib.Initialization - [config.py:420] - default_conf: client.\n",
+-      "[5344:MainThread](2025-06-18 14:41:03,900) INFO - qlib.Initialization - [__init__.py:74] - qlib successfully initialized based on client settings.\n",
+-      "[5344:MainThread](2025-06-18 14:41:03,903) INFO - qlib.Initialization - [__init__.py:76] - data_path={'__DEFAULT_FREQ': WindowsPath('D:/sync/qlib/qlib_data/cn_data')}\n"
++      "[13736:MainThread](2025-06-19 15:30:19,504) INFO - qlib.Initialization - [config.py:420] - default_conf: client.\n",
++      "[13736:MainThread](2025-06-19 15:30:19,506) INFO - qlib.Initialization - [__init__.py:74] - qlib successfully initialized based on client settings.\n",
++      "[13736:MainThread](2025-06-19 15:30:19,508) INFO - qlib.Initialization - [__init__.py:76] - data_path={'__DEFAULT_FREQ': WindowsPath('D:/sync/qlib/qlib_data/cn_data')}\n"
+      ]
+     }
+    ],
+    "source": [
+     "import qlib\n",
+-    "qlib.init(provider_uri=\"D:/sync/qlib/qlib_data/cn_data\", region=\"cn\")"
++    "qlib.init(provider_uri=r\"D:\\sync\\qlib\\qlib_data\\cn_data\", region=\"cn\")"
+    ]
+   },
+   {
+    "cell_type": "code",
+-   "execution_count": 12,
++   "execution_count": 14,
+    "id": "295df9af",
+    "metadata": {},
+    "outputs": [
+     {
+      "data": {
+       "text/plain": [
+-       "array([Timestamp('2020-09-21 00:00:00'), Timestamp('2020-09-22 00:00:00'),\n",
+-       "       Timestamp('2020-09-23 00:00:00'), Timestamp('2020-09-24 00:00:00'),\n",
+-       "       Timestamp('2020-09-25 00:00:00')], dtype=object)"
++       "array([Timestamp('2017-01-03 00:00:00'), Timestamp('2017-01-04 00:00:00'),\n",
++       "       Timestamp('2017-01-05 00:00:00'), Timestamp('2017-01-06 00:00:00'),\n",
++       "       Timestamp('2017-01-09 00:00:00')], dtype=object)"
+       ]
+      },
+-     "execution_count": 12,
++     "execution_count": 14,
+      "metadata": {},
+      "output_type": "execute_result"
+     }
+    ],
+    "source": [
+     "from qlib.data import D\n",
+-    "D.calendar(start_time='2020-09-21', end_time='2020-10-30', freq='day')"
++    "D.calendar(start_time=\"2017-01-01\", end_time=\"2020-08-01\",freq=\"day\")[:5]"
++   ]
++  },
++  {
++   "cell_type": "code",
++   "execution_count": 21,
++   "id": "da009afa",
++   "metadata": {},
++   "outputs": [
++    {
++     "ename": "error",
++     "evalue": "nothing to repeat at position 0",
++     "output_type": "error",
++     "traceback": [
++      "\u001b[31m---------------------------------------------------------------------------\u001b[39m",
++      "\u001b[31merror\u001b[39m                                     Traceback (most recent call last)",
++      "\u001b[36mCell\u001b[39m\u001b[36m \u001b[39m\u001b[32mIn[21]\u001b[39m\u001b[32m, line 4\u001b[39m\n\u001b[32m      2\u001b[39m nameDFilter = NameDFilter(name_rule_re=\u001b[33m'\u001b[39m\u001b[33m*000858\u001b[39m\u001b[33m'\u001b[39m)\n\u001b[32m      3\u001b[39m instruments = D.instruments(market=\u001b[33m'\u001b[39m\u001b[33mall\u001b[39m\u001b[33m'\u001b[39m,filter_pipe=[nameDFilter])\n\u001b[32m----> \u001b[39m\u001b[32m4\u001b[39m \u001b[43mD\u001b[49m\u001b[43m.\u001b[49m\u001b[43mlist_instruments\u001b[49m\u001b[43m(\u001b[49m\u001b[43minstruments\u001b[49m\u001b[43m=\u001b[49m\u001b[43minstruments\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mstart_time\u001b[49m\u001b[43m=\u001b[49m\u001b[33;43m'\u001b[39;49m\u001b[33;43m2015-01-01\u001b[39;49m\u001b[33;43m'\u001b[39;49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mend_time\u001b[49m\u001b[43m=\u001b[49m\u001b[33;43m'\u001b[39;49m\u001b[33;43m2016-02-15\u001b[39;49m\u001b[33;43m'\u001b[39;49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mas_list\u001b[49m\u001b[43m=\u001b[49m\u001b[38;5;28;43;01mTrue\u001b[39;49;00m\u001b[43m)\u001b[49m\n",
++      "\u001b[36mFile \u001b[39m\u001b[32md:\\project\\python\\tradenote\\.venv\\Lib\\site-packages\\qlib\\data\\data.py:1160\u001b[39m, in \u001b[36mBaseProvider.list_instruments\u001b[39m\u001b[34m(self, instruments, start_time, end_time, freq, as_list)\u001b[39m\n\u001b[32m   1159\u001b[39m \u001b[38;5;28;01mdef\u001b[39;00m\u001b[38;5;250m \u001b[39m\u001b[34mlist_instruments\u001b[39m(\u001b[38;5;28mself\u001b[39m, instruments, start_time=\u001b[38;5;28;01mNone\u001b[39;00m, end_time=\u001b[38;5;28;01mNone\u001b[39;00m, freq=\u001b[33m\"\u001b[39m\u001b[33mday\u001b[39m\u001b[33m\"\u001b[39m, as_list=\u001b[38;5;28;01mFalse\u001b[39;00m):\n\u001b[32m-> \u001b[39m\u001b[32m1160\u001b[39m     \u001b[38;5;28;01mreturn\u001b[39;00m \u001b[43mInst\u001b[49m\u001b[43m.\u001b[49m\u001b[43mlist_instruments\u001b[49m\u001b[43m(\u001b[49m\u001b[43minstruments\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mstart_time\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mend_time\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mfreq\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mas_list\u001b[49m\u001b[43m)\u001b[49m\n",
++      "\u001b[36mFile \u001b[39m\u001b[32md:\\project\\python\\tradenote\\.venv\\Lib\\site-packages\\qlib\\data\\data.py:719\u001b[39m, in \u001b[36mLocalInstrumentProvider.list_instruments\u001b[39m\u001b[34m(self, instruments, start_time, end_time, freq, as_list)\u001b[39m\n\u001b[32m    716\u001b[39m     \u001b[38;5;28;01mfrom\u001b[39;00m\u001b[38;5;250m \u001b[39m\u001b[34;01m.\u001b[39;00m\u001b[38;5;250m \u001b[39m\u001b[38;5;28;01mimport\u001b[39;00m \u001b[38;5;28mfilter\u001b[39m \u001b[38;5;28;01mas\u001b[39;00m F  \u001b[38;5;66;03m# pylint: disable=C0415\u001b[39;00m\n\u001b[32m    718\u001b[39m     filter_t = \u001b[38;5;28mgetattr\u001b[39m(F, filter_config[\u001b[33m\"\u001b[39m\u001b[33mfilter_type\u001b[39m\u001b[33m\"\u001b[39m]).from_config(filter_config)\n\u001b[32m--> \u001b[39m\u001b[32m719\u001b[39m     _instruments_filtered = \u001b[43mfilter_t\u001b[49m\u001b[43m(\u001b[49m\u001b[43m_instruments_filtered\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mstart_time\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mend_time\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mfreq\u001b[49m\u001b[43m)\u001b[49m\n\u001b[32m    720\u001b[39m \u001b[38;5;66;03m# as list\u001b[39;00m\n\u001b[32m    721\u001b[39m \u001b[38;5;28;01mif\u001b[39;00m as_list:\n",
++      "\u001b[36mFile \u001b[39m\u001b[32md:\\project\\python\\tradenote\\.venv\\Lib\\site-packages\\qlib\\data\\filter.py:192\u001b[39m, in \u001b[36mSeriesDFilter.__call__\u001b[39m\u001b[34m(self, instruments, start_time, end_time, freq)\u001b[39m\n\u001b[32m    190\u001b[39m \u001b[38;5;250m\u001b[39m\u001b[33;03m\"\"\"Call this filter to get filtered instruments list\"\"\"\u001b[39;00m\n\u001b[32m    191\u001b[39m \u001b[38;5;28mself\u001b[39m.filter_freq = freq\n\u001b[32m--> \u001b[39m\u001b[32m192\u001b[39m \u001b[38;5;28;01mreturn\u001b[39;00m \u001b[38;5;28;43mself\u001b[39;49m\u001b[43m.\u001b[49m\u001b[43mfilter_main\u001b[49m\u001b[43m(\u001b[49m\u001b[43minstruments\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mstart_time\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mend_time\u001b[49m\u001b[43m)\u001b[49m\n",
++      "\u001b[36mFile \u001b[39m\u001b[32md:\\project\\python\\tradenote\\.venv\\Lib\\site-packages\\qlib\\data\\filter.py:243\u001b[39m, in \u001b[36mSeriesDFilter.filter_main\u001b[39m\u001b[34m(self, instruments, start_time, end_time)\u001b[39m\n\u001b[32m    237\u001b[39m _all_calendar = Cal.calendar(start_time=start_time, end_time=end_time, freq=\u001b[38;5;28mself\u001b[39m.filter_freq)\n\u001b[32m    238\u001b[39m _filter_calendar = Cal.calendar(\n\u001b[32m    239\u001b[39m     start_time=\u001b[38;5;28mself\u001b[39m.filter_start_time \u001b[38;5;129;01mand\u001b[39;00m \u001b[38;5;28mmax\u001b[39m(\u001b[38;5;28mself\u001b[39m.filter_start_time, _all_calendar[\u001b[32m0\u001b[39m]) \u001b[38;5;129;01mor\u001b[39;00m _all_calendar[\u001b[32m0\u001b[39m],\n\u001b[32m    240\u001b[39m     end_time=\u001b[38;5;28mself\u001b[39m.filter_end_time \u001b[38;5;129;01mand\u001b[39;00m \u001b[38;5;28mmin\u001b[39m(\u001b[38;5;28mself\u001b[39m.filter_end_time, _all_calendar[-\u001b[32m1\u001b[39m]) \u001b[38;5;129;01mor\u001b[39;00m _all_calendar[-\u001b[32m1\u001b[39m],\n\u001b[32m    241\u001b[39m     freq=\u001b[38;5;28mself\u001b[39m.filter_freq,\n\u001b[32m    242\u001b[39m )\n\u001b[32m--> \u001b[39m\u001b[32m243\u001b[39m _all_filter_series = \u001b[38;5;28;43mself\u001b[39;49m\u001b[43m.\u001b[49m\u001b[43m_getFilterSeries\u001b[49m\u001b[43m(\u001b[49m\u001b[43minstruments\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43m_filter_calendar\u001b[49m\u001b[43m[\u001b[49m\u001b[32;43m0\u001b[39;49m\u001b[43m]\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43m_filter_calendar\u001b[49m\u001b[43m[\u001b[49m\u001b[43m-\u001b[49m\u001b[32;43m1\u001b[39;49m\u001b[43m]\u001b[49m\u001b[43m)\u001b[49m\n\u001b[32m    244\u001b[39m \u001b[38;5;28;01mfor\u001b[39;00m inst, timestamp \u001b[38;5;129;01min\u001b[39;00m instruments.items():\n\u001b[32m    245\u001b[39m     \u001b[38;5;66;03m# Construct a whole map of date\u001b[39;00m\n\u001b[32m    246\u001b[39m     _timestamp_series = \u001b[38;5;28mself\u001b[39m._toSeries(_all_calendar, timestamp)\n",
++      "\u001b[36mFile \u001b[39m\u001b[32md:\\project\\python\\tradenote\\.venv\\Lib\\site-packages\\qlib\\data\\filter.py:288\u001b[39m, in \u001b[36mNameDFilter._getFilterSeries\u001b[39m\u001b[34m(self, instruments, fstart, fend)\u001b[39m\n\u001b[32m    286\u001b[39m filter_calendar = Cal.calendar(start_time=fstart, end_time=fend, freq=\u001b[38;5;28mself\u001b[39m.filter_freq)\n\u001b[32m    287\u001b[39m \u001b[38;5;28;01mfor\u001b[39;00m inst, timestamp \u001b[38;5;129;01min\u001b[39;00m instruments.items():\n\u001b[32m--> \u001b[39m\u001b[32m288\u001b[39m     \u001b[38;5;28;01mif\u001b[39;00m \u001b[43mre\u001b[49m\u001b[43m.\u001b[49m\u001b[43mmatch\u001b[49m\u001b[43m(\u001b[49m\u001b[38;5;28;43mself\u001b[39;49m\u001b[43m.\u001b[49m\u001b[43mname_rule_re\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43minst\u001b[49m\u001b[43m)\u001b[49m:\n\u001b[32m    289\u001b[39m         _filter_series = pd.Series({timestamp: \u001b[38;5;28;01mTrue\u001b[39;00m \u001b[38;5;28;01mfor\u001b[39;00m timestamp \u001b[38;5;129;01min\u001b[39;00m filter_calendar})\n\u001b[32m    290\u001b[39m     \u001b[38;5;28;01melse\u001b[39;00m:\n",
++      "\u001b[36mFile \u001b[39m\u001b[32m~\\AppData\\Roaming\\uv\\python\\cpython-3.12.11-windows-x86_64-none\\Lib\\re\\__init__.py:167\u001b[39m, in \u001b[36mmatch\u001b[39m\u001b[34m(pattern, string, flags)\u001b[39m\n\u001b[32m    164\u001b[39m \u001b[38;5;28;01mdef\u001b[39;00m\u001b[38;5;250m \u001b[39m\u001b[34mmatch\u001b[39m(pattern, string, flags=\u001b[32m0\u001b[39m):\n\u001b[32m    165\u001b[39m \u001b[38;5;250m    \u001b[39m\u001b[33;03m\"\"\"Try to apply the pattern at the start of the string, returning\u001b[39;00m\n\u001b[32m    166\u001b[39m \u001b[33;03m    a Match object, or None if no match was found.\"\"\"\u001b[39;00m\n\u001b[32m--> \u001b[39m\u001b[32m167\u001b[39m     \u001b[38;5;28;01mreturn\u001b[39;00m \u001b[43m_compile\u001b[49m\u001b[43m(\u001b[49m\u001b[43mpattern\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mflags\u001b[49m\u001b[43m)\u001b[49m.match(string)\n",
++      "\u001b[36mFile \u001b[39m\u001b[32m~\\AppData\\Roaming\\uv\\python\\cpython-3.12.11-windows-x86_64-none\\Lib\\re\\__init__.py:307\u001b[39m, in \u001b[36m_compile\u001b[39m\u001b[34m(pattern, flags)\u001b[39m\n\u001b[32m    301\u001b[39m     \u001b[38;5;28;01mimport\u001b[39;00m\u001b[38;5;250m \u001b[39m\u001b[34;01mwarnings\u001b[39;00m\n\u001b[32m    302\u001b[39m     warnings.warn(\u001b[33m\"\u001b[39m\u001b[33mThe re.TEMPLATE/re.T flag is deprecated \u001b[39m\u001b[33m\"\u001b[39m\n\u001b[32m    303\u001b[39m             \u001b[33m\"\u001b[39m\u001b[33mas it is an undocumented flag \u001b[39m\u001b[33m\"\u001b[39m\n\u001b[32m    304\u001b[39m             \u001b[33m\"\u001b[39m\u001b[33mwithout an obvious purpose. \u001b[39m\u001b[33m\"\u001b[39m\n\u001b[32m    305\u001b[39m             \u001b[33m\"\u001b[39m\u001b[33mDon\u001b[39m\u001b[33m'\u001b[39m\u001b[33mt use it.\u001b[39m\u001b[33m\"\u001b[39m,\n\u001b[32m    306\u001b[39m             \u001b[38;5;167;01mDeprecationWarning\u001b[39;00m)\n\u001b[32m--> \u001b[39m\u001b[32m307\u001b[39m p = \u001b[43m_compiler\u001b[49m\u001b[43m.\u001b[49m\u001b[43mcompile\u001b[49m\u001b[43m(\u001b[49m\u001b[43mpattern\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mflags\u001b[49m\u001b[43m)\u001b[49m\n\u001b[32m    308\u001b[39m \u001b[38;5;28;01mif\u001b[39;00m flags & DEBUG:\n\u001b[32m    309\u001b[39m     \u001b[38;5;28;01mreturn\u001b[39;00m p\n",
++      "\u001b[36mFile \u001b[39m\u001b[32m~\\AppData\\Roaming\\uv\\python\\cpython-3.12.11-windows-x86_64-none\\Lib\\re\\_compiler.py:750\u001b[39m, in \u001b[36mcompile\u001b[39m\u001b[34m(p, flags)\u001b[39m\n\u001b[32m    748\u001b[39m \u001b[38;5;28;01mif\u001b[39;00m isstring(p):\n\u001b[32m    749\u001b[39m     pattern = p\n\u001b[32m--> \u001b[39m\u001b[32m750\u001b[39m     p = \u001b[43m_parser\u001b[49m\u001b[43m.\u001b[49m\u001b[43mparse\u001b[49m\u001b[43m(\u001b[49m\u001b[43mp\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mflags\u001b[49m\u001b[43m)\u001b[49m\n\u001b[32m    751\u001b[39m \u001b[38;5;28;01melse\u001b[39;00m:\n\u001b[32m    752\u001b[39m     pattern = \u001b[38;5;28;01mNone\u001b[39;00m\n",
++      "\u001b[36mFile \u001b[39m\u001b[32m~\\AppData\\Roaming\\uv\\python\\cpython-3.12.11-windows-x86_64-none\\Lib\\re\\_parser.py:979\u001b[39m, in \u001b[36mparse\u001b[39m\u001b[34m(str, flags, state)\u001b[39m\n\u001b[32m    976\u001b[39m state.flags = flags\n\u001b[32m    977\u001b[39m state.str = \u001b[38;5;28mstr\u001b[39m\n\u001b[32m--> \u001b[39m\u001b[32m979\u001b[39m p = \u001b[43m_parse_sub\u001b[49m\u001b[43m(\u001b[49m\u001b[43msource\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mstate\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mflags\u001b[49m\u001b[43m \u001b[49m\u001b[43m&\u001b[49m\u001b[43m \u001b[49m\u001b[43mSRE_FLAG_VERBOSE\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[32;43m0\u001b[39;49m\u001b[43m)\u001b[49m\n\u001b[32m    980\u001b[39m p.state.flags = fix_flags(\u001b[38;5;28mstr\u001b[39m, p.state.flags)\n\u001b[32m    982\u001b[39m \u001b[38;5;28;01mif\u001b[39;00m source.next \u001b[38;5;129;01mis\u001b[39;00m \u001b[38;5;129;01mnot\u001b[39;00m \u001b[38;5;28;01mNone\u001b[39;00m:\n",
++      "\u001b[36mFile \u001b[39m\u001b[32m~\\AppData\\Roaming\\uv\\python\\cpython-3.12.11-windows-x86_64-none\\Lib\\re\\_parser.py:460\u001b[39m, in \u001b[36m_parse_sub\u001b[39m\u001b[34m(source, state, verbose, nested)\u001b[39m\n\u001b[32m    458\u001b[39m start = source.tell()\n\u001b[32m    459\u001b[39m \u001b[38;5;28;01mwhile\u001b[39;00m \u001b[38;5;28;01mTrue\u001b[39;00m:\n\u001b[32m--> \u001b[39m\u001b[32m460\u001b[39m     itemsappend(\u001b[43m_parse\u001b[49m\u001b[43m(\u001b[49m\u001b[43msource\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mstate\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mverbose\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mnested\u001b[49m\u001b[43m \u001b[49m\u001b[43m+\u001b[49m\u001b[43m \u001b[49m\u001b[32;43m1\u001b[39;49m\u001b[43m,\u001b[49m\n\u001b[32m    461\u001b[39m \u001b[43m                       \u001b[49m\u001b[38;5;129;43;01mnot\u001b[39;49;00m\u001b[43m \u001b[49m\u001b[43mnested\u001b[49m\u001b[43m \u001b[49m\u001b[38;5;129;43;01mand\u001b[39;49;00m\u001b[43m \u001b[49m\u001b[38;5;129;43;01mnot\u001b[39;49;00m\u001b[43m \u001b[49m\u001b[43mitems\u001b[49m\u001b[43m)\u001b[49m)\n\u001b[32m    462\u001b[39m     \u001b[38;5;28;01mif\u001b[39;00m \u001b[38;5;129;01mnot\u001b[39;00m sourcematch(\u001b[33m\"\u001b[39m\u001b[33m|\u001b[39m\u001b[33m\"\u001b[39m):\n\u001b[32m    463\u001b[39m         \u001b[38;5;28;01mbreak\u001b[39;00m\n",
++      "\u001b[36mFile \u001b[39m\u001b[32m~\\AppData\\Roaming\\uv\\python\\cpython-3.12.11-windows-x86_64-none\\Lib\\re\\_parser.py:687\u001b[39m, in \u001b[36m_parse\u001b[39m\u001b[34m(source, state, verbose, nested, first)\u001b[39m\n\u001b[32m    685\u001b[39m     item = \u001b[38;5;28;01mNone\u001b[39;00m\n\u001b[32m    686\u001b[39m \u001b[38;5;28;01mif\u001b[39;00m \u001b[38;5;129;01mnot\u001b[39;00m item \u001b[38;5;129;01mor\u001b[39;00m item[\u001b[32m0\u001b[39m][\u001b[32m0\u001b[39m] \u001b[38;5;129;01mis\u001b[39;00m AT:\n\u001b[32m--> \u001b[39m\u001b[32m687\u001b[39m     \u001b[38;5;28;01mraise\u001b[39;00m source.error(\u001b[33m\"\u001b[39m\u001b[33mnothing to repeat\u001b[39m\u001b[33m\"\u001b[39m,\n\u001b[32m    688\u001b[39m                        source.tell() - here + \u001b[38;5;28mlen\u001b[39m(this))\n\u001b[32m    689\u001b[39m \u001b[38;5;28;01mif\u001b[39;00m item[\u001b[32m0\u001b[39m][\u001b[32m0\u001b[39m] \u001b[38;5;129;01min\u001b[39;00m _REPEATCODES:\n\u001b[32m    690\u001b[39m     \u001b[38;5;28;01mraise\u001b[39;00m source.error(\u001b[33m\"\u001b[39m\u001b[33mmultiple repeat\u001b[39m\u001b[33m\"\u001b[39m,\n\u001b[32m    691\u001b[39m                        source.tell() - here + \u001b[38;5;28mlen\u001b[39m(this))\n",
++      "\u001b[31merror\u001b[39m: nothing to repeat at position 0"
++     ]
++    }
++   ],
++   "source": [
++    "from qlib.data.filter import NameDFilter\n",
++    "nameDFilter = NameDFilter(name_rule_re='*000858')\n",
++    "instruments = D.instruments(market='all',filter_pipe=[nameDFilter])\n",
++    "D.list_instruments(instruments=instruments, start_time='2015-01-01', end_time='2016-02-15', as_list=True)\n"
+    ]
+   }
+  ],
+diff --git a/test/ma_cross_strategy.py b/test/ma_cross_strategy.py
+deleted file mode 100644
+index 719d849..0000000
+--- a/test/ma_cross_strategy.py
++++ /dev/null
+@@ -1,274 +0,0 @@
+-"""
+-均线交叉策略：金叉买入，死叉卖出
+-使用qlib框架实现
+-"""
+-
+-import qlib
+-from qlib.constant import REG_CN
+-from qlib.utils import init_instance_by_config
+-from qlib.workflow import R
+-from qlib.workflow.record_temp import SignalRecord, PortAnaRecord
+-from qlib.contrib.evaluate import backtest_daily
+-from qlib.contrib.strategy import TopkDropoutStrategy
+-import pandas as pd
+-import numpy as np
+-from typing import Dict, List, Tuple
+-
+-
+-class MACrossStrategy(TopkDropoutStrategy):
+-    """
+-    均线交叉策略
+-    金叉（短期均线上穿长期均线）买入
+-    死叉（短期均线下穿长期均线）卖出
+-    """
+-    
+-    def __init__(self, 
+-                 short_window: int = 5,
+-                 long_window: int = 20,
+-                 topk: int = 50,
+-                 n_drop: int = 5,
+-                 **kwargs):
+-        """
+-        初始化策略参数
+-        
+-        Args:
+-            short_window: 短期均线周期
+-            long_window: 长期均线周期
+-            topk: 选择前k只股票
+-            n_drop: 剔除前n只股票
+-        """
+-        super().__init__(topk=topk, n_drop=n_drop, **kwargs)
+-        self.short_window = short_window
+-        self.long_window = long_window
+-        
+-    def generate_trade_decision(self, score: pd.Series, trade_step: int) -> pd.Series:
+-        """
+-        生成交易决策
+-        
+-        Args:
+-            score: 股票评分
+-            trade_step: 交易步骤
+-            
+-        Returns:
+-            交易决策，1表示买入，-1表示卖出，0表示持有
+-        """
+-        # 获取当前持仓
+-        current_pos = self.get_current_position()
+-        
+-        # 计算均线信号
+-        signal = self._calculate_ma_signal(score.index.tolist(), trade_step)
+-        
+-        # 生成交易决策
+-        decision = pd.Series(0, index=score.index)
+-        
+-        # 金叉买入信号
+-        buy_signal = signal == 1
+-        decision[buy_signal] = 1
+-        
+-        # 死叉卖出信号
+-        sell_signal = signal == -1
+-        decision[sell_signal] = -1
+-        
+-        return decision
+-    
+-    def _calculate_ma_signal(self, instruments: List[str], trade_step: int) -> pd.Series:
+-        """
+-        计算均线交叉信号
+-        
+-        Args:
+-            instruments: 股票代码列表
+-            trade_step: 交易步骤
+-            
+-        Returns:
+-            信号序列：1表示金叉买入，-1表示死叉卖出，0表示无信号
+-        """
+-        # 获取历史数据
+-        data = self._get_historical_data(instruments, trade_step)
+-        
+-        signals = pd.Series(0, index=instruments)
+-        
+-        for instrument in instruments:
+-            if instrument in data.index:
+-                # 计算短期和长期均线
+-                short_ma = data.loc[instrument].rolling(window=self.short_window).mean()
+-                long_ma = data.loc[instrument].rolling(window=self.long_window).mean()
+-                
+-                # 计算交叉信号
+-                if len(short_ma) >= 2 and len(long_ma) >= 2:
+-                    # 当前和前一个时间点的均线差值
+-                    current_diff = short_ma.iloc[-1] - long_ma.iloc[-1]
+-                    prev_diff = short_ma.iloc[-2] - long_ma.iloc[-2]
+-                    
+-                    # 金叉：短期均线从下方穿越长期均线
+-                    if prev_diff < 0 and current_diff > 0:
+-                        signals[instrument] = 1
+-                    # 死叉：短期均线从上方穿越长期均线
+-                    elif prev_diff > 0 and current_diff < 0:
+-                        signals[instrument] = -1
+-        
+-        return signals
+-    
+-    def _get_historical_data(self, instruments: List[str], trade_step: int) -> pd.DataFrame:
+-        """
+-        获取历史价格数据
+-        
+-        Args:
+-            instruments: 股票代码列表
+-            trade_step: 交易步骤
+-            
+-        Returns:
+-            历史价格数据
+-        """
+-        # 这里简化处理，实际应该从qlib数据源获取
+-        # 在实际应用中，您需要使用qlib的数据接口
+-        try:
+-            # 获取最近的数据用于计算均线
+-            # 这里使用模拟数据，实际应该从qlib获取
+-            dates = pd.date_range(end=pd.Timestamp.now(), periods=50, freq='D')
+-            data = pd.DataFrame(
+-                np.random.randn(len(dates), len(instruments)) * 0.02 + 1.0,
+-                index=dates,
+-                columns=instruments
+-            )
+-            return data
+-        except Exception as e:
+-            print(f"获取历史数据失败: {e}")
+-            return pd.DataFrame()
+-
+-
+-def create_ma_cross_strategy_config():
+-    """
+-    创建均线交叉策略配置
+-    """
+-    strategy_config = {
+-        "class": "MACrossStrategy",
+-        "module_path": "test.ma_cross_strategy",
+-        "kwargs": {
+-            "short_window": 5,
+-            "long_window": 20,
+-            "topk": 50,
+-            "n_drop": 5,
+-        }
+-    }
+-    
+-    return strategy_config
+-
+-
+-def run_backtest():
+-    """
+-    运行回测
+-    """
+-    # 初始化qlib
+-    qlib.init(provider_uri='~/.qlib/qlib_data/cn_data', region=REG_CN)
+-    
+-    # 策略配置
+-    strategy_config = create_ma_cross_strategy_config()
+-    
+-    # 回测配置
+-    backtest_config = {
+-        "start_time": "2020-01-01",
+-        "end_time": "2023-12-31",
+-        "benchmark": "SH000300",  # 沪深300作为基准
+-        "account": 100000000,     # 初始资金1亿
+-        "exchange_kwargs": {
+-            "freq": "day",
+-            "limit_threshold": 0.095,
+-            "deal_price": "close",
+-            "open_cost": 0.0005,
+-            "close_cost": 0.0015,
+-            "min_cost": 5,
+-        }
+-    }
+-    
+-    # 创建策略实例
+-    strategy = init_instance_by_config(strategy_config)
+-    
+-    # 运行回测
+-    with R.start(experiment_name="ma_cross_strategy"):
+-        # 记录信号
+-        sr = SignalRecord(model=strategy, dataset=None, recorder=R.get_recorder())
+-        sr.generate()
+-        
+-        # 记录投资组合分析
+-        par = PortAnaRecord(recorder=R.get_recorder(), config=backtest_config, strategy=strategy)
+-        par.generate()
+-        
+-        # 获取回测结果
+-        report_normal, positions_normal = backtest_daily(
+-            account=backtest_config["account"],
+-            benchmark=backtest_config["benchmark"],
+-            start_time=backtest_config["start_time"],
+-            end_time=backtest_config["end_time"],
+-            strategy=strategy,
+-            exchange_kwargs=backtest_config["exchange_kwargs"]
+-        )
+-        
+-        return report_normal, positions_normal
+-
+-
+-def analyze_results(report: pd.DataFrame, positions: pd.DataFrame):
+-    """
+-    分析回测结果
+-    
+-    Args:
+-        report: 回测报告
+-        positions: 持仓信息
+-    """
+-    print("=" * 50)
+-    print("均线交叉策略回测结果")
+-    print("=" * 50)
+-    
+-    # 基本统计信息
+-    print(f"总收益率: {report['return'].sum():.2%}")
+-    print(f"年化收益率: {report['return'].mean() * 252:.2%}")
+-    print(f"最大回撤: {report['drawdown'].min():.2%}")
+-    print(f"夏普比率: {report['sharpe'].iloc[-1]:.2f}")
+-    print(f"胜率: {(report['return'] > 0).mean():.2%}")
+-    
+-    # 风险指标
+-    volatility = report['return'].std() * np.sqrt(252)
+-    print(f"年化波动率: {volatility:.2%}")
+-    
+-    # 最大回撤期间
+-    max_drawdown_idx = report['drawdown'].idxmin()
+-    print(f"最大回撤发生时间: {max_drawdown_idx}")
+-    
+-    # 收益分布
+-    print("\n收益分布统计:")
+-    print(f"平均日收益: {report['return'].mean():.2%}")
+-    print(f"收益标准差: {report['return'].std():.2%}")
+-    print(f"最小日收益: {report['return'].min():.2%}")
+-    print(f"最大日收益: {report['return'].max():.2%}")
+-    
+-    # 交易统计
+-    if 'trade_count' in report.columns:
+-        print(f"\n总交易次数: {report['trade_count'].sum()}")
+-        print(f"平均每日交易次数: {report['trade_count'].mean():.1f}")
+-
+-
+-def main():
+-    """
+-    主函数
+-    """
+-    print("开始运行均线交叉策略回测...")
+-    
+-    try:
+-        # 运行回测
+-        report, positions = run_backtest()
+-        
+-        # 分析结果
+-        analyze_results(report, positions)
+-        
+-        # 保存结果
+-        report.to_csv("ma_cross_strategy_report.csv")
+-        positions.to_csv("ma_cross_strategy_positions.csv")
+-        
+-        print("\n回测完成！结果已保存到CSV文件。")
+-        
+-    except Exception as e:
+-        print(f"回测过程中出现错误: {e}")
+-        print("请确保已正确安装qlib并下载了相应的数据。")
+-
+-
+-if __name__ == "__main__":
+-    main() 
+\ No newline at end of file
+diff --git a/test/ma_cross_strategy_improved.py b/test/ma_cross_strategy_improved.py
+deleted file mode 100644
+index d166c68..0000000
+--- a/test/ma_cross_strategy_improved.py
++++ /dev/null
+@@ -1,443 +0,0 @@
+-"""
+-改进的均线交叉策略：金叉买入，死叉卖出
+-使用qlib框架实现，包含完整的数据获取和信号计算
+-"""
+-
+-import qlib
+-from qlib.constant import REG_CN
+-from qlib.utils import init_instance_by_config
+-from qlib.workflow import R
+-from qlib.workflow.record_temp import SignalRecord, PortAnaRecord
+-from qlib.contrib.evaluate import backtest_daily
+-from qlib.contrib.strategy import TopkDropoutStrategy
+-from qlib.data import D
+-from qlib.data.dataset import DatasetH
+-from qlib.data.dataset.handler import DataHandlerLP
+-import pandas as pd
+-import numpy as np
+-from typing import Dict, List, Tuple
+-import warnings
+-warnings.filterwarnings('ignore')
+-
+-
+-class MACrossStrategyImproved(TopkDropoutStrategy):
+-    """
+-    改进的均线交叉策略
+-    金叉（短期均线上穿长期均线）买入
+-    死叉（短期均线下穿长期均线）卖出
+-    """
+-    
+-    def __init__(self, 
+-                 short_window: int = 5,
+-                 long_window: int = 20,
+-                 topk: int = 50,
+-                 n_drop: int = 5,
+-                 universe: str = "csi300",
+-                 **kwargs):
+-        """
+-        初始化策略参数
+-        
+-        Args:
+-            short_window: 短期均线周期
+-            long_window: 长期均线周期
+-            topk: 选择前k只股票
+-            n_drop: 剔除前n只股票
+-            universe: 股票池
+-        """
+-        super().__init__(topk=topk, n_drop=n_drop, **kwargs)
+-        self.short_window = short_window
+-        self.long_window = long_window
+-        self.universe = universe
+-        self.instruments = None
+-        self.price_cache = {}
+-        
+-    def generate_trade_decision(self, score: pd.Series, trade_step: int) -> pd.Series:
+-        """
+-        生成交易决策
+-        
+-        Args:
+-            score: 股票评分
+-            trade_step: 交易步骤
+-            
+-        Returns:
+-            交易决策，1表示买入，-1表示卖出，0表示持有
+-        """
+-        # 获取当前持仓
+-        current_pos = self.get_current_position()
+-        
+-        # 计算均线信号
+-        signal = self._calculate_ma_signal(score.index.tolist(), trade_step)
+-        
+-        # 生成交易决策
+-        decision = pd.Series(0, index=score.index)
+-        
+-        # 金叉买入信号
+-        buy_signal = signal == 1
+-        decision[buy_signal] = 1
+-        
+-        # 死叉卖出信号
+-        sell_signal = signal == -1
+-        decision[sell_signal] = -1
+-        
+-        return decision
+-    
+-    def _calculate_ma_signal(self, instruments: List[str], trade_step: int) -> pd.Series:
+-        """
+-        计算均线交叉信号
+-        
+-        Args:
+-            instruments: 股票代码列表
+-            trade_step: 交易步骤
+-            
+-        Returns:
+-            信号序列：1表示金叉买入，-1表示死叉卖出，0表示无信号
+-        """
+-        signals = pd.Series(0, index=instruments)
+-        
+-        # 获取当前日期
+-        current_date = self._get_current_date(trade_step)
+-        
+-        for instrument in instruments:
+-            try:
+-                # 获取历史价格数据
+-                price_data = self._get_price_data(instrument, current_date)
+-                
+-                if price_data is not None and len(price_data) >= self.long_window:
+-                    # 计算短期和长期均线
+-                    short_ma = price_data['close'].rolling(window=self.short_window).mean()
+-                    long_ma = price_data['close'].rolling(window=self.long_window).mean()
+-                    
+-                    # 计算交叉信号
+-                    if len(short_ma) >= 2 and len(long_ma) >= 2:
+-                        # 当前和前一个时间点的均线差值
+-                        current_diff = short_ma.iloc[-1] - long_ma.iloc[-1]
+-                        prev_diff = short_ma.iloc[-2] - long_ma.iloc[-2]
+-                        
+-                        # 金叉：短期均线从下方穿越长期均线
+-                        if prev_diff < 0 and current_diff > 0:
+-                            signals[instrument] = 1
+-                        # 死叉：短期均线从上方穿越长期均线
+-                        elif prev_diff > 0 and current_diff < 0:
+-                            signals[instrument] = -1
+-                            
+-            except Exception as e:
+-                print(f"计算{instrument}均线信号时出错: {e}")
+-                continue
+-        
+-        return signals
+-    
+-    def _get_price_data(self, instrument: str, current_date: str) -> pd.DataFrame:
+-        """
+-        获取股票价格数据
+-        
+-        Args:
+-            instrument: 股票代码
+-            current_date: 当前日期
+-            
+-        Returns:
+-            价格数据DataFrame
+-        """
+-        try:
+-            # 计算开始日期（获取足够的历史数据来计算均线）
+-            start_date = pd.Timestamp(current_date) - pd.Timedelta(days=self.long_window * 2)
+-            
+-            # 从qlib获取数据
+-            data = D.features(
+-                instruments=[instrument],
+-                start_time=start_date.strftime('%Y-%m-%d'),
+-                end_time=current_date,
+-                freq='day',
+-                fields=['$close', '$open', '$high', '$low', '$volume']
+-            )
+-            
+-            if data is not None and not data.empty:
+-                # 重命名列
+-                data.columns = ['close', 'open', 'high', 'low', 'volume']
+-                return data
+-            else:
+-                return None
+-                
+-        except Exception as e:
+-            print(f"获取{instrument}价格数据失败: {e}")
+-            return None
+-    
+-    def _get_current_date(self, trade_step: int) -> str:
+-        """
+-        根据交易步骤获取当前日期
+-        
+-        Args:
+-            trade_step: 交易步骤
+-            
+-        Returns:
+-            当前日期字符串
+-        """
+-        # 这里简化处理，实际应该从qlib的日历获取
+-        # 假设从2020-01-01开始，每个trade_step代表一天
+-        start_date = pd.Timestamp('2020-01-01')
+-        current_date = start_date + pd.Timedelta(days=trade_step)
+-        return current_date.strftime('%Y-%m-%d')
+-
+-
+-def create_dataset_config():
+-    """
+-    创建数据集配置
+-    """
+-    dataset_config = {
+-        "class": "DatasetH",
+-        "module_path": "qlib.data.dataset",
+-        "kwargs": {
+-            "handler": {
+-                "class": "DataHandlerLP",
+-                "module_path": "qlib.data.dataset.handler",
+-                "kwargs": {
+-                    "start_time": "2020-01-01",
+-                    "end_time": "2023-12-31",
+-                    "fit_start_time": "2020-01-01",
+-                    "fit_end_time": "2023-12-31",
+-                    "instruments": "csi300",
+-                    "infer_processors": [
+-                        {
+-                            "class": "RobustZScoreNorm",
+-                            "module_path": "qlib.data.dataset.processor",
+-                            "kwargs": {
+-                                "fields_group": "feature",
+-                                "clip_outlier": True,
+-                            },
+-                        },
+-                        {
+-                            "class": "Fillna",
+-                            "module_path": "qlib.data.dataset.processor",
+-                            "kwargs": {
+-                                "fields_group": "feature",
+-                            },
+-                        },
+-                    ],
+-                    "learn_processors": [
+-                        {
+-                            "class": "DropnaLabel",
+-                            "module_path": "qlib.data.dataset.processor",
+-                        },
+-                        {
+-                            "class": "CSRankNorm",
+-                            "module_path": "qlib.data.dataset.processor",
+-                            "kwargs": {
+-                                "fields_group": "label",
+-                            },
+-                        },
+-                    ],
+-                    "instruments": "csi300",
+-                },
+-            },
+-            "segments": {
+-                "train": ("2020-01-01", "2022-12-31"),
+-                "valid": ("2023-01-01", "2023-06-30"),
+-                "test": ("2023-07-01", "2023-12-31"),
+-            },
+-        },
+-    }
+-    
+-    return dataset_config
+-
+-
+-def create_ma_cross_strategy_config():
+-    """
+-    创建均线交叉策略配置
+-    """
+-    strategy_config = {
+-        "class": "MACrossStrategyImproved",
+-        "module_path": "test.ma_cross_strategy_improved",
+-        "kwargs": {
+-            "short_window": 5,
+-            "long_window": 20,
+-            "topk": 50,
+-            "n_drop": 5,
+-            "universe": "csi300",
+-        }
+-    }
+-    
+-    return strategy_config
+-
+-
+-def run_backtest():
+-    """
+-    运行回测
+-    """
+-    # 初始化qlib
+-    qlib.init(provider_uri='~/.qlib/qlib_data/cn_data', region=REG_CN)
+-    
+-    # 策略配置
+-    strategy_config = create_ma_cross_strategy_config()
+-    
+-    # 回测配置
+-    backtest_config = {
+-        "start_time": "2020-01-01",
+-        "end_time": "2023-12-31",
+-        "benchmark": "SH000300",  # 沪深300作为基准
+-        "account": 100000000,     # 初始资金1亿
+-        "exchange_kwargs": {
+-            "freq": "day",
+-            "limit_threshold": 0.095,
+-            "deal_price": "close",
+-            "open_cost": 0.0005,
+-            "close_cost": 0.0015,
+-            "min_cost": 5,
+-        }
+-    }
+-    
+-    # 创建策略实例
+-    strategy = init_instance_by_config(strategy_config)
+-    
+-    # 运行回测
+-    with R.start(experiment_name="ma_cross_strategy_improved"):
+-        # 记录信号
+-        sr = SignalRecord(model=strategy, dataset=None, recorder=R.get_recorder())
+-        sr.generate()
+-        
+-        # 记录投资组合分析
+-        par = PortAnaRecord(recorder=R.get_recorder(), config=backtest_config, strategy=strategy)
+-        par.generate()
+-        
+-        # 获取回测结果
+-        report_normal, positions_normal = backtest_daily(
+-            account=backtest_config["account"],
+-            benchmark=backtest_config["benchmark"],
+-            start_time=backtest_config["start_time"],
+-            end_time=backtest_config["end_time"],
+-            strategy=strategy,
+-            exchange_kwargs=backtest_config["exchange_kwargs"]
+-        )
+-        
+-        return report_normal, positions_normal
+-
+-
+-def analyze_results(report: pd.DataFrame, positions: pd.DataFrame):
+-    """
+-    分析回测结果
+-    
+-    Args:
+-        report: 回测报告
+-        positions: 持仓信息
+-    """
+-    print("=" * 50)
+-    print("均线交叉策略回测结果")
+-    print("=" * 50)
+-    
+-    # 基本统计信息
+-    print(f"总收益率: {report['return'].sum():.2%}")
+-    print(f"年化收益率: {report['return'].mean() * 252:.2%}")
+-    print(f"最大回撤: {report['drawdown'].min():.2%}")
+-    
+-    if 'sharpe' in report.columns:
+-        print(f"夏普比率: {report['sharpe'].iloc[-1]:.2f}")
+-    
+-    print(f"胜率: {(report['return'] > 0).mean():.2%}")
+-    
+-    # 风险指标
+-    volatility = report['return'].std() * np.sqrt(252)
+-    print(f"年化波动率: {volatility:.2%}")
+-    
+-    # 最大回撤期间
+-    max_drawdown_idx = report['drawdown'].idxmin()
+-    print(f"最大回撤发生时间: {max_drawdown_idx}")
+-    
+-    # 收益分布
+-    print("\n收益分布统计:")
+-    print(f"平均日收益: {report['return'].mean():.2%}")
+-    print(f"收益标准差: {report['return'].std():.2%}")
+-    print(f"最小日收益: {report['return'].min():.2%}")
+-    print(f"最大日收益: {report['return'].max():.2%}")
+-    
+-    # 交易统计
+-    if 'trade_count' in report.columns:
+-        print(f"\n总交易次数: {report['trade_count'].sum()}")
+-        print(f"平均每日交易次数: {report['trade_count'].mean():.1f}")
+-
+-
+-def create_simple_backtest():
+-    """
+-    创建简化版回测，用于演示
+-    """
+-    print("创建简化版均线交叉策略回测...")
+-    
+-    # 初始化qlib
+-    qlib.init(provider_uri='~/.qlib/qlib_data/cn_data', region=REG_CN)
+-    
+-    # 获取股票列表
+-    instruments = D.list_instruments(instruments="csi300", start_time="2020-01-01", end_time="2023-12-31")
+-    
+-    print(f"获取到 {len(instruments)} 只股票")
+-    
+-    # 选择前10只股票进行演示
+-    demo_instruments = instruments[:10]
+-    
+-    # 获取价格数据
+-    data = D.features(
+-        instruments=demo_instruments,
+-        start_time="2020-01-01",
+-        end_time="2023-12-31",
+-        freq='day',
+-        fields=['$close']
+-    )
+-    
+-    print(f"获取到价格数据，形状: {data.shape}")
+-    
+-    # 计算均线
+-    short_ma = data.rolling(window=5).mean()
+-    long_ma = data.rolling(window=20).mean()
+-    
+-    # 计算交叉信号
+-    signals = pd.DataFrame(0, index=data.index, columns=data.columns)
+-    
+-    for col in data.columns:
+-        # 计算均线差值
+-        diff = short_ma[col] - long_ma[col]
+-        
+-        # 计算交叉信号
+-        for i in range(1, len(diff)):
+-            if diff.iloc[i-1] < 0 and diff.iloc[i] > 0:
+-                signals.iloc[i, signals.columns.get_loc(col)] = 1  # 金叉买入
+-            elif diff.iloc[i-1] > 0 and diff.iloc[i] < 0:
+-                signals.iloc[i, signals.columns.get_loc(col)] = -1  # 死叉卖出
+-    
+-    # 统计信号
+-    buy_signals = (signals == 1).sum().sum()
+-    sell_signals = (signals == -1).sum().sum()
+-    
+-    print(f"\n信号统计:")
+-    print(f"买入信号数量: {buy_signals}")
+-    print(f"卖出信号数量: {sell_signals}")
+-    
+-    # 计算简单收益（假设每次信号都产生1%的收益）
+-    returns = signals * 0.01
+-    cumulative_returns = returns.sum(axis=1).cumsum()
+-    
+-    print(f"\n累计收益: {cumulative_returns.iloc[-1]:.2%}")
+-    
+-    return signals, cumulative_returns
+-
+-
+-def main():
+-    """
+-    主函数
+-    """
+-    print("开始运行均线交叉策略回测...")
+-    
+-    try:
+-        # 运行简化版回测
+-        signals, cumulative_returns = create_simple_backtest()
+-        
+-        # 保存简化版结果
+-        signals.to_csv("ma_cross_signals.csv")
+-        cumulative_returns.to_csv("ma_cross_cumulative_returns.csv")
+-        
+-        print("\n简化版回测完成！")
+-        print("信号数据已保存到 ma_cross_signals.csv")
+-        print("累计收益已保存到 ma_cross_cumulative_returns.csv")
+-        
+-    except Exception as e:
+-        print(f"回测过程中出现错误: {e}")
+-        print("请确保已正确安装qlib并下载了相应的数据。")
+-
+-
+-if __name__ == "__main__":
+-    main() 
+\ No newline at end of file
+diff --git a/test/ma_strategy_demo.py b/test/ma_strategy_demo.py
+deleted file mode 100644
+index 1fa4fb4..0000000
+Binary files a/test/ma_strategy_demo.py and /dev/null differ
+diff --git a/test/simple_ma_strategy.py b/test/simple_ma_strategy.py
+deleted file mode 100644
+index 8d03f6b..0000000
+--- a/test/simple_ma_strategy.py
++++ /dev/null
+@@ -1,298 +0,0 @@
+-"""
+-简单实用的均线交叉策略
+-金叉买入，死叉卖出
+-"""
+-
+-import qlib
+-from qlib.constant import REG_CN
+-from qlib.data import D
+-import pandas as pd
+-import numpy as np
+-import matplotlib.pyplot as plt
+-from datetime import datetime, timedelta
+-
+-
+-def init_qlib():
+-    """初始化qlib"""
+-    try:
+-        qlib.init(provider_uri='~/.qlib/qlib_data/cn_data', region=REG_CN)
+-        print("qlib初始化成功")
+-        return True
+-    except Exception as e:
+-        print(f"qlib初始化失败: {e}")
+-        print("请确保已安装qlib并下载了数据")
+-        return False
+-
+-
+-def get_stock_data(instruments, start_date, end_date):
+-    """
+-    获取股票数据
+-    
+-    Args:
+-        instruments: 股票代码列表
+-        start_date: 开始日期
+-        end_date: 结束日期
+-    
+-    Returns:
+-        股票价格数据
+-    """
+-    try:
+-        data = D.features(
+-            instruments=instruments,
+-            start_time=start_date,
+-            end_time=end_date,
+-            freq='day',
+-            fields=['$close', '$open', '$high', '$low', '$volume']
+-        )
+-        
+-        if data is not None and not data.empty:
+-            # 重命名列
+-            data.columns = ['close', 'open', 'high', 'low', 'volume']
+-            return data
+-        else:
+-            print("未获取到数据")
+-            return None
+-            
+-    except Exception as e:
+-        print(f"获取数据失败: {e}")
+-        return None
+-
+-
+-def calculate_ma_signals(data, short_window=5, long_window=20):
+-    """
+-    计算均线交叉信号
+-    
+-    Args:
+-        data: 价格数据
+-        short_window: 短期均线周期
+-        long_window: 长期均线周期
+-    
+-    Returns:
+-        信号DataFrame，1表示买入，-1表示卖出，0表示无信号
+-    """
+-    signals = pd.DataFrame(0, index=data.index, columns=data.columns)
+-    
+-    for col in data.columns:
+-        if col == 'close':
+-            continue
+-            
+-        # 计算均线
+-        short_ma = data[col].rolling(window=short_window).mean()
+-        long_ma = data[col].rolling(window=long_window).mean()
+-        
+-        # 计算均线差值
+-        diff = short_ma - long_ma
+-        
+-        # 计算交叉信号
+-        for i in range(1, len(diff)):
+-            if pd.notna(diff.iloc[i-1]) and pd.notna(diff.iloc[i]):
+-                # 金叉：短期均线从下方穿越长期均线
+-                if diff.iloc[i-1] < 0 and diff.iloc[i] > 0:
+-                    signals.iloc[i, signals.columns.get_loc(col)] = 1
+-                # 死叉：短期均线从上方穿越长期均线
+-                elif diff.iloc[i-1] > 0 and diff.iloc[i] < 0:
+-                    signals.iloc[i, signals.columns.get_loc(col)] = -1
+-    
+-    return signals
+-
+-
+-def calculate_returns(data, signals, initial_capital=100000):
+-    """
+-    计算策略收益
+-    
+-    Args:
+-        data: 价格数据
+-        signals: 信号数据
+-        initial_capital: 初始资金
+-    
+-    Returns:
+-        收益数据
+-    """
+-    # 计算日收益率
+-    returns = data.pct_change()
+-    
+-    # 策略收益（假设每次信号产生1%的收益）
+-    strategy_returns = signals * 0.01
+-    
+-    # 累计收益
+-    cumulative_returns = strategy_returns.sum(axis=1).cumsum()
+-    
+-    # 资金曲线
+-    capital_curve = initial_capital * (1 + cumulative_returns)
+-    
+-    return {
+-        'strategy_returns': strategy_returns,
+-        'cumulative_returns': cumulative_returns,
+-        'capital_curve': capital_curve
+-    }
+-
+-
+-def analyze_strategy(signals, returns_data):
+-    """
+-    分析策略表现
+-    
+-    Args:
+-        signals: 信号数据
+-        returns_data: 收益数据
+-    """
+-    print("=" * 50)
+-    print("均线交叉策略分析结果")
+-    print("=" * 50)
+-    
+-    # 信号统计
+-    buy_signals = (signals == 1).sum().sum()
+-    sell_signals = (signals == -1).sum().sum()
+-    
+-    print(f"买入信号数量: {buy_signals}")
+-    print(f"卖出信号数量: {sell_signals}")
+-    print(f"总信号数量: {buy_signals + sell_signals}")
+-    
+-    # 收益统计
+-    cumulative_returns = returns_data['cumulative_returns']
+-    capital_curve = returns_data['capital_curve']
+-    
+-    total_return = cumulative_returns.iloc[-1]
+-    annual_return = total_return / (len(cumulative_returns) / 252)
+-    
+-    print(f"\n收益统计:")
+-    print(f"总收益率: {total_return:.2%}")
+-    print(f"年化收益率: {annual_return:.2%}")
+-    print(f"最终资金: {capital_curve.iloc[-1]:,.0f}")
+-    
+-    # 风险统计
+-    daily_returns = returns_data['strategy_returns'].sum(axis=1)
+-    volatility = daily_returns.std() * np.sqrt(252)
+-    sharpe_ratio = annual_return / volatility if volatility > 0 else 0
+-    
+-    print(f"\n风险统计:")
+-    print(f"年化波动率: {volatility:.2%}")
+-    print(f"夏普比率: {sharpe_ratio:.2f}")
+-    print(f"胜率: {(daily_returns > 0).mean():.2%}")
+-
+-
+-def plot_results(data, signals, returns_data, stock_code):
+-    """
+-    绘制结果图表
+-    
+-    Args:
+-        data: 价格数据
+-        signals: 信号数据
+-        returns_data: 收益数据
+-        stock_code: 股票代码
+-    """
+-    fig, axes = plt.subplots(3, 1, figsize=(12, 10))
+-    
+-    # 绘制价格和均线
+-    axes[0].plot(data.index, data[stock_code], label='收盘价', alpha=0.7)
+-    short_ma = data[stock_code].rolling(window=5).mean()
+-    long_ma = data[stock_code].rolling(window=20).mean()
+-    axes[0].plot(data.index, short_ma, label='5日均线', alpha=0.8)
+-    axes[0].plot(data.index, long_ma, label='20日均线', alpha=0.8)
+-    
+-    # 标记买卖信号
+-    buy_signals = signals[stock_code] == 1
+-    sell_signals = signals[stock_code] == -1
+-    
+-    axes[0].scatter(data.index[buy_signals], data.loc[buy_signals, stock_code], 
+-                   color='red', marker='^', s=100, label='买入信号', alpha=0.8)
+-    axes[0].scatter(data.index[sell_signals], data.loc[sell_signals, stock_code], 
+-                   color='green', marker='v', s=100, label='卖出信号', alpha=0.8)
+-    
+-    axes[0].set_title(f'{stock_code} 价格走势与均线交叉信号')
+-    axes[0].legend()
+-    axes[0].grid(True, alpha=0.3)
+-    
+-    # 绘制累计收益
+-    axes[1].plot(returns_data['cumulative_returns'].index, 
+-                returns_data['cumulative_returns'].values, 
+-                label='累计收益', color='blue')
+-    axes[1].set_title('策略累计收益')
+-    axes[1].legend()
+-    axes[1].grid(True, alpha=0.3)
+-    
+-    # 绘制资金曲线
+-    axes[2].plot(returns_data['capital_curve'].index, 
+-                returns_data['capital_curve'].values, 
+-                label='资金曲线', color='green')
+-    axes[2].set_title('资金曲线')
+-    axes[2].legend()
+-    axes[2].grid(True, alpha=0.3)
+-    
+-    plt.tight_layout()
+-    plt.savefig('ma_cross_strategy_results.png', dpi=300, bbox_inches='tight')
+-    plt.show()
+-
+-
+-def main():
+-    """
+-    主函数
+-    """
+-    print("开始运行均线交叉策略...")
+-    
+-    # 初始化qlib
+-    if not init_qlib():
+-        return
+-    
+-    # 策略参数
+-    start_date = "2020-01-01"
+-    end_date = "2023-12-31"
+-    short_window = 5
+-    long_window = 20
+-    initial_capital = 100000
+-    
+-    # 获取股票列表
+-    try:
+-        instruments = D.list_instruments(instruments="csi300", start_time=start_date, end_time=end_date)
+-        print(f"获取到 {len(instruments)} 只股票")
+-        
+-        # 选择前5只股票进行演示
+-        demo_instruments = instruments[:5]
+-        print(f"选择演示股票: {demo_instruments}")
+-        
+-    except Exception as e:
+-        print(f"获取股票列表失败: {e}")
+-        # 使用默认股票列表
+-        demo_instruments = ['000001.SZ', '000002.SZ', '000858.SZ', '002415.SZ', '600036.SH']
+-        print(f"使用默认股票列表: {demo_instruments}")
+-    
+-    # 获取价格数据
+-    data = get_stock_data(demo_instruments, start_date, end_date)
+-    
+-    if data is None:
+-        print("无法获取数据，程序退出")
+-        return
+-    
+-    print(f"获取到价格数据，形状: {data.shape}")
+-    
+-    # 计算均线信号
+-    signals = calculate_ma_signals(data, short_window, long_window)
+-    
+-    # 计算收益
+-    returns_data = calculate_returns(data, signals, initial_capital)
+-    
+-    # 分析策略
+-    analyze_strategy(signals, returns_data)
+-    
+-    # 保存结果
+-    signals.to_csv("ma_cross_signals.csv")
+-    returns_data['cumulative_returns'].to_csv("ma_cross_cumulative_returns.csv")
+-    returns_data['capital_curve'].to_csv("ma_cross_capital_curve.csv")
+-    
+-    print("\n结果已保存到CSV文件:")
+-    print("- ma_cross_signals.csv: 买卖信号")
+-    print("- ma_cross_cumulative_returns.csv: 累计收益")
+-    print("- ma_cross_capital_curve.csv: 资金曲线")
+-    
+-    # 绘制图表（选择第一只股票）
+-    if len(demo_instruments) > 0:
+-        try:
+-            plot_results(data, signals, returns_data, demo_instruments[0])
+-            print("图表已保存为 ma_cross_strategy_results.png")
+-        except Exception as e:
+-            print(f"绘制图表失败: {e}")
+-    
+-    print("\n策略回测完成！")
+-
+-
+-if __name__ == "__main__":
+-    main() 
+\ No newline at end of file
+diff --git a/test/two_ema_stragety.py b/test/two_ema_stragety.py
+index a72e7e8..a9890c7 100644
+--- a/test/two_ema_stragety.py
++++ b/test/two_ema_stragety.py
+@@ -1,2 +1,98 @@
+-from qlib.contrib.strategy import 
+-from qlib.backtest import backtest
+\ No newline at end of file
++import pandas as pd
++
++from abc import ABC
++from typing import Dict, List, Text, Tuple, Union
++from qlib.data.dataset import Dataset
++from qlib.model.base import BaseModel
++from qlib.backtest.signal import Signal, create_signal_from
++from qlib.strategy.base import BaseStrategy
++from qlib.backtest.decision import Order, OrderDir, OrderHelper, TradeDecisionWO
++# from qlib.strategy import 
++# from qlib.backtest import backtest
++
++class InnerStrategy(BaseStrategy):
++    """
++    Inner strategy for order execution:
++    - Buy: if price < 200, buy all cash; else buy 200,000 worth.
++    - Sell: if price > 200, sell all; else sell half.
++    """
++    STOCK_CODE = "000858.SZ"
++
++    def generate_trade_decision(self, execute_result: list = None, action: str = None, amount: float = None):
++        # action: 'buy' or 'sell', amount: suggested amount (shares) from outer
++        position = self.trade_position
++        trade_step = self.trade_calendar.get_trade_step()
++        trade_start_time, trade_end_time = self.trade_calendar.get_step_time(trade_step)
++        order_helper = self.trade_exchange.get_order_helper()
++        orders = []
++        price = self.trade_exchange.get_deal_price(self.STOCK_CODE, trade_start_time, trade_end_time)
++        if action == 'buy':
++            cash = position.get_cash()
++            if price <= 0:
++                return TradeDecisionWO([], self)
++            if price < 200:
++                buy_amount = cash // price
++            else:
++                buy_amount = min(cash // price, 200000 // price)
++            buy_amount = int(buy_amount)
++            if buy_amount > 0:
++                order = order_helper.create(
++                    code=self.STOCK_CODE,
++                    amount=buy_amount,
++                    direction=OrderDir.BUY,
++                    start_time=trade_start_time,
++                    end_time=trade_end_time,
++                )
++                orders.append(order)
++        elif action == 'sell':
++            held_amount = position.get_stock_amount(self.STOCK_CODE)
++            if held_amount <= 0 or price <= 0:
++                return TradeDecisionWO([], self)
++            if price > 200:
++                sell_amount = held_amount
++            else:
++                sell_amount = held_amount // 2
++            sell_amount = int(sell_amount)
++            if sell_amount > 0:
++                order = order_helper.create(
++                    code=self.STOCK_CODE,
++                    amount=sell_amount,
++                    direction=OrderDir.SELL,
++                    start_time=trade_start_time,
++                    end_time=trade_end_time,
++                )
++                orders.append(order)
++        return TradeDecisionWO(orders, self)
++
++class OuterStrategy(BaseStrategy):
++    """
++    Outer strategy:
++    - If not holding Wuliangye, issues a buy order via inner strategy.
++    - If holding, checks if held for 25 days, if so, issues a sell order via inner strategy.
++    - Otherwise, holds.
++    """
++    STOCK_CODE = "000858.SZ"
++    HOLD_DAYS = 25
++    BAR = "day"
++
++    def __init__(self, *args, **kwargs):
++        super().__init__(*args, **kwargs)
++        self.inner_strategy = InnerStrategy()
++
++    def generate_trade_decision(self, execute_result: list = None):
++        position = self.trade_position
++        stock_list = position.get_stock_list()
++        trade_step = self.trade_calendar.get_trade_step()
++        trade_start_time, trade_end_time = self.trade_calendar.get_step_time(trade_step)
++        # Pass infra to inner strategy
++        self.inner_strategy.reset(level_infra=self.level_infra, common_infra=self.common_infra)
++        if self.STOCK_CODE in stock_list:
++            hold_days = position.get_stock_count(self.STOCK_CODE, self.BAR)
++            if hold_days >= self.HOLD_DAYS:
++                # Sell via inner strategy
++                return self.inner_strategy.generate_trade_decision(action='sell')
++        else:
++            # Buy via inner strategy
++            return self.inner_strategy.generate_trade_decision(action='buy')
++        # Otherwise, hold
++        return TradeDecisionWO([], self)
+\ No newline at end of file
diff --git a/github/examples/mlruns/881301994755452456/157579a2201241aaafcff94e93d7da0e/artifacts/code_status.txt b/github/examples/mlruns/881301994755452456/157579a2201241aaafcff94e93d7da0e/artifacts/code_status.txt
new file mode 100644
index 0000000..23a33d1
--- /dev/null
+++ b/github/examples/mlruns/881301994755452456/157579a2201241aaafcff94e93d7da0e/artifacts/code_status.txt
@@ -0,0 +1,25 @@
+On branch main
+Your branch is up to date with 'origin/main'.
+
+Changes not staged for commit:
+  (use "git add/rm <file>..." to update what will be committed)
+  (use "git restore <file>..." to discard changes in working directory)
+	modified:   benchmarks/LightGBM/workflow_config_lightgbm_Alpha1582.yaml
+	deleted:    ../../test/README_MA_Strategy.md
+	modified:   ../../test/damo1.py
+	modified:   ../../test/demo2.ipynb
+	deleted:    ../../test/ma_cross_strategy.py
+	deleted:    ../../test/ma_cross_strategy_improved.py
+	deleted:    ../../test/ma_strategy_demo.py
+	deleted:    ../../test/simple_ma_strategy.py
+	modified:   ../../test/two_ema_stragety.py
+
+Untracked files:
+  (use "git add <file>..." to include in what will be committed)
+	mlruns/881301994755452456/157579a2201241aaafcff94e93d7da0e/
+	../../mlruns/
+	../../test/__pycache__/
+	../../test/buy_and_hold.py
+	../../test/workflow_by_code.py
+
+no changes added to commit (use "git add" and/or "git commit -a")
diff --git a/github/examples/mlruns/881301994755452456/157579a2201241aaafcff94e93d7da0e/artifacts/config b/github/examples/mlruns/881301994755452456/157579a2201241aaafcff94e93d7da0e/artifacts/config
new file mode 100644
index 0000000..10d4305
Binary files /dev/null and b/github/examples/mlruns/881301994755452456/157579a2201241aaafcff94e93d7da0e/artifacts/config differ
diff --git a/github/examples/mlruns/881301994755452456/157579a2201241aaafcff94e93d7da0e/artifacts/dataset b/github/examples/mlruns/881301994755452456/157579a2201241aaafcff94e93d7da0e/artifacts/dataset
new file mode 100644
index 0000000..29c38af
Binary files /dev/null and b/github/examples/mlruns/881301994755452456/157579a2201241aaafcff94e93d7da0e/artifacts/dataset differ
diff --git a/github/examples/mlruns/881301994755452456/157579a2201241aaafcff94e93d7da0e/artifacts/label.pkl b/github/examples/mlruns/881301994755452456/157579a2201241aaafcff94e93d7da0e/artifacts/label.pkl
new file mode 100644
index 0000000..2162a05
Binary files /dev/null and b/github/examples/mlruns/881301994755452456/157579a2201241aaafcff94e93d7da0e/artifacts/label.pkl differ
diff --git a/github/examples/mlruns/881301994755452456/157579a2201241aaafcff94e93d7da0e/artifacts/params.pkl b/github/examples/mlruns/881301994755452456/157579a2201241aaafcff94e93d7da0e/artifacts/params.pkl
new file mode 100644
index 0000000..b990757
Binary files /dev/null and b/github/examples/mlruns/881301994755452456/157579a2201241aaafcff94e93d7da0e/artifacts/params.pkl differ
diff --git a/github/examples/mlruns/881301994755452456/157579a2201241aaafcff94e93d7da0e/artifacts/portfolio_analysis/indicator_analysis_1day.pkl b/github/examples/mlruns/881301994755452456/157579a2201241aaafcff94e93d7da0e/artifacts/portfolio_analysis/indicator_analysis_1day.pkl
new file mode 100644
index 0000000..4820b71
Binary files /dev/null and b/github/examples/mlruns/881301994755452456/157579a2201241aaafcff94e93d7da0e/artifacts/portfolio_analysis/indicator_analysis_1day.pkl differ
diff --git a/github/examples/mlruns/881301994755452456/157579a2201241aaafcff94e93d7da0e/artifacts/portfolio_analysis/indicators_normal_1day.pkl b/github/examples/mlruns/881301994755452456/157579a2201241aaafcff94e93d7da0e/artifacts/portfolio_analysis/indicators_normal_1day.pkl
new file mode 100644
index 0000000..2e48e86
Binary files /dev/null and b/github/examples/mlruns/881301994755452456/157579a2201241aaafcff94e93d7da0e/artifacts/portfolio_analysis/indicators_normal_1day.pkl differ
diff --git a/github/examples/mlruns/881301994755452456/157579a2201241aaafcff94e93d7da0e/artifacts/portfolio_analysis/indicators_normal_1day_obj.pkl b/github/examples/mlruns/881301994755452456/157579a2201241aaafcff94e93d7da0e/artifacts/portfolio_analysis/indicators_normal_1day_obj.pkl
new file mode 100644
index 0000000..f0740c5
Binary files /dev/null and b/github/examples/mlruns/881301994755452456/157579a2201241aaafcff94e93d7da0e/artifacts/portfolio_analysis/indicators_normal_1day_obj.pkl differ
diff --git a/github/examples/mlruns/881301994755452456/157579a2201241aaafcff94e93d7da0e/artifacts/portfolio_analysis/port_analysis_1day.pkl b/github/examples/mlruns/881301994755452456/157579a2201241aaafcff94e93d7da0e/artifacts/portfolio_analysis/port_analysis_1day.pkl
new file mode 100644
index 0000000..df7c541
Binary files /dev/null and b/github/examples/mlruns/881301994755452456/157579a2201241aaafcff94e93d7da0e/artifacts/portfolio_analysis/port_analysis_1day.pkl differ
diff --git a/github/examples/mlruns/881301994755452456/157579a2201241aaafcff94e93d7da0e/artifacts/portfolio_analysis/positions_normal_1day.pkl b/github/examples/mlruns/881301994755452456/157579a2201241aaafcff94e93d7da0e/artifacts/portfolio_analysis/positions_normal_1day.pkl
new file mode 100644
index 0000000..ffd3f65
Binary files /dev/null and b/github/examples/mlruns/881301994755452456/157579a2201241aaafcff94e93d7da0e/artifacts/portfolio_analysis/positions_normal_1day.pkl differ
diff --git a/github/examples/mlruns/881301994755452456/157579a2201241aaafcff94e93d7da0e/artifacts/portfolio_analysis/report_normal_1day.pkl b/github/examples/mlruns/881301994755452456/157579a2201241aaafcff94e93d7da0e/artifacts/portfolio_analysis/report_normal_1day.pkl
new file mode 100644
index 0000000..285524b
Binary files /dev/null and b/github/examples/mlruns/881301994755452456/157579a2201241aaafcff94e93d7da0e/artifacts/portfolio_analysis/report_normal_1day.pkl differ
diff --git a/github/examples/mlruns/881301994755452456/157579a2201241aaafcff94e93d7da0e/artifacts/pred.pkl b/github/examples/mlruns/881301994755452456/157579a2201241aaafcff94e93d7da0e/artifacts/pred.pkl
new file mode 100644
index 0000000..4d6a04c
Binary files /dev/null and b/github/examples/mlruns/881301994755452456/157579a2201241aaafcff94e93d7da0e/artifacts/pred.pkl differ
diff --git a/github/examples/mlruns/881301994755452456/157579a2201241aaafcff94e93d7da0e/artifacts/sig_analysis/ic.pkl b/github/examples/mlruns/881301994755452456/157579a2201241aaafcff94e93d7da0e/artifacts/sig_analysis/ic.pkl
new file mode 100644
index 0000000..3a4a5da
Binary files /dev/null and b/github/examples/mlruns/881301994755452456/157579a2201241aaafcff94e93d7da0e/artifacts/sig_analysis/ic.pkl differ
diff --git a/github/examples/mlruns/881301994755452456/157579a2201241aaafcff94e93d7da0e/artifacts/sig_analysis/ric.pkl b/github/examples/mlruns/881301994755452456/157579a2201241aaafcff94e93d7da0e/artifacts/sig_analysis/ric.pkl
new file mode 100644
index 0000000..546f155
Binary files /dev/null and b/github/examples/mlruns/881301994755452456/157579a2201241aaafcff94e93d7da0e/artifacts/sig_analysis/ric.pkl differ
diff --git a/github/examples/mlruns/881301994755452456/157579a2201241aaafcff94e93d7da0e/artifacts/task b/github/examples/mlruns/881301994755452456/157579a2201241aaafcff94e93d7da0e/artifacts/task
new file mode 100644
index 0000000..00ec1b0
Binary files /dev/null and b/github/examples/mlruns/881301994755452456/157579a2201241aaafcff94e93d7da0e/artifacts/task differ
diff --git a/github/examples/mlruns/881301994755452456/157579a2201241aaafcff94e93d7da0e/meta.yaml b/github/examples/mlruns/881301994755452456/157579a2201241aaafcff94e93d7da0e/meta.yaml
new file mode 100644
index 0000000..54d5bff
--- /dev/null
+++ b/github/examples/mlruns/881301994755452456/157579a2201241aaafcff94e93d7da0e/meta.yaml
@@ -0,0 +1,14 @@
+artifact_uri: file:D:\project\python\tradenote\github\examples\mlruns/881301994755452456/157579a2201241aaafcff94e93d7da0e/artifacts
+end_time: 1750319261130
+entry_point_name: ''
+experiment_id: '881301994755452456'
+lifecycle_stage: active
+run_id: 157579a2201241aaafcff94e93d7da0e
+run_name: mlflow_recorder
+source_name: ''
+source_type: 4
+source_version: ''
+start_time: 1750319105440
+status: 3
+tags: []
+user_id: abulimity
diff --git a/github/examples/mlruns/881301994755452456/157579a2201241aaafcff94e93d7da0e/metrics/1day.excess_return_with_cost.annualized_return b/github/examples/mlruns/881301994755452456/157579a2201241aaafcff94e93d7da0e/metrics/1day.excess_return_with_cost.annualized_return
new file mode 100644
index 0000000..6d42447
--- /dev/null
+++ b/github/examples/mlruns/881301994755452456/157579a2201241aaafcff94e93d7da0e/metrics/1day.excess_return_with_cost.annualized_return
@@ -0,0 +1 @@
+1750319260652 0.08065424981584696 0
diff --git a/github/examples/mlruns/881301994755452456/157579a2201241aaafcff94e93d7da0e/metrics/1day.excess_return_with_cost.information_ratio b/github/examples/mlruns/881301994755452456/157579a2201241aaafcff94e93d7da0e/metrics/1day.excess_return_with_cost.information_ratio
new file mode 100644
index 0000000..9cda901
--- /dev/null
+++ b/github/examples/mlruns/881301994755452456/157579a2201241aaafcff94e93d7da0e/metrics/1day.excess_return_with_cost.information_ratio
@@ -0,0 +1 @@
+1750319260816 0.9144858856010745 0
diff --git a/github/examples/mlruns/881301994755452456/157579a2201241aaafcff94e93d7da0e/metrics/1day.excess_return_with_cost.max_drawdown b/github/examples/mlruns/881301994755452456/157579a2201241aaafcff94e93d7da0e/metrics/1day.excess_return_with_cost.max_drawdown
new file mode 100644
index 0000000..45d9ff7
--- /dev/null
+++ b/github/examples/mlruns/881301994755452456/157579a2201241aaafcff94e93d7da0e/metrics/1day.excess_return_with_cost.max_drawdown
@@ -0,0 +1 @@
+1750319260992 -0.08608280684938452 0
diff --git a/github/examples/mlruns/881301994755452456/157579a2201241aaafcff94e93d7da0e/metrics/1day.excess_return_with_cost.mean b/github/examples/mlruns/881301994755452456/157579a2201241aaafcff94e93d7da0e/metrics/1day.excess_return_with_cost.mean
new file mode 100644
index 0000000..c00ca53
--- /dev/null
+++ b/github/examples/mlruns/881301994755452456/157579a2201241aaafcff94e93d7da0e/metrics/1day.excess_return_with_cost.mean
@@ -0,0 +1 @@
+1750319260551 0.0003388834025875923 0
diff --git a/github/examples/mlruns/881301994755452456/157579a2201241aaafcff94e93d7da0e/metrics/1day.excess_return_with_cost.std b/github/examples/mlruns/881301994755452456/157579a2201241aaafcff94e93d7da0e/metrics/1day.excess_return_with_cost.std
new file mode 100644
index 0000000..ad286f7
--- /dev/null
+++ b/github/examples/mlruns/881301994755452456/157579a2201241aaafcff94e93d7da0e/metrics/1day.excess_return_with_cost.std
@@ -0,0 +1 @@
+1750319260605 0.005716915468473912 0
diff --git a/github/examples/mlruns/881301994755452456/157579a2201241aaafcff94e93d7da0e/metrics/1day.excess_return_without_cost.annualized_return b/github/examples/mlruns/881301994755452456/157579a2201241aaafcff94e93d7da0e/metrics/1day.excess_return_without_cost.annualized_return
new file mode 100644
index 0000000..5338d75
--- /dev/null
+++ b/github/examples/mlruns/881301994755452456/157579a2201241aaafcff94e93d7da0e/metrics/1day.excess_return_without_cost.annualized_return
@@ -0,0 +1 @@
+1750319260269 0.12602897949315703 0
diff --git a/github/examples/mlruns/881301994755452456/157579a2201241aaafcff94e93d7da0e/metrics/1day.excess_return_without_cost.information_ratio b/github/examples/mlruns/881301994755452456/157579a2201241aaafcff94e93d7da0e/metrics/1day.excess_return_without_cost.information_ratio
new file mode 100644
index 0000000..7e3f2c9
--- /dev/null
+++ b/github/examples/mlruns/881301994755452456/157579a2201241aaafcff94e93d7da0e/metrics/1day.excess_return_without_cost.information_ratio
@@ -0,0 +1 @@
+1750319260271 1.4285742844475504 0
diff --git a/github/examples/mlruns/881301994755452456/157579a2201241aaafcff94e93d7da0e/metrics/1day.excess_return_without_cost.max_drawdown b/github/examples/mlruns/881301994755452456/157579a2201241aaafcff94e93d7da0e/metrics/1day.excess_return_without_cost.max_drawdown
new file mode 100644
index 0000000..8fd6026
--- /dev/null
+++ b/github/examples/mlruns/881301994755452456/157579a2201241aaafcff94e93d7da0e/metrics/1day.excess_return_without_cost.max_drawdown
@@ -0,0 +1 @@
+1750319260365 -0.07230960299230554 0
diff --git a/github/examples/mlruns/881301994755452456/157579a2201241aaafcff94e93d7da0e/metrics/1day.excess_return_without_cost.mean b/github/examples/mlruns/881301994755452456/157579a2201241aaafcff94e93d7da0e/metrics/1day.excess_return_without_cost.mean
new file mode 100644
index 0000000..23c9e17
--- /dev/null
+++ b/github/examples/mlruns/881301994755452456/157579a2201241aaafcff94e93d7da0e/metrics/1day.excess_return_without_cost.mean
@@ -0,0 +1 @@
+1750319260240 0.0005295335272821724 0
diff --git a/github/examples/mlruns/881301994755452456/157579a2201241aaafcff94e93d7da0e/metrics/1day.excess_return_without_cost.std b/github/examples/mlruns/881301994755452456/157579a2201241aaafcff94e93d7da0e/metrics/1day.excess_return_without_cost.std
new file mode 100644
index 0000000..d4f9ec7
--- /dev/null
+++ b/github/examples/mlruns/881301994755452456/157579a2201241aaafcff94e93d7da0e/metrics/1day.excess_return_without_cost.std
@@ -0,0 +1 @@
+1750319260255 0.005718460332956039 0
diff --git a/github/examples/mlruns/881301994755452456/157579a2201241aaafcff94e93d7da0e/metrics/1day.ffr b/github/examples/mlruns/881301994755452456/157579a2201241aaafcff94e93d7da0e/metrics/1day.ffr
new file mode 100644
index 0000000..1a69cde
--- /dev/null
+++ b/github/examples/mlruns/881301994755452456/157579a2201241aaafcff94e93d7da0e/metrics/1day.ffr
@@ -0,0 +1 @@
+1750319261121 1.0 0
diff --git a/github/examples/mlruns/881301994755452456/157579a2201241aaafcff94e93d7da0e/metrics/1day.pa b/github/examples/mlruns/881301994755452456/157579a2201241aaafcff94e93d7da0e/metrics/1day.pa
new file mode 100644
index 0000000..49a8d02
--- /dev/null
+++ b/github/examples/mlruns/881301994755452456/157579a2201241aaafcff94e93d7da0e/metrics/1day.pa
@@ -0,0 +1 @@
+1750319261122 0.0 0
diff --git a/github/examples/mlruns/881301994755452456/157579a2201241aaafcff94e93d7da0e/metrics/1day.pos b/github/examples/mlruns/881301994755452456/157579a2201241aaafcff94e93d7da0e/metrics/1day.pos
new file mode 100644
index 0000000..2bfb5aa
--- /dev/null
+++ b/github/examples/mlruns/881301994755452456/157579a2201241aaafcff94e93d7da0e/metrics/1day.pos
@@ -0,0 +1 @@
+1750319261124 0.0 0
diff --git a/github/examples/mlruns/881301994755452456/157579a2201241aaafcff94e93d7da0e/metrics/IC b/github/examples/mlruns/881301994755452456/157579a2201241aaafcff94e93d7da0e/metrics/IC
new file mode 100644
index 0000000..eaf03a1
--- /dev/null
+++ b/github/examples/mlruns/881301994755452456/157579a2201241aaafcff94e93d7da0e/metrics/IC
@@ -0,0 +1 @@
+1750319205121 0.04680587323833807 0
diff --git a/github/examples/mlruns/881301994755452456/157579a2201241aaafcff94e93d7da0e/metrics/ICIR b/github/examples/mlruns/881301994755452456/157579a2201241aaafcff94e93d7da0e/metrics/ICIR
new file mode 100644
index 0000000..593bea2
--- /dev/null
+++ b/github/examples/mlruns/881301994755452456/157579a2201241aaafcff94e93d7da0e/metrics/ICIR
@@ -0,0 +1 @@
+1750319205123 0.3815683918932705 0
diff --git a/github/examples/mlruns/881301994755452456/157579a2201241aaafcff94e93d7da0e/metrics/Rank IC b/github/examples/mlruns/881301994755452456/157579a2201241aaafcff94e93d7da0e/metrics/Rank IC
new file mode 100644
index 0000000..e06e399
--- /dev/null
+++ b/github/examples/mlruns/881301994755452456/157579a2201241aaafcff94e93d7da0e/metrics/Rank IC	
@@ -0,0 +1 @@
+1750319205125 0.049049290457489736 0
diff --git a/github/examples/mlruns/881301994755452456/157579a2201241aaafcff94e93d7da0e/metrics/Rank ICIR b/github/examples/mlruns/881301994755452456/157579a2201241aaafcff94e93d7da0e/metrics/Rank ICIR
new file mode 100644
index 0000000..930f762
--- /dev/null
+++ b/github/examples/mlruns/881301994755452456/157579a2201241aaafcff94e93d7da0e/metrics/Rank ICIR	
@@ -0,0 +1 @@
+1750319205127 0.406748756941287 0
diff --git a/github/examples/mlruns/881301994755452456/157579a2201241aaafcff94e93d7da0e/metrics/l2.train b/github/examples/mlruns/881301994755452456/157579a2201241aaafcff94e93d7da0e/metrics/l2.train
new file mode 100644
index 0000000..270c724
--- /dev/null
+++ b/github/examples/mlruns/881301994755452456/157579a2201241aaafcff94e93d7da0e/metrics/l2.train
@@ -0,0 +1,68 @@
+1750319202867 0.9946429660064169 0
+1750319202881 0.993180174753216 1
+1750319202887 0.9919112031761499 2
+1750319202898 0.9908153051336693 3
+1750319202903 0.9897399690763109 4
+1750319202910 0.9888034198040134 5
+1750319202916 0.9880264988555498 6
+1750319202919 0.9874338327729513 7
+1750319202928 0.9866260311905501 8
+1750319202933 0.986052788452645 9
+1750319202942 0.9854977493190381 10
+1750319202952 0.9849287923043079 11
+1750319202960 0.9844232407828042 12
+1750319202971 0.9838545327138349 13
+1750319202977 0.9834464993874245 14
+1750319202991 0.9829411155269864 15
+1750319202998 0.9825570185401087 16
+1750319203008 0.9821820551962865 17
+1750319203023 0.9818070306392479 18
+1750319203032 0.9813774405525829 19
+1750319203037 0.9809662852794192 20
+1750319203042 0.9806162723802618 21
+1750319203049 0.9801324806407727 22
+1750319203055 0.9796234506422887 23
+1750319203061 0.9792487729965835 24
+1750319203065 0.9789239102376857 25
+1750319203069 0.9786207120776286 26
+1750319203074 0.9782747878142718 27
+1750319203079 0.9778732845795345 28
+1750319203083 0.9773688950482772 29
+1750319203087 0.9769011828327996 30
+1750319203094 0.9765495769785922 31
+1750319203098 0.976142862250202 32
+1750319203103 0.9757981857883767 33
+1750319203107 0.9755213347725463 34
+1750319203114 0.9751971437543426 35
+1750319203120 0.9748019444841971 36
+1750319203127 0.974479645581059 37
+1750319203133 0.9741975270394891 38
+1750319203139 0.9738108657458638 39
+1750319203146 0.9734385792739976 40
+1750319203152 0.9730825104049254 41
+1750319203159 0.9728238713871274 42
+1750319203165 0.9725347569188096 43
+1750319203168 0.9721753667314483 44
+1750319203173 0.9718118989648334 45
+1750319203177 0.9714214596082568 46
+1750319203179 0.971097841466105 47
+1750319203181 0.97076422115284 48
+1750319203183 0.9704043394662826 49
+1750319203184 0.9700095495774907 50
+1750319203187 0.9697848202134376 51
+1750319203189 0.9694339661734573 52
+1750319203191 0.969118497561048 53
+1750319203193 0.968808092224893 54
+1750319203195 0.9685084197020712 55
+1750319203197 0.9681623555422074 56
+1750319203199 0.9678240825495192 57
+1750319203201 0.9674841602015607 58
+1750319203203 0.9671521888942005 59
+1750319203205 0.9668026140878453 60
+1750319203207 0.9664666726958561 61
+1750319203209 0.9661201263714719 62
+1750319203211 0.9658069258646514 63
+1750319203212 0.9654859042210324 64
+1750319203214 0.9651243808241167 65
+1750319203216 0.9648348363046608 66
+1750319203218 0.9645443274938362 67
diff --git a/github/examples/mlruns/881301994755452456/157579a2201241aaafcff94e93d7da0e/metrics/l2.valid b/github/examples/mlruns/881301994755452456/157579a2201241aaafcff94e93d7da0e/metrics/l2.valid
new file mode 100644
index 0000000..b777ecd
--- /dev/null
+++ b/github/examples/mlruns/881301994755452456/157579a2201241aaafcff94e93d7da0e/metrics/l2.valid
@@ -0,0 +1,68 @@
+1750319203221 0.9957279324151268 0
+1750319203223 0.9951531356456631 1
+1750319203226 0.99487994419474 2
+1750319203228 0.994535294797923 3
+1750319203230 0.9943029094633086 4
+1750319203234 0.9941319081131783 5
+1750319203236 0.9940604217248121 6
+1750319203238 0.9940141883154097 7
+1750319203240 0.9939327358874062 8
+1750319203242 0.9938238713294111 9
+1750319203243 0.9937585949310203 10
+1750319203245 0.993740995606895 11
+1750319203247 0.9936935456055775 12
+1750319203249 0.9936237366292924 13
+1750319203253 0.9936030278242867 14
+1750319203257 0.993616198062933 15
+1750319203259 0.9935403605783565 16
+1750319203261 0.9934971255925089 17
+1750319203263 0.9935486031563063 18
+1750319203265 0.9935659109674063 19
+1750319203267 0.9935794655054091 20
+1750319203270 0.9935255902525211 21
+1750319203272 0.993561687975921 22
+1750319203273 0.9935608670021352 23
+1750319203276 0.9935411991828461 24
+1750319203278 0.9936079576653529 25
+1750319203280 0.9936268656140975 26
+1750319203282 0.9936481073556415 27
+1750319203284 0.9936912759714592 28
+1750319203286 0.993697745317788 29
+1750319203288 0.9938745638588765 30
+1750319203289 0.9938591766669366 31
+1750319203291 0.9938676772365683 32
+1750319203293 0.9938476222647777 33
+1750319203294 0.9938388370765684 34
+1750319203297 0.9938139901934193 35
+1750319203300 0.9938797739825903 36
+1750319203302 0.9939117833897817 37
+1750319203305 0.9938726719749716 38
+1750319203309 0.993976722070025 39
+1750319203311 0.994011057044634 40
+1750319203313 0.9940263477826512 41
+1750319203315 0.9940036353999507 42
+1750319203317 0.9940339971721586 43
+1750319203319 0.9940483796978958 44
+1750319203321 0.9940928150506074 45
+1750319203322 0.9941748072651118 46
+1750319203324 0.9942576190097517 47
+1750319203326 0.9942873867438466 48
+1750319203328 0.9942783534841702 49
+1750319203330 0.9944128912891459 50
+1750319203332 0.9943681467791802 51
+1750319203334 0.9943128187548772 52
+1750319203336 0.9944369333067639 53
+1750319203337 0.9944804176400358 54
+1750319203339 0.9945441486241686 55
+1750319203341 0.9945696328056838 56
+1750319203344 0.9945389010966934 57
+1750319203346 0.9945853380394043 58
+1750319203347 0.994647543720556 59
+1750319203349 0.9946966093044881 60
+1750319203351 0.9947362450114523 61
+1750319203353 0.9947704357493118 62
+1750319203355 0.9948267433134428 63
+1750319203357 0.9948716065100159 64
+1750319203359 0.9949015061392684 65
+1750319203361 0.9950516809387532 66
+1750319203363 0.9950544899629334 67
diff --git a/github/examples/mlruns/881301994755452456/157579a2201241aaafcff94e93d7da0e/params/cmd-sys.argv b/github/examples/mlruns/881301994755452456/157579a2201241aaafcff94e93d7da0e/params/cmd-sys.argv
new file mode 100644
index 0000000..c20049c
--- /dev/null
+++ b/github/examples/mlruns/881301994755452456/157579a2201241aaafcff94e93d7da0e/params/cmd-sys.argv
@@ -0,0 +1 @@
+D:\project\python\tradenote\.venv\Scripts\qrun benchmarks/LightGBM/workflow_config_lightgbm_Alpha1582.yaml
\ No newline at end of file
diff --git a/github/examples/mlruns/881301994755452456/157579a2201241aaafcff94e93d7da0e/params/dataset.class b/github/examples/mlruns/881301994755452456/157579a2201241aaafcff94e93d7da0e/params/dataset.class
new file mode 100644
index 0000000..358d343
--- /dev/null
+++ b/github/examples/mlruns/881301994755452456/157579a2201241aaafcff94e93d7da0e/params/dataset.class
@@ -0,0 +1 @@
+DatasetH
\ No newline at end of file
diff --git a/github/examples/mlruns/881301994755452456/157579a2201241aaafcff94e93d7da0e/params/dataset.kwargs.handler.class b/github/examples/mlruns/881301994755452456/157579a2201241aaafcff94e93d7da0e/params/dataset.kwargs.handler.class
new file mode 100644
index 0000000..64adf3e
--- /dev/null
+++ b/github/examples/mlruns/881301994755452456/157579a2201241aaafcff94e93d7da0e/params/dataset.kwargs.handler.class
@@ -0,0 +1 @@
+Alpha158
\ No newline at end of file
diff --git a/github/examples/mlruns/881301994755452456/157579a2201241aaafcff94e93d7da0e/params/dataset.kwargs.handler.kwargs.end_time b/github/examples/mlruns/881301994755452456/157579a2201241aaafcff94e93d7da0e/params/dataset.kwargs.handler.kwargs.end_time
new file mode 100644
index 0000000..a0cb3b2
--- /dev/null
+++ b/github/examples/mlruns/881301994755452456/157579a2201241aaafcff94e93d7da0e/params/dataset.kwargs.handler.kwargs.end_time
@@ -0,0 +1 @@
+2020-08-01
\ No newline at end of file
diff --git a/github/examples/mlruns/881301994755452456/157579a2201241aaafcff94e93d7da0e/params/dataset.kwargs.handler.kwargs.fit_end_time b/github/examples/mlruns/881301994755452456/157579a2201241aaafcff94e93d7da0e/params/dataset.kwargs.handler.kwargs.fit_end_time
new file mode 100644
index 0000000..c35d146
--- /dev/null
+++ b/github/examples/mlruns/881301994755452456/157579a2201241aaafcff94e93d7da0e/params/dataset.kwargs.handler.kwargs.fit_end_time
@@ -0,0 +1 @@
+2014-12-31
\ No newline at end of file
diff --git a/github/examples/mlruns/881301994755452456/157579a2201241aaafcff94e93d7da0e/params/dataset.kwargs.handler.kwargs.fit_start_time b/github/examples/mlruns/881301994755452456/157579a2201241aaafcff94e93d7da0e/params/dataset.kwargs.handler.kwargs.fit_start_time
new file mode 100644
index 0000000..60a166b
--- /dev/null
+++ b/github/examples/mlruns/881301994755452456/157579a2201241aaafcff94e93d7da0e/params/dataset.kwargs.handler.kwargs.fit_start_time
@@ -0,0 +1 @@
+2008-01-01
\ No newline at end of file
diff --git a/github/examples/mlruns/881301994755452456/157579a2201241aaafcff94e93d7da0e/params/dataset.kwargs.handler.kwargs.instruments b/github/examples/mlruns/881301994755452456/157579a2201241aaafcff94e93d7da0e/params/dataset.kwargs.handler.kwargs.instruments
new file mode 100644
index 0000000..9520926
--- /dev/null
+++ b/github/examples/mlruns/881301994755452456/157579a2201241aaafcff94e93d7da0e/params/dataset.kwargs.handler.kwargs.instruments
@@ -0,0 +1 @@
+csi300
\ No newline at end of file
diff --git a/github/examples/mlruns/881301994755452456/157579a2201241aaafcff94e93d7da0e/params/dataset.kwargs.handler.kwargs.start_time b/github/examples/mlruns/881301994755452456/157579a2201241aaafcff94e93d7da0e/params/dataset.kwargs.handler.kwargs.start_time
new file mode 100644
index 0000000..60a166b
--- /dev/null
+++ b/github/examples/mlruns/881301994755452456/157579a2201241aaafcff94e93d7da0e/params/dataset.kwargs.handler.kwargs.start_time
@@ -0,0 +1 @@
+2008-01-01
\ No newline at end of file
diff --git a/github/examples/mlruns/881301994755452456/157579a2201241aaafcff94e93d7da0e/params/dataset.kwargs.handler.module_path b/github/examples/mlruns/881301994755452456/157579a2201241aaafcff94e93d7da0e/params/dataset.kwargs.handler.module_path
new file mode 100644
index 0000000..042d3a7
--- /dev/null
+++ b/github/examples/mlruns/881301994755452456/157579a2201241aaafcff94e93d7da0e/params/dataset.kwargs.handler.module_path
@@ -0,0 +1 @@
+qlib.contrib.data.handler
\ No newline at end of file
diff --git a/github/examples/mlruns/881301994755452456/157579a2201241aaafcff94e93d7da0e/params/dataset.kwargs.segments.test b/github/examples/mlruns/881301994755452456/157579a2201241aaafcff94e93d7da0e/params/dataset.kwargs.segments.test
new file mode 100644
index 0000000..38b9eb0
--- /dev/null
+++ b/github/examples/mlruns/881301994755452456/157579a2201241aaafcff94e93d7da0e/params/dataset.kwargs.segments.test
@@ -0,0 +1 @@
+[datetime.date(2017, 1, 1), datetime.date(2020, 8, 1)]
\ No newline at end of file
diff --git a/github/examples/mlruns/881301994755452456/157579a2201241aaafcff94e93d7da0e/params/dataset.kwargs.segments.train b/github/examples/mlruns/881301994755452456/157579a2201241aaafcff94e93d7da0e/params/dataset.kwargs.segments.train
new file mode 100644
index 0000000..c46292d
--- /dev/null
+++ b/github/examples/mlruns/881301994755452456/157579a2201241aaafcff94e93d7da0e/params/dataset.kwargs.segments.train
@@ -0,0 +1 @@
+[datetime.date(2008, 1, 1), datetime.date(2014, 12, 31)]
\ No newline at end of file
diff --git a/github/examples/mlruns/881301994755452456/157579a2201241aaafcff94e93d7da0e/params/dataset.kwargs.segments.valid b/github/examples/mlruns/881301994755452456/157579a2201241aaafcff94e93d7da0e/params/dataset.kwargs.segments.valid
new file mode 100644
index 0000000..ddf3f55
--- /dev/null
+++ b/github/examples/mlruns/881301994755452456/157579a2201241aaafcff94e93d7da0e/params/dataset.kwargs.segments.valid
@@ -0,0 +1 @@
+[datetime.date(2015, 1, 1), datetime.date(2016, 12, 31)]
\ No newline at end of file
diff --git a/github/examples/mlruns/881301994755452456/157579a2201241aaafcff94e93d7da0e/params/dataset.module_path b/github/examples/mlruns/881301994755452456/157579a2201241aaafcff94e93d7da0e/params/dataset.module_path
new file mode 100644
index 0000000..21721a6
--- /dev/null
+++ b/github/examples/mlruns/881301994755452456/157579a2201241aaafcff94e93d7da0e/params/dataset.module_path
@@ -0,0 +1 @@
+qlib.data.dataset
\ No newline at end of file
diff --git a/github/examples/mlruns/881301994755452456/157579a2201241aaafcff94e93d7da0e/params/model.class b/github/examples/mlruns/881301994755452456/157579a2201241aaafcff94e93d7da0e/params/model.class
new file mode 100644
index 0000000..5db8ba9
--- /dev/null
+++ b/github/examples/mlruns/881301994755452456/157579a2201241aaafcff94e93d7da0e/params/model.class
@@ -0,0 +1 @@
+LGBModel
\ No newline at end of file
diff --git a/github/examples/mlruns/881301994755452456/157579a2201241aaafcff94e93d7da0e/params/model.kwargs.colsample_bytree b/github/examples/mlruns/881301994755452456/157579a2201241aaafcff94e93d7da0e/params/model.kwargs.colsample_bytree
new file mode 100644
index 0000000..e02e5fa
--- /dev/null
+++ b/github/examples/mlruns/881301994755452456/157579a2201241aaafcff94e93d7da0e/params/model.kwargs.colsample_bytree
@@ -0,0 +1 @@
+0.8879
\ No newline at end of file
diff --git a/github/examples/mlruns/881301994755452456/157579a2201241aaafcff94e93d7da0e/params/model.kwargs.lambda_l1 b/github/examples/mlruns/881301994755452456/157579a2201241aaafcff94e93d7da0e/params/model.kwargs.lambda_l1
new file mode 100644
index 0000000..5893e25
--- /dev/null
+++ b/github/examples/mlruns/881301994755452456/157579a2201241aaafcff94e93d7da0e/params/model.kwargs.lambda_l1
@@ -0,0 +1 @@
+205.6999
\ No newline at end of file
diff --git a/github/examples/mlruns/881301994755452456/157579a2201241aaafcff94e93d7da0e/params/model.kwargs.lambda_l2 b/github/examples/mlruns/881301994755452456/157579a2201241aaafcff94e93d7da0e/params/model.kwargs.lambda_l2
new file mode 100644
index 0000000..33d3922
--- /dev/null
+++ b/github/examples/mlruns/881301994755452456/157579a2201241aaafcff94e93d7da0e/params/model.kwargs.lambda_l2
@@ -0,0 +1 @@
+580.9768
\ No newline at end of file
diff --git a/github/examples/mlruns/881301994755452456/157579a2201241aaafcff94e93d7da0e/params/model.kwargs.learning_rate b/github/examples/mlruns/881301994755452456/157579a2201241aaafcff94e93d7da0e/params/model.kwargs.learning_rate
new file mode 100644
index 0000000..2f45361
--- /dev/null
+++ b/github/examples/mlruns/881301994755452456/157579a2201241aaafcff94e93d7da0e/params/model.kwargs.learning_rate
@@ -0,0 +1 @@
+0.2
\ No newline at end of file
diff --git a/github/examples/mlruns/881301994755452456/157579a2201241aaafcff94e93d7da0e/params/model.kwargs.loss b/github/examples/mlruns/881301994755452456/157579a2201241aaafcff94e93d7da0e/params/model.kwargs.loss
new file mode 100644
index 0000000..f290a7a
--- /dev/null
+++ b/github/examples/mlruns/881301994755452456/157579a2201241aaafcff94e93d7da0e/params/model.kwargs.loss
@@ -0,0 +1 @@
+mse
\ No newline at end of file
diff --git a/github/examples/mlruns/881301994755452456/157579a2201241aaafcff94e93d7da0e/params/model.kwargs.max_depth b/github/examples/mlruns/881301994755452456/157579a2201241aaafcff94e93d7da0e/params/model.kwargs.max_depth
new file mode 100644
index 0000000..301160a
--- /dev/null
+++ b/github/examples/mlruns/881301994755452456/157579a2201241aaafcff94e93d7da0e/params/model.kwargs.max_depth
@@ -0,0 +1 @@
+8
\ No newline at end of file
diff --git a/github/examples/mlruns/881301994755452456/157579a2201241aaafcff94e93d7da0e/params/model.kwargs.num_leaves b/github/examples/mlruns/881301994755452456/157579a2201241aaafcff94e93d7da0e/params/model.kwargs.num_leaves
new file mode 100644
index 0000000..55596b2
--- /dev/null
+++ b/github/examples/mlruns/881301994755452456/157579a2201241aaafcff94e93d7da0e/params/model.kwargs.num_leaves
@@ -0,0 +1 @@
+210
\ No newline at end of file
diff --git a/github/examples/mlruns/881301994755452456/157579a2201241aaafcff94e93d7da0e/params/model.kwargs.num_threads b/github/examples/mlruns/881301994755452456/157579a2201241aaafcff94e93d7da0e/params/model.kwargs.num_threads
new file mode 100644
index 0000000..2edeafb
--- /dev/null
+++ b/github/examples/mlruns/881301994755452456/157579a2201241aaafcff94e93d7da0e/params/model.kwargs.num_threads
@@ -0,0 +1 @@
+20
\ No newline at end of file
diff --git a/github/examples/mlruns/881301994755452456/157579a2201241aaafcff94e93d7da0e/params/model.kwargs.subsample b/github/examples/mlruns/881301994755452456/157579a2201241aaafcff94e93d7da0e/params/model.kwargs.subsample
new file mode 100644
index 0000000..f37011c
--- /dev/null
+++ b/github/examples/mlruns/881301994755452456/157579a2201241aaafcff94e93d7da0e/params/model.kwargs.subsample
@@ -0,0 +1 @@
+0.8789
\ No newline at end of file
diff --git a/github/examples/mlruns/881301994755452456/157579a2201241aaafcff94e93d7da0e/params/model.module_path b/github/examples/mlruns/881301994755452456/157579a2201241aaafcff94e93d7da0e/params/model.module_path
new file mode 100644
index 0000000..bdb8957
--- /dev/null
+++ b/github/examples/mlruns/881301994755452456/157579a2201241aaafcff94e93d7da0e/params/model.module_path
@@ -0,0 +1 @@
+qlib.contrib.model.gbdt
\ No newline at end of file
diff --git a/github/examples/mlruns/881301994755452456/157579a2201241aaafcff94e93d7da0e/params/record b/github/examples/mlruns/881301994755452456/157579a2201241aaafcff94e93d7da0e/params/record
new file mode 100644
index 0000000..a264724
--- /dev/null
+++ b/github/examples/mlruns/881301994755452456/157579a2201241aaafcff94e93d7da0e/params/record
@@ -0,0 +1 @@
+[{'class': 'SignalRecord', 'module_path': 'qlib.workflow.record_temp', 'kwargs': {'model': '<MODEL>', 'dataset': '<DATASET>'}}, {'class': 'SigAnaRecord', 'module_path': 'qlib.workflow.record_temp', 'kwargs': {'ana_long_short': False, 'ann_scaler': 252}}, {'class': 'PortAnaRecord', 'module_path': 'qlib.workflow.record_temp', 'kwargs': {'config': {'strategy': {'class': 'TopkDropoutStrategy', 'module_path': 'qlib.contrib.strategy', 'kwargs': {'signal': '<PRED>', 'topk': 50, 'n_drop': 5}}, 'backtest': {'start_time': datetime.date(2017, 1, 1), 'end_time': datetime.date(2020, 8, 1), 'account': 100000000, 'benchmark': 'SH000300', 'exchange_kwargs': {'limit_threshold': 0.095, 'deal_price': 'close', 'open_cost': 0.0005, 'close_cost': 0.0015, 'min_cost': 5}}}}}]
\ No newline at end of file
diff --git a/github/examples/mlruns/881301994755452456/157579a2201241aaafcff94e93d7da0e/tags/hostname b/github/examples/mlruns/881301994755452456/157579a2201241aaafcff94e93d7da0e/tags/hostname
new file mode 100644
index 0000000..f5daa18
--- /dev/null
+++ b/github/examples/mlruns/881301994755452456/157579a2201241aaafcff94e93d7da0e/tags/hostname
@@ -0,0 +1 @@
+LAPTOP-L7JMBF8C
\ No newline at end of file
diff --git a/github/examples/mlruns/881301994755452456/157579a2201241aaafcff94e93d7da0e/tags/mlflow.runName b/github/examples/mlruns/881301994755452456/157579a2201241aaafcff94e93d7da0e/tags/mlflow.runName
new file mode 100644
index 0000000..25487e4
--- /dev/null
+++ b/github/examples/mlruns/881301994755452456/157579a2201241aaafcff94e93d7da0e/tags/mlflow.runName
@@ -0,0 +1 @@
+mlflow_recorder
\ No newline at end of file
diff --git a/github/examples/mlruns/881301994755452456/157579a2201241aaafcff94e93d7da0e/tags/mlflow.source.name b/github/examples/mlruns/881301994755452456/157579a2201241aaafcff94e93d7da0e/tags/mlflow.source.name
new file mode 100644
index 0000000..3846681
--- /dev/null
+++ b/github/examples/mlruns/881301994755452456/157579a2201241aaafcff94e93d7da0e/tags/mlflow.source.name
@@ -0,0 +1 @@
+D:\project\python\tradenote\.venv\Scripts\qrun
\ No newline at end of file
diff --git a/github/examples/mlruns/881301994755452456/157579a2201241aaafcff94e93d7da0e/tags/mlflow.source.type b/github/examples/mlruns/881301994755452456/157579a2201241aaafcff94e93d7da0e/tags/mlflow.source.type
new file mode 100644
index 0000000..0c2c1fe
--- /dev/null
+++ b/github/examples/mlruns/881301994755452456/157579a2201241aaafcff94e93d7da0e/tags/mlflow.source.type
@@ -0,0 +1 @@
+LOCAL
\ No newline at end of file
diff --git a/github/examples/mlruns/881301994755452456/157579a2201241aaafcff94e93d7da0e/tags/mlflow.user b/github/examples/mlruns/881301994755452456/157579a2201241aaafcff94e93d7da0e/tags/mlflow.user
new file mode 100644
index 0000000..b9cec6f
--- /dev/null
+++ b/github/examples/mlruns/881301994755452456/157579a2201241aaafcff94e93d7da0e/tags/mlflow.user
@@ -0,0 +1 @@
+abulimity
\ No newline at end of file
diff --git a/mlruns/0/meta.yaml b/mlruns/0/meta.yaml
new file mode 100644
index 0000000..6c9c8cf
--- /dev/null
+++ b/mlruns/0/meta.yaml
@@ -0,0 +1,6 @@
+artifact_location: file:D:\project\python\tradenote\mlruns/0
+creation_time: 1750314275919
+experiment_id: '0'
+last_update_time: 1750314275919
+lifecycle_stage: active
+name: Default
diff --git a/mlruns/812028854715931404/0012f3eec07d4e4980b4ec205853584d/artifacts/code_cached.txt b/mlruns/812028854715931404/0012f3eec07d4e4980b4ec205853584d/artifacts/code_cached.txt
new file mode 100644
index 0000000..e69de29
diff --git a/mlruns/812028854715931404/0012f3eec07d4e4980b4ec205853584d/artifacts/code_diff.txt b/mlruns/812028854715931404/0012f3eec07d4e4980b4ec205853584d/artifacts/code_diff.txt
new file mode 100644
index 0000000..ceea66d
--- /dev/null
+++ b/mlruns/812028854715931404/0012f3eec07d4e4980b4ec205853584d/artifacts/code_diff.txt
@@ -0,0 +1,1361 @@
+diff --git a/test/README_MA_Strategy.md b/test/README_MA_Strategy.md
+deleted file mode 100644
+index 5facaf7..0000000
+--- a/test/README_MA_Strategy.md
++++ /dev/null
+@@ -1,197 +0,0 @@
+-# 均线交叉策略 (Moving Average Crossover Strategy)
+-
+-## 策略概述
+-
+-这是一个基于qlib框架实现的均线交叉策略，核心逻辑是：
+-- **金叉买入**：短期均线上穿长期均线时买入
+-- **死叉卖出**：短期均线下穿长期均线时卖出
+-
+-## 文件说明
+-
+-### 1. `ma_cross_strategy.py`
+-完整的策略实现，包含：
+-- `MACrossStrategy` 类：继承自qlib的TopkDropoutStrategy
+-- 完整的回测框架
+-- 结果分析和保存
+-
+-### 2. `ma_cross_strategy_improved.py`
+-改进版本，包含：
+-- 更完善的数据获取逻辑
+-- 错误处理机制
+-- 简化版回测功能
+-
+-### 3. `simple_ma_strategy.py` ⭐ **推荐使用**
+-简单实用的版本，包含：
+-- 清晰的数据获取和处理
+-- 均线信号计算
+-- 收益计算和分析
+-- 可视化图表生成
+-- 结果保存功能
+-
+-## 使用方法
+-
+-### 环境准备
+-
+-1. 确保已安装qlib：
+-```bash
+-pip install pyqlib
+-```
+-
+-2. 下载qlib数据（如果还没有）：
+-```bash
+-# 下载中国股票数据
+-python -m qlib.data.dump_bin --csv_path ~/.qlib/qlib_data/cn_data --include_fields close,open,high,low,volume
+-```
+-
+-### 运行策略
+-
+-#### 方法1：运行简单版本（推荐）
+-```bash
+-cd test
+-python simple_ma_strategy.py
+-```
+-
+-#### 方法2：运行完整版本
+-```bash
+-cd test
+-python ma_cross_strategy.py
+-```
+-
+-#### 方法3：运行改进版本
+-```bash
+-cd test
+-python ma_cross_strategy_improved.py
+-```
+-
+-## 策略参数
+-
+-可以在代码中修改以下参数：
+-
+-```python
+-# 均线周期
+-short_window = 5    # 短期均线周期
+-long_window = 20    # 长期均线周期
+-
+-# 回测时间
+-start_date = "2020-01-01"
+-end_date = "2023-12-31"
+-
+-# 初始资金
+-initial_capital = 100000
+-
+-# 股票池
+-instruments = "csi300"  # 沪深300成分股
+-```
+-
+-## 输出结果
+-
+-运行策略后会生成以下文件：
+-
+-1. **CSV文件**：
+-   - `ma_cross_signals.csv`：买卖信号数据
+-   - `ma_cross_cumulative_returns.csv`：累计收益数据
+-   - `ma_cross_capital_curve.csv`：资金曲线数据
+-
+-2. **图表文件**：
+-   - `ma_cross_strategy_results.png`：策略结果可视化图表
+-
+-3. **控制台输出**：
+-   - 策略分析结果
+-   - 收益统计
+-   - 风险指标
+-
+-## 策略分析指标
+-
+-### 收益指标
+-- 总收益率
+-- 年化收益率
+-- 最终资金
+-
+-### 风险指标
+-- 年化波动率
+-- 夏普比率
+-- 胜率
+-- 最大回撤
+-
+-### 交易统计
+-- 买入信号数量
+-- 卖出信号数量
+-- 总交易次数
+-
+-## 策略逻辑详解
+-
+-### 1. 均线计算
+-```python
+-# 计算短期和长期均线
+-short_ma = price_data.rolling(window=short_window).mean()
+-long_ma = price_data.rolling(window=long_window).mean()
+-```
+-
+-### 2. 交叉信号判断
+-```python
+-# 计算均线差值
+-diff = short_ma - long_ma
+-
+-# 金叉：短期均线从下方穿越长期均线
+-if diff.iloc[i-1] < 0 and diff.iloc[i] > 0:
+-    signal = 1  # 买入信号
+-
+-# 死叉：短期均线从上方穿越长期均线
+-elif diff.iloc[i-1] > 0 and diff.iloc[i] < 0:
+-    signal = -1  # 卖出信号
+-```
+-
+-### 3. 收益计算
+-```python
+-# 策略收益（简化处理）
+-strategy_returns = signals * 0.01
+-
+-# 累计收益
+-cumulative_returns = strategy_returns.sum(axis=1).cumsum()
+-```
+-
+-## 注意事项
+-
+-1. **数据依赖**：确保qlib数据已正确下载和配置
+-2. **参数调优**：可以根据不同市场环境调整均线周期
+-3. **风险控制**：实际交易中需要加入止损和仓位管理
+-4. **交易成本**：当前版本未考虑交易费用，实际应用需要考虑
+-
+-## 扩展功能
+-
+-可以基于此策略进行以下扩展：
+-
+-1. **多均线策略**：使用多条均线进行更复杂的信号判断
+-2. **量价配合**：结合成交量指标优化信号
+-3. **止损机制**：添加动态止损策略
+-4. **仓位管理**：根据信号强度调整仓位大小
+-5. **多股票组合**：构建股票组合分散风险
+-
+-## 常见问题
+-
+-### Q: 如何修改股票池？
+-A: 在代码中修改 `instruments` 参数，例如：
+-```python
+-instruments = "csi500"  # 中证500
+-instruments = ["000001.SZ", "000002.SZ"]  # 指定股票列表
+-```
+-
+-### Q: 如何调整均线周期？
+-A: 修改 `short_window` 和 `long_window` 参数：
+-```python
+-short_window = 10  # 10日均线
+-long_window = 30   # 30日均线
+-```
+-
+-### Q: 如何查看详细的交易记录？
+-A: 查看生成的 `ma_cross_signals.csv` 文件，其中包含每日的买卖信号。
+-
+-## 联系方式
+-
+-如有问题或建议，请通过以下方式联系：
+-- 提交Issue到项目仓库
+-- 发送邮件到项目维护者
+-
+----
+-
+-**免责声明**：本策略仅供学习和研究使用，不构成投资建议。实际投资请谨慎决策，并承担相应风险。 
+\ No newline at end of file
+diff --git a/test/damo1.py b/test/damo1.py
+index 03102e1..6477dc0 100644
+--- a/test/damo1.py
++++ b/test/damo1.py
+@@ -1,4 +1,4 @@
+-# python scripts/get_data.py qlib_data --target_dir ../qlib_data/cn_data --region cn
++# python scripts/get_data.py qlib_data --target_dir D:/sync/sync/qlib/qlib_data/cn_data --region cn
+ 
+ import qlib
+ # region in [REG_CN, REG_US]
+diff --git a/test/ma_cross_strategy.py b/test/ma_cross_strategy.py
+deleted file mode 100644
+index 719d849..0000000
+--- a/test/ma_cross_strategy.py
++++ /dev/null
+@@ -1,274 +0,0 @@
+-"""
+-均线交叉策略：金叉买入，死叉卖出
+-使用qlib框架实现
+-"""
+-
+-import qlib
+-from qlib.constant import REG_CN
+-from qlib.utils import init_instance_by_config
+-from qlib.workflow import R
+-from qlib.workflow.record_temp import SignalRecord, PortAnaRecord
+-from qlib.contrib.evaluate import backtest_daily
+-from qlib.contrib.strategy import TopkDropoutStrategy
+-import pandas as pd
+-import numpy as np
+-from typing import Dict, List, Tuple
+-
+-
+-class MACrossStrategy(TopkDropoutStrategy):
+-    """
+-    均线交叉策略
+-    金叉（短期均线上穿长期均线）买入
+-    死叉（短期均线下穿长期均线）卖出
+-    """
+-    
+-    def __init__(self, 
+-                 short_window: int = 5,
+-                 long_window: int = 20,
+-                 topk: int = 50,
+-                 n_drop: int = 5,
+-                 **kwargs):
+-        """
+-        初始化策略参数
+-        
+-        Args:
+-            short_window: 短期均线周期
+-            long_window: 长期均线周期
+-            topk: 选择前k只股票
+-            n_drop: 剔除前n只股票
+-        """
+-        super().__init__(topk=topk, n_drop=n_drop, **kwargs)
+-        self.short_window = short_window
+-        self.long_window = long_window
+-        
+-    def generate_trade_decision(self, score: pd.Series, trade_step: int) -> pd.Series:
+-        """
+-        生成交易决策
+-        
+-        Args:
+-            score: 股票评分
+-            trade_step: 交易步骤
+-            
+-        Returns:
+-            交易决策，1表示买入，-1表示卖出，0表示持有
+-        """
+-        # 获取当前持仓
+-        current_pos = self.get_current_position()
+-        
+-        # 计算均线信号
+-        signal = self._calculate_ma_signal(score.index.tolist(), trade_step)
+-        
+-        # 生成交易决策
+-        decision = pd.Series(0, index=score.index)
+-        
+-        # 金叉买入信号
+-        buy_signal = signal == 1
+-        decision[buy_signal] = 1
+-        
+-        # 死叉卖出信号
+-        sell_signal = signal == -1
+-        decision[sell_signal] = -1
+-        
+-        return decision
+-    
+-    def _calculate_ma_signal(self, instruments: List[str], trade_step: int) -> pd.Series:
+-        """
+-        计算均线交叉信号
+-        
+-        Args:
+-            instruments: 股票代码列表
+-            trade_step: 交易步骤
+-            
+-        Returns:
+-            信号序列：1表示金叉买入，-1表示死叉卖出，0表示无信号
+-        """
+-        # 获取历史数据
+-        data = self._get_historical_data(instruments, trade_step)
+-        
+-        signals = pd.Series(0, index=instruments)
+-        
+-        for instrument in instruments:
+-            if instrument in data.index:
+-                # 计算短期和长期均线
+-                short_ma = data.loc[instrument].rolling(window=self.short_window).mean()
+-                long_ma = data.loc[instrument].rolling(window=self.long_window).mean()
+-                
+-                # 计算交叉信号
+-                if len(short_ma) >= 2 and len(long_ma) >= 2:
+-                    # 当前和前一个时间点的均线差值
+-                    current_diff = short_ma.iloc[-1] - long_ma.iloc[-1]
+-                    prev_diff = short_ma.iloc[-2] - long_ma.iloc[-2]
+-                    
+-                    # 金叉：短期均线从下方穿越长期均线
+-                    if prev_diff < 0 and current_diff > 0:
+-                        signals[instrument] = 1
+-                    # 死叉：短期均线从上方穿越长期均线
+-                    elif prev_diff > 0 and current_diff < 0:
+-                        signals[instrument] = -1
+-        
+-        return signals
+-    
+-    def _get_historical_data(self, instruments: List[str], trade_step: int) -> pd.DataFrame:
+-        """
+-        获取历史价格数据
+-        
+-        Args:
+-            instruments: 股票代码列表
+-            trade_step: 交易步骤
+-            
+-        Returns:
+-            历史价格数据
+-        """
+-        # 这里简化处理，实际应该从qlib数据源获取
+-        # 在实际应用中，您需要使用qlib的数据接口
+-        try:
+-            # 获取最近的数据用于计算均线
+-            # 这里使用模拟数据，实际应该从qlib获取
+-            dates = pd.date_range(end=pd.Timestamp.now(), periods=50, freq='D')
+-            data = pd.DataFrame(
+-                np.random.randn(len(dates), len(instruments)) * 0.02 + 1.0,
+-                index=dates,
+-                columns=instruments
+-            )
+-            return data
+-        except Exception as e:
+-            print(f"获取历史数据失败: {e}")
+-            return pd.DataFrame()
+-
+-
+-def create_ma_cross_strategy_config():
+-    """
+-    创建均线交叉策略配置
+-    """
+-    strategy_config = {
+-        "class": "MACrossStrategy",
+-        "module_path": "test.ma_cross_strategy",
+-        "kwargs": {
+-            "short_window": 5,
+-            "long_window": 20,
+-            "topk": 50,
+-            "n_drop": 5,
+-        }
+-    }
+-    
+-    return strategy_config
+-
+-
+-def run_backtest():
+-    """
+-    运行回测
+-    """
+-    # 初始化qlib
+-    qlib.init(provider_uri='~/.qlib/qlib_data/cn_data', region=REG_CN)
+-    
+-    # 策略配置
+-    strategy_config = create_ma_cross_strategy_config()
+-    
+-    # 回测配置
+-    backtest_config = {
+-        "start_time": "2020-01-01",
+-        "end_time": "2023-12-31",
+-        "benchmark": "SH000300",  # 沪深300作为基准
+-        "account": 100000000,     # 初始资金1亿
+-        "exchange_kwargs": {
+-            "freq": "day",
+-            "limit_threshold": 0.095,
+-            "deal_price": "close",
+-            "open_cost": 0.0005,
+-            "close_cost": 0.0015,
+-            "min_cost": 5,
+-        }
+-    }
+-    
+-    # 创建策略实例
+-    strategy = init_instance_by_config(strategy_config)
+-    
+-    # 运行回测
+-    with R.start(experiment_name="ma_cross_strategy"):
+-        # 记录信号
+-        sr = SignalRecord(model=strategy, dataset=None, recorder=R.get_recorder())
+-        sr.generate()
+-        
+-        # 记录投资组合分析
+-        par = PortAnaRecord(recorder=R.get_recorder(), config=backtest_config, strategy=strategy)
+-        par.generate()
+-        
+-        # 获取回测结果
+-        report_normal, positions_normal = backtest_daily(
+-            account=backtest_config["account"],
+-            benchmark=backtest_config["benchmark"],
+-            start_time=backtest_config["start_time"],
+-            end_time=backtest_config["end_time"],
+-            strategy=strategy,
+-            exchange_kwargs=backtest_config["exchange_kwargs"]
+-        )
+-        
+-        return report_normal, positions_normal
+-
+-
+-def analyze_results(report: pd.DataFrame, positions: pd.DataFrame):
+-    """
+-    分析回测结果
+-    
+-    Args:
+-        report: 回测报告
+-        positions: 持仓信息
+-    """
+-    print("=" * 50)
+-    print("均线交叉策略回测结果")
+-    print("=" * 50)
+-    
+-    # 基本统计信息
+-    print(f"总收益率: {report['return'].sum():.2%}")
+-    print(f"年化收益率: {report['return'].mean() * 252:.2%}")
+-    print(f"最大回撤: {report['drawdown'].min():.2%}")
+-    print(f"夏普比率: {report['sharpe'].iloc[-1]:.2f}")
+-    print(f"胜率: {(report['return'] > 0).mean():.2%}")
+-    
+-    # 风险指标
+-    volatility = report['return'].std() * np.sqrt(252)
+-    print(f"年化波动率: {volatility:.2%}")
+-    
+-    # 最大回撤期间
+-    max_drawdown_idx = report['drawdown'].idxmin()
+-    print(f"最大回撤发生时间: {max_drawdown_idx}")
+-    
+-    # 收益分布
+-    print("\n收益分布统计:")
+-    print(f"平均日收益: {report['return'].mean():.2%}")
+-    print(f"收益标准差: {report['return'].std():.2%}")
+-    print(f"最小日收益: {report['return'].min():.2%}")
+-    print(f"最大日收益: {report['return'].max():.2%}")
+-    
+-    # 交易统计
+-    if 'trade_count' in report.columns:
+-        print(f"\n总交易次数: {report['trade_count'].sum()}")
+-        print(f"平均每日交易次数: {report['trade_count'].mean():.1f}")
+-
+-
+-def main():
+-    """
+-    主函数
+-    """
+-    print("开始运行均线交叉策略回测...")
+-    
+-    try:
+-        # 运行回测
+-        report, positions = run_backtest()
+-        
+-        # 分析结果
+-        analyze_results(report, positions)
+-        
+-        # 保存结果
+-        report.to_csv("ma_cross_strategy_report.csv")
+-        positions.to_csv("ma_cross_strategy_positions.csv")
+-        
+-        print("\n回测完成！结果已保存到CSV文件。")
+-        
+-    except Exception as e:
+-        print(f"回测过程中出现错误: {e}")
+-        print("请确保已正确安装qlib并下载了相应的数据。")
+-
+-
+-if __name__ == "__main__":
+-    main() 
+\ No newline at end of file
+diff --git a/test/ma_cross_strategy_improved.py b/test/ma_cross_strategy_improved.py
+deleted file mode 100644
+index d166c68..0000000
+--- a/test/ma_cross_strategy_improved.py
++++ /dev/null
+@@ -1,443 +0,0 @@
+-"""
+-改进的均线交叉策略：金叉买入，死叉卖出
+-使用qlib框架实现，包含完整的数据获取和信号计算
+-"""
+-
+-import qlib
+-from qlib.constant import REG_CN
+-from qlib.utils import init_instance_by_config
+-from qlib.workflow import R
+-from qlib.workflow.record_temp import SignalRecord, PortAnaRecord
+-from qlib.contrib.evaluate import backtest_daily
+-from qlib.contrib.strategy import TopkDropoutStrategy
+-from qlib.data import D
+-from qlib.data.dataset import DatasetH
+-from qlib.data.dataset.handler import DataHandlerLP
+-import pandas as pd
+-import numpy as np
+-from typing import Dict, List, Tuple
+-import warnings
+-warnings.filterwarnings('ignore')
+-
+-
+-class MACrossStrategyImproved(TopkDropoutStrategy):
+-    """
+-    改进的均线交叉策略
+-    金叉（短期均线上穿长期均线）买入
+-    死叉（短期均线下穿长期均线）卖出
+-    """
+-    
+-    def __init__(self, 
+-                 short_window: int = 5,
+-                 long_window: int = 20,
+-                 topk: int = 50,
+-                 n_drop: int = 5,
+-                 universe: str = "csi300",
+-                 **kwargs):
+-        """
+-        初始化策略参数
+-        
+-        Args:
+-            short_window: 短期均线周期
+-            long_window: 长期均线周期
+-            topk: 选择前k只股票
+-            n_drop: 剔除前n只股票
+-            universe: 股票池
+-        """
+-        super().__init__(topk=topk, n_drop=n_drop, **kwargs)
+-        self.short_window = short_window
+-        self.long_window = long_window
+-        self.universe = universe
+-        self.instruments = None
+-        self.price_cache = {}
+-        
+-    def generate_trade_decision(self, score: pd.Series, trade_step: int) -> pd.Series:
+-        """
+-        生成交易决策
+-        
+-        Args:
+-            score: 股票评分
+-            trade_step: 交易步骤
+-            
+-        Returns:
+-            交易决策，1表示买入，-1表示卖出，0表示持有
+-        """
+-        # 获取当前持仓
+-        current_pos = self.get_current_position()
+-        
+-        # 计算均线信号
+-        signal = self._calculate_ma_signal(score.index.tolist(), trade_step)
+-        
+-        # 生成交易决策
+-        decision = pd.Series(0, index=score.index)
+-        
+-        # 金叉买入信号
+-        buy_signal = signal == 1
+-        decision[buy_signal] = 1
+-        
+-        # 死叉卖出信号
+-        sell_signal = signal == -1
+-        decision[sell_signal] = -1
+-        
+-        return decision
+-    
+-    def _calculate_ma_signal(self, instruments: List[str], trade_step: int) -> pd.Series:
+-        """
+-        计算均线交叉信号
+-        
+-        Args:
+-            instruments: 股票代码列表
+-            trade_step: 交易步骤
+-            
+-        Returns:
+-            信号序列：1表示金叉买入，-1表示死叉卖出，0表示无信号
+-        """
+-        signals = pd.Series(0, index=instruments)
+-        
+-        # 获取当前日期
+-        current_date = self._get_current_date(trade_step)
+-        
+-        for instrument in instruments:
+-            try:
+-                # 获取历史价格数据
+-                price_data = self._get_price_data(instrument, current_date)
+-                
+-                if price_data is not None and len(price_data) >= self.long_window:
+-                    # 计算短期和长期均线
+-                    short_ma = price_data['close'].rolling(window=self.short_window).mean()
+-                    long_ma = price_data['close'].rolling(window=self.long_window).mean()
+-                    
+-                    # 计算交叉信号
+-                    if len(short_ma) >= 2 and len(long_ma) >= 2:
+-                        # 当前和前一个时间点的均线差值
+-                        current_diff = short_ma.iloc[-1] - long_ma.iloc[-1]
+-                        prev_diff = short_ma.iloc[-2] - long_ma.iloc[-2]
+-                        
+-                        # 金叉：短期均线从下方穿越长期均线
+-                        if prev_diff < 0 and current_diff > 0:
+-                            signals[instrument] = 1
+-                        # 死叉：短期均线从上方穿越长期均线
+-                        elif prev_diff > 0 and current_diff < 0:
+-                            signals[instrument] = -1
+-                            
+-            except Exception as e:
+-                print(f"计算{instrument}均线信号时出错: {e}")
+-                continue
+-        
+-        return signals
+-    
+-    def _get_price_data(self, instrument: str, current_date: str) -> pd.DataFrame:
+-        """
+-        获取股票价格数据
+-        
+-        Args:
+-            instrument: 股票代码
+-            current_date: 当前日期
+-            
+-        Returns:
+-            价格数据DataFrame
+-        """
+-        try:
+-            # 计算开始日期（获取足够的历史数据来计算均线）
+-            start_date = pd.Timestamp(current_date) - pd.Timedelta(days=self.long_window * 2)
+-            
+-            # 从qlib获取数据
+-            data = D.features(
+-                instruments=[instrument],
+-                start_time=start_date.strftime('%Y-%m-%d'),
+-                end_time=current_date,
+-                freq='day',
+-                fields=['$close', '$open', '$high', '$low', '$volume']
+-            )
+-            
+-            if data is not None and not data.empty:
+-                # 重命名列
+-                data.columns = ['close', 'open', 'high', 'low', 'volume']
+-                return data
+-            else:
+-                return None
+-                
+-        except Exception as e:
+-            print(f"获取{instrument}价格数据失败: {e}")
+-            return None
+-    
+-    def _get_current_date(self, trade_step: int) -> str:
+-        """
+-        根据交易步骤获取当前日期
+-        
+-        Args:
+-            trade_step: 交易步骤
+-            
+-        Returns:
+-            当前日期字符串
+-        """
+-        # 这里简化处理，实际应该从qlib的日历获取
+-        # 假设从2020-01-01开始，每个trade_step代表一天
+-        start_date = pd.Timestamp('2020-01-01')
+-        current_date = start_date + pd.Timedelta(days=trade_step)
+-        return current_date.strftime('%Y-%m-%d')
+-
+-
+-def create_dataset_config():
+-    """
+-    创建数据集配置
+-    """
+-    dataset_config = {
+-        "class": "DatasetH",
+-        "module_path": "qlib.data.dataset",
+-        "kwargs": {
+-            "handler": {
+-                "class": "DataHandlerLP",
+-                "module_path": "qlib.data.dataset.handler",
+-                "kwargs": {
+-                    "start_time": "2020-01-01",
+-                    "end_time": "2023-12-31",
+-                    "fit_start_time": "2020-01-01",
+-                    "fit_end_time": "2023-12-31",
+-                    "instruments": "csi300",
+-                    "infer_processors": [
+-                        {
+-                            "class": "RobustZScoreNorm",
+-                            "module_path": "qlib.data.dataset.processor",
+-                            "kwargs": {
+-                                "fields_group": "feature",
+-                                "clip_outlier": True,
+-                            },
+-                        },
+-                        {
+-                            "class": "Fillna",
+-                            "module_path": "qlib.data.dataset.processor",
+-                            "kwargs": {
+-                                "fields_group": "feature",
+-                            },
+-                        },
+-                    ],
+-                    "learn_processors": [
+-                        {
+-                            "class": "DropnaLabel",
+-                            "module_path": "qlib.data.dataset.processor",
+-                        },
+-                        {
+-                            "class": "CSRankNorm",
+-                            "module_path": "qlib.data.dataset.processor",
+-                            "kwargs": {
+-                                "fields_group": "label",
+-                            },
+-                        },
+-                    ],
+-                    "instruments": "csi300",
+-                },
+-            },
+-            "segments": {
+-                "train": ("2020-01-01", "2022-12-31"),
+-                "valid": ("2023-01-01", "2023-06-30"),
+-                "test": ("2023-07-01", "2023-12-31"),
+-            },
+-        },
+-    }
+-    
+-    return dataset_config
+-
+-
+-def create_ma_cross_strategy_config():
+-    """
+-    创建均线交叉策略配置
+-    """
+-    strategy_config = {
+-        "class": "MACrossStrategyImproved",
+-        "module_path": "test.ma_cross_strategy_improved",
+-        "kwargs": {
+-            "short_window": 5,
+-            "long_window": 20,
+-            "topk": 50,
+-            "n_drop": 5,
+-            "universe": "csi300",
+-        }
+-    }
+-    
+-    return strategy_config
+-
+-
+-def run_backtest():
+-    """
+-    运行回测
+-    """
+-    # 初始化qlib
+-    qlib.init(provider_uri='~/.qlib/qlib_data/cn_data', region=REG_CN)
+-    
+-    # 策略配置
+-    strategy_config = create_ma_cross_strategy_config()
+-    
+-    # 回测配置
+-    backtest_config = {
+-        "start_time": "2020-01-01",
+-        "end_time": "2023-12-31",
+-        "benchmark": "SH000300",  # 沪深300作为基准
+-        "account": 100000000,     # 初始资金1亿
+-        "exchange_kwargs": {
+-            "freq": "day",
+-            "limit_threshold": 0.095,
+-            "deal_price": "close",
+-            "open_cost": 0.0005,
+-            "close_cost": 0.0015,
+-            "min_cost": 5,
+-        }
+-    }
+-    
+-    # 创建策略实例
+-    strategy = init_instance_by_config(strategy_config)
+-    
+-    # 运行回测
+-    with R.start(experiment_name="ma_cross_strategy_improved"):
+-        # 记录信号
+-        sr = SignalRecord(model=strategy, dataset=None, recorder=R.get_recorder())
+-        sr.generate()
+-        
+-        # 记录投资组合分析
+-        par = PortAnaRecord(recorder=R.get_recorder(), config=backtest_config, strategy=strategy)
+-        par.generate()
+-        
+-        # 获取回测结果
+-        report_normal, positions_normal = backtest_daily(
+-            account=backtest_config["account"],
+-            benchmark=backtest_config["benchmark"],
+-            start_time=backtest_config["start_time"],
+-            end_time=backtest_config["end_time"],
+-            strategy=strategy,
+-            exchange_kwargs=backtest_config["exchange_kwargs"]
+-        )
+-        
+-        return report_normal, positions_normal
+-
+-
+-def analyze_results(report: pd.DataFrame, positions: pd.DataFrame):
+-    """
+-    分析回测结果
+-    
+-    Args:
+-        report: 回测报告
+-        positions: 持仓信息
+-    """
+-    print("=" * 50)
+-    print("均线交叉策略回测结果")
+-    print("=" * 50)
+-    
+-    # 基本统计信息
+-    print(f"总收益率: {report['return'].sum():.2%}")
+-    print(f"年化收益率: {report['return'].mean() * 252:.2%}")
+-    print(f"最大回撤: {report['drawdown'].min():.2%}")
+-    
+-    if 'sharpe' in report.columns:
+-        print(f"夏普比率: {report['sharpe'].iloc[-1]:.2f}")
+-    
+-    print(f"胜率: {(report['return'] > 0).mean():.2%}")
+-    
+-    # 风险指标
+-    volatility = report['return'].std() * np.sqrt(252)
+-    print(f"年化波动率: {volatility:.2%}")
+-    
+-    # 最大回撤期间
+-    max_drawdown_idx = report['drawdown'].idxmin()
+-    print(f"最大回撤发生时间: {max_drawdown_idx}")
+-    
+-    # 收益分布
+-    print("\n收益分布统计:")
+-    print(f"平均日收益: {report['return'].mean():.2%}")
+-    print(f"收益标准差: {report['return'].std():.2%}")
+-    print(f"最小日收益: {report['return'].min():.2%}")
+-    print(f"最大日收益: {report['return'].max():.2%}")
+-    
+-    # 交易统计
+-    if 'trade_count' in report.columns:
+-        print(f"\n总交易次数: {report['trade_count'].sum()}")
+-        print(f"平均每日交易次数: {report['trade_count'].mean():.1f}")
+-
+-
+-def create_simple_backtest():
+-    """
+-    创建简化版回测，用于演示
+-    """
+-    print("创建简化版均线交叉策略回测...")
+-    
+-    # 初始化qlib
+-    qlib.init(provider_uri='~/.qlib/qlib_data/cn_data', region=REG_CN)
+-    
+-    # 获取股票列表
+-    instruments = D.list_instruments(instruments="csi300", start_time="2020-01-01", end_time="2023-12-31")
+-    
+-    print(f"获取到 {len(instruments)} 只股票")
+-    
+-    # 选择前10只股票进行演示
+-    demo_instruments = instruments[:10]
+-    
+-    # 获取价格数据
+-    data = D.features(
+-        instruments=demo_instruments,
+-        start_time="2020-01-01",
+-        end_time="2023-12-31",
+-        freq='day',
+-        fields=['$close']
+-    )
+-    
+-    print(f"获取到价格数据，形状: {data.shape}")
+-    
+-    # 计算均线
+-    short_ma = data.rolling(window=5).mean()
+-    long_ma = data.rolling(window=20).mean()
+-    
+-    # 计算交叉信号
+-    signals = pd.DataFrame(0, index=data.index, columns=data.columns)
+-    
+-    for col in data.columns:
+-        # 计算均线差值
+-        diff = short_ma[col] - long_ma[col]
+-        
+-        # 计算交叉信号
+-        for i in range(1, len(diff)):
+-            if diff.iloc[i-1] < 0 and diff.iloc[i] > 0:
+-                signals.iloc[i, signals.columns.get_loc(col)] = 1  # 金叉买入
+-            elif diff.iloc[i-1] > 0 and diff.iloc[i] < 0:
+-                signals.iloc[i, signals.columns.get_loc(col)] = -1  # 死叉卖出
+-    
+-    # 统计信号
+-    buy_signals = (signals == 1).sum().sum()
+-    sell_signals = (signals == -1).sum().sum()
+-    
+-    print(f"\n信号统计:")
+-    print(f"买入信号数量: {buy_signals}")
+-    print(f"卖出信号数量: {sell_signals}")
+-    
+-    # 计算简单收益（假设每次信号都产生1%的收益）
+-    returns = signals * 0.01
+-    cumulative_returns = returns.sum(axis=1).cumsum()
+-    
+-    print(f"\n累计收益: {cumulative_returns.iloc[-1]:.2%}")
+-    
+-    return signals, cumulative_returns
+-
+-
+-def main():
+-    """
+-    主函数
+-    """
+-    print("开始运行均线交叉策略回测...")
+-    
+-    try:
+-        # 运行简化版回测
+-        signals, cumulative_returns = create_simple_backtest()
+-        
+-        # 保存简化版结果
+-        signals.to_csv("ma_cross_signals.csv")
+-        cumulative_returns.to_csv("ma_cross_cumulative_returns.csv")
+-        
+-        print("\n简化版回测完成！")
+-        print("信号数据已保存到 ma_cross_signals.csv")
+-        print("累计收益已保存到 ma_cross_cumulative_returns.csv")
+-        
+-    except Exception as e:
+-        print(f"回测过程中出现错误: {e}")
+-        print("请确保已正确安装qlib并下载了相应的数据。")
+-
+-
+-if __name__ == "__main__":
+-    main() 
+\ No newline at end of file
+diff --git a/test/ma_strategy_demo.py b/test/ma_strategy_demo.py
+deleted file mode 100644
+index 1fa4fb4..0000000
+Binary files a/test/ma_strategy_demo.py and /dev/null differ
+diff --git a/test/simple_ma_strategy.py b/test/simple_ma_strategy.py
+deleted file mode 100644
+index 8d03f6b..0000000
+--- a/test/simple_ma_strategy.py
++++ /dev/null
+@@ -1,298 +0,0 @@
+-"""
+-简单实用的均线交叉策略
+-金叉买入，死叉卖出
+-"""
+-
+-import qlib
+-from qlib.constant import REG_CN
+-from qlib.data import D
+-import pandas as pd
+-import numpy as np
+-import matplotlib.pyplot as plt
+-from datetime import datetime, timedelta
+-
+-
+-def init_qlib():
+-    """初始化qlib"""
+-    try:
+-        qlib.init(provider_uri='~/.qlib/qlib_data/cn_data', region=REG_CN)
+-        print("qlib初始化成功")
+-        return True
+-    except Exception as e:
+-        print(f"qlib初始化失败: {e}")
+-        print("请确保已安装qlib并下载了数据")
+-        return False
+-
+-
+-def get_stock_data(instruments, start_date, end_date):
+-    """
+-    获取股票数据
+-    
+-    Args:
+-        instruments: 股票代码列表
+-        start_date: 开始日期
+-        end_date: 结束日期
+-    
+-    Returns:
+-        股票价格数据
+-    """
+-    try:
+-        data = D.features(
+-            instruments=instruments,
+-            start_time=start_date,
+-            end_time=end_date,
+-            freq='day',
+-            fields=['$close', '$open', '$high', '$low', '$volume']
+-        )
+-        
+-        if data is not None and not data.empty:
+-            # 重命名列
+-            data.columns = ['close', 'open', 'high', 'low', 'volume']
+-            return data
+-        else:
+-            print("未获取到数据")
+-            return None
+-            
+-    except Exception as e:
+-        print(f"获取数据失败: {e}")
+-        return None
+-
+-
+-def calculate_ma_signals(data, short_window=5, long_window=20):
+-    """
+-    计算均线交叉信号
+-    
+-    Args:
+-        data: 价格数据
+-        short_window: 短期均线周期
+-        long_window: 长期均线周期
+-    
+-    Returns:
+-        信号DataFrame，1表示买入，-1表示卖出，0表示无信号
+-    """
+-    signals = pd.DataFrame(0, index=data.index, columns=data.columns)
+-    
+-    for col in data.columns:
+-        if col == 'close':
+-            continue
+-            
+-        # 计算均线
+-        short_ma = data[col].rolling(window=short_window).mean()
+-        long_ma = data[col].rolling(window=long_window).mean()
+-        
+-        # 计算均线差值
+-        diff = short_ma - long_ma
+-        
+-        # 计算交叉信号
+-        for i in range(1, len(diff)):
+-            if pd.notna(diff.iloc[i-1]) and pd.notna(diff.iloc[i]):
+-                # 金叉：短期均线从下方穿越长期均线
+-                if diff.iloc[i-1] < 0 and diff.iloc[i] > 0:
+-                    signals.iloc[i, signals.columns.get_loc(col)] = 1
+-                # 死叉：短期均线从上方穿越长期均线
+-                elif diff.iloc[i-1] > 0 and diff.iloc[i] < 0:
+-                    signals.iloc[i, signals.columns.get_loc(col)] = -1
+-    
+-    return signals
+-
+-
+-def calculate_returns(data, signals, initial_capital=100000):
+-    """
+-    计算策略收益
+-    
+-    Args:
+-        data: 价格数据
+-        signals: 信号数据
+-        initial_capital: 初始资金
+-    
+-    Returns:
+-        收益数据
+-    """
+-    # 计算日收益率
+-    returns = data.pct_change()
+-    
+-    # 策略收益（假设每次信号产生1%的收益）
+-    strategy_returns = signals * 0.01
+-    
+-    # 累计收益
+-    cumulative_returns = strategy_returns.sum(axis=1).cumsum()
+-    
+-    # 资金曲线
+-    capital_curve = initial_capital * (1 + cumulative_returns)
+-    
+-    return {
+-        'strategy_returns': strategy_returns,
+-        'cumulative_returns': cumulative_returns,
+-        'capital_curve': capital_curve
+-    }
+-
+-
+-def analyze_strategy(signals, returns_data):
+-    """
+-    分析策略表现
+-    
+-    Args:
+-        signals: 信号数据
+-        returns_data: 收益数据
+-    """
+-    print("=" * 50)
+-    print("均线交叉策略分析结果")
+-    print("=" * 50)
+-    
+-    # 信号统计
+-    buy_signals = (signals == 1).sum().sum()
+-    sell_signals = (signals == -1).sum().sum()
+-    
+-    print(f"买入信号数量: {buy_signals}")
+-    print(f"卖出信号数量: {sell_signals}")
+-    print(f"总信号数量: {buy_signals + sell_signals}")
+-    
+-    # 收益统计
+-    cumulative_returns = returns_data['cumulative_returns']
+-    capital_curve = returns_data['capital_curve']
+-    
+-    total_return = cumulative_returns.iloc[-1]
+-    annual_return = total_return / (len(cumulative_returns) / 252)
+-    
+-    print(f"\n收益统计:")
+-    print(f"总收益率: {total_return:.2%}")
+-    print(f"年化收益率: {annual_return:.2%}")
+-    print(f"最终资金: {capital_curve.iloc[-1]:,.0f}")
+-    
+-    # 风险统计
+-    daily_returns = returns_data['strategy_returns'].sum(axis=1)
+-    volatility = daily_returns.std() * np.sqrt(252)
+-    sharpe_ratio = annual_return / volatility if volatility > 0 else 0
+-    
+-    print(f"\n风险统计:")
+-    print(f"年化波动率: {volatility:.2%}")
+-    print(f"夏普比率: {sharpe_ratio:.2f}")
+-    print(f"胜率: {(daily_returns > 0).mean():.2%}")
+-
+-
+-def plot_results(data, signals, returns_data, stock_code):
+-    """
+-    绘制结果图表
+-    
+-    Args:
+-        data: 价格数据
+-        signals: 信号数据
+-        returns_data: 收益数据
+-        stock_code: 股票代码
+-    """
+-    fig, axes = plt.subplots(3, 1, figsize=(12, 10))
+-    
+-    # 绘制价格和均线
+-    axes[0].plot(data.index, data[stock_code], label='收盘价', alpha=0.7)
+-    short_ma = data[stock_code].rolling(window=5).mean()
+-    long_ma = data[stock_code].rolling(window=20).mean()
+-    axes[0].plot(data.index, short_ma, label='5日均线', alpha=0.8)
+-    axes[0].plot(data.index, long_ma, label='20日均线', alpha=0.8)
+-    
+-    # 标记买卖信号
+-    buy_signals = signals[stock_code] == 1
+-    sell_signals = signals[stock_code] == -1
+-    
+-    axes[0].scatter(data.index[buy_signals], data.loc[buy_signals, stock_code], 
+-                   color='red', marker='^', s=100, label='买入信号', alpha=0.8)
+-    axes[0].scatter(data.index[sell_signals], data.loc[sell_signals, stock_code], 
+-                   color='green', marker='v', s=100, label='卖出信号', alpha=0.8)
+-    
+-    axes[0].set_title(f'{stock_code} 价格走势与均线交叉信号')
+-    axes[0].legend()
+-    axes[0].grid(True, alpha=0.3)
+-    
+-    # 绘制累计收益
+-    axes[1].plot(returns_data['cumulative_returns'].index, 
+-                returns_data['cumulative_returns'].values, 
+-                label='累计收益', color='blue')
+-    axes[1].set_title('策略累计收益')
+-    axes[1].legend()
+-    axes[1].grid(True, alpha=0.3)
+-    
+-    # 绘制资金曲线
+-    axes[2].plot(returns_data['capital_curve'].index, 
+-                returns_data['capital_curve'].values, 
+-                label='资金曲线', color='green')
+-    axes[2].set_title('资金曲线')
+-    axes[2].legend()
+-    axes[2].grid(True, alpha=0.3)
+-    
+-    plt.tight_layout()
+-    plt.savefig('ma_cross_strategy_results.png', dpi=300, bbox_inches='tight')
+-    plt.show()
+-
+-
+-def main():
+-    """
+-    主函数
+-    """
+-    print("开始运行均线交叉策略...")
+-    
+-    # 初始化qlib
+-    if not init_qlib():
+-        return
+-    
+-    # 策略参数
+-    start_date = "2020-01-01"
+-    end_date = "2023-12-31"
+-    short_window = 5
+-    long_window = 20
+-    initial_capital = 100000
+-    
+-    # 获取股票列表
+-    try:
+-        instruments = D.list_instruments(instruments="csi300", start_time=start_date, end_time=end_date)
+-        print(f"获取到 {len(instruments)} 只股票")
+-        
+-        # 选择前5只股票进行演示
+-        demo_instruments = instruments[:5]
+-        print(f"选择演示股票: {demo_instruments}")
+-        
+-    except Exception as e:
+-        print(f"获取股票列表失败: {e}")
+-        # 使用默认股票列表
+-        demo_instruments = ['000001.SZ', '000002.SZ', '000858.SZ', '002415.SZ', '600036.SH']
+-        print(f"使用默认股票列表: {demo_instruments}")
+-    
+-    # 获取价格数据
+-    data = get_stock_data(demo_instruments, start_date, end_date)
+-    
+-    if data is None:
+-        print("无法获取数据，程序退出")
+-        return
+-    
+-    print(f"获取到价格数据，形状: {data.shape}")
+-    
+-    # 计算均线信号
+-    signals = calculate_ma_signals(data, short_window, long_window)
+-    
+-    # 计算收益
+-    returns_data = calculate_returns(data, signals, initial_capital)
+-    
+-    # 分析策略
+-    analyze_strategy(signals, returns_data)
+-    
+-    # 保存结果
+-    signals.to_csv("ma_cross_signals.csv")
+-    returns_data['cumulative_returns'].to_csv("ma_cross_cumulative_returns.csv")
+-    returns_data['capital_curve'].to_csv("ma_cross_capital_curve.csv")
+-    
+-    print("\n结果已保存到CSV文件:")
+-    print("- ma_cross_signals.csv: 买卖信号")
+-    print("- ma_cross_cumulative_returns.csv: 累计收益")
+-    print("- ma_cross_capital_curve.csv: 资金曲线")
+-    
+-    # 绘制图表（选择第一只股票）
+-    if len(demo_instruments) > 0:
+-        try:
+-            plot_results(data, signals, returns_data, demo_instruments[0])
+-            print("图表已保存为 ma_cross_strategy_results.png")
+-        except Exception as e:
+-            print(f"绘制图表失败: {e}")
+-    
+-    print("\n策略回测完成！")
+-
+-
+-if __name__ == "__main__":
+-    main() 
+\ No newline at end of file
+diff --git a/test/two_ema_stragety.py b/test/two_ema_stragety.py
+index a72e7e8..a9890c7 100644
+--- a/test/two_ema_stragety.py
++++ b/test/two_ema_stragety.py
+@@ -1,2 +1,98 @@
+-from qlib.contrib.strategy import 
+-from qlib.backtest import backtest
+\ No newline at end of file
++import pandas as pd
++
++from abc import ABC
++from typing import Dict, List, Text, Tuple, Union
++from qlib.data.dataset import Dataset
++from qlib.model.base import BaseModel
++from qlib.backtest.signal import Signal, create_signal_from
++from qlib.strategy.base import BaseStrategy
++from qlib.backtest.decision import Order, OrderDir, OrderHelper, TradeDecisionWO
++# from qlib.strategy import 
++# from qlib.backtest import backtest
++
++class InnerStrategy(BaseStrategy):
++    """
++    Inner strategy for order execution:
++    - Buy: if price < 200, buy all cash; else buy 200,000 worth.
++    - Sell: if price > 200, sell all; else sell half.
++    """
++    STOCK_CODE = "000858.SZ"
++
++    def generate_trade_decision(self, execute_result: list = None, action: str = None, amount: float = None):
++        # action: 'buy' or 'sell', amount: suggested amount (shares) from outer
++        position = self.trade_position
++        trade_step = self.trade_calendar.get_trade_step()
++        trade_start_time, trade_end_time = self.trade_calendar.get_step_time(trade_step)
++        order_helper = self.trade_exchange.get_order_helper()
++        orders = []
++        price = self.trade_exchange.get_deal_price(self.STOCK_CODE, trade_start_time, trade_end_time)
++        if action == 'buy':
++            cash = position.get_cash()
++            if price <= 0:
++                return TradeDecisionWO([], self)
++            if price < 200:
++                buy_amount = cash // price
++            else:
++                buy_amount = min(cash // price, 200000 // price)
++            buy_amount = int(buy_amount)
++            if buy_amount > 0:
++                order = order_helper.create(
++                    code=self.STOCK_CODE,
++                    amount=buy_amount,
++                    direction=OrderDir.BUY,
++                    start_time=trade_start_time,
++                    end_time=trade_end_time,
++                )
++                orders.append(order)
++        elif action == 'sell':
++            held_amount = position.get_stock_amount(self.STOCK_CODE)
++            if held_amount <= 0 or price <= 0:
++                return TradeDecisionWO([], self)
++            if price > 200:
++                sell_amount = held_amount
++            else:
++                sell_amount = held_amount // 2
++            sell_amount = int(sell_amount)
++            if sell_amount > 0:
++                order = order_helper.create(
++                    code=self.STOCK_CODE,
++                    amount=sell_amount,
++                    direction=OrderDir.SELL,
++                    start_time=trade_start_time,
++                    end_time=trade_end_time,
++                )
++                orders.append(order)
++        return TradeDecisionWO(orders, self)
++
++class OuterStrategy(BaseStrategy):
++    """
++    Outer strategy:
++    - If not holding Wuliangye, issues a buy order via inner strategy.
++    - If holding, checks if held for 25 days, if so, issues a sell order via inner strategy.
++    - Otherwise, holds.
++    """
++    STOCK_CODE = "000858.SZ"
++    HOLD_DAYS = 25
++    BAR = "day"
++
++    def __init__(self, *args, **kwargs):
++        super().__init__(*args, **kwargs)
++        self.inner_strategy = InnerStrategy()
++
++    def generate_trade_decision(self, execute_result: list = None):
++        position = self.trade_position
++        stock_list = position.get_stock_list()
++        trade_step = self.trade_calendar.get_trade_step()
++        trade_start_time, trade_end_time = self.trade_calendar.get_step_time(trade_step)
++        # Pass infra to inner strategy
++        self.inner_strategy.reset(level_infra=self.level_infra, common_infra=self.common_infra)
++        if self.STOCK_CODE in stock_list:
++            hold_days = position.get_stock_count(self.STOCK_CODE, self.BAR)
++            if hold_days >= self.HOLD_DAYS:
++                # Sell via inner strategy
++                return self.inner_strategy.generate_trade_decision(action='sell')
++        else:
++            # Buy via inner strategy
++            return self.inner_strategy.generate_trade_decision(action='buy')
++        # Otherwise, hold
++        return TradeDecisionWO([], self)
+\ No newline at end of file
diff --git a/mlruns/812028854715931404/0012f3eec07d4e4980b4ec205853584d/artifacts/code_status.txt b/mlruns/812028854715931404/0012f3eec07d4e4980b4ec205853584d/artifacts/code_status.txt
new file mode 100644
index 0000000..35a35fa
--- /dev/null
+++ b/mlruns/812028854715931404/0012f3eec07d4e4980b4ec205853584d/artifacts/code_status.txt
@@ -0,0 +1,22 @@
+On branch main
+Your branch is up to date with 'origin/main'.
+
+Changes not staged for commit:
+  (use "git add/rm <file>..." to update what will be committed)
+  (use "git restore <file>..." to discard changes in working directory)
+	deleted:    test/README_MA_Strategy.md
+	modified:   test/damo1.py
+	deleted:    test/ma_cross_strategy.py
+	deleted:    test/ma_cross_strategy_improved.py
+	deleted:    test/ma_strategy_demo.py
+	deleted:    test/simple_ma_strategy.py
+	modified:   test/two_ema_stragety.py
+
+Untracked files:
+  (use "git add <file>..." to include in what will be committed)
+	mlruns/
+	test/__pycache__/
+	test/buy_and_hold.py
+	test/workflow_by_code.py
+
+no changes added to commit (use "git add" and/or "git commit -a")
diff --git a/mlruns/812028854715931404/0012f3eec07d4e4980b4ec205853584d/meta.yaml b/mlruns/812028854715931404/0012f3eec07d4e4980b4ec205853584d/meta.yaml
new file mode 100644
index 0000000..657d779
--- /dev/null
+++ b/mlruns/812028854715931404/0012f3eec07d4e4980b4ec205853584d/meta.yaml
@@ -0,0 +1,14 @@
+artifact_uri: file:D:\project\python\tradenote\mlruns/812028854715931404/0012f3eec07d4e4980b4ec205853584d/artifacts
+end_time: 1750317638523
+entry_point_name: ''
+experiment_id: '812028854715931404'
+lifecycle_stage: active
+run_id: 0012f3eec07d4e4980b4ec205853584d
+run_name: mlflow_recorder
+source_name: ''
+source_type: 4
+source_version: ''
+start_time: 1750317638318
+status: 3
+tags: []
+user_id: abulimity
diff --git a/mlruns/812028854715931404/0012f3eec07d4e4980b4ec205853584d/params/cmd-sys.argv b/mlruns/812028854715931404/0012f3eec07d4e4980b4ec205853584d/params/cmd-sys.argv
new file mode 100644
index 0000000..db800eb
--- /dev/null
+++ b/mlruns/812028854715931404/0012f3eec07d4e4980b4ec205853584d/params/cmd-sys.argv
@@ -0,0 +1 @@
+D:\project\python\tradenote\test\workflow_by_code.py
\ No newline at end of file
diff --git a/mlruns/812028854715931404/0012f3eec07d4e4980b4ec205853584d/tags/mlflow.runName b/mlruns/812028854715931404/0012f3eec07d4e4980b4ec205853584d/tags/mlflow.runName
new file mode 100644
index 0000000..25487e4
--- /dev/null
+++ b/mlruns/812028854715931404/0012f3eec07d4e4980b4ec205853584d/tags/mlflow.runName
@@ -0,0 +1 @@
+mlflow_recorder
\ No newline at end of file
diff --git a/mlruns/812028854715931404/0012f3eec07d4e4980b4ec205853584d/tags/mlflow.source.git.commit b/mlruns/812028854715931404/0012f3eec07d4e4980b4ec205853584d/tags/mlflow.source.git.commit
new file mode 100644
index 0000000..288ce21
--- /dev/null
+++ b/mlruns/812028854715931404/0012f3eec07d4e4980b4ec205853584d/tags/mlflow.source.git.commit
@@ -0,0 +1 @@
+0daea9b5bbb40120a1bc07c702d171abc1f219c7
\ No newline at end of file
diff --git a/mlruns/812028854715931404/0012f3eec07d4e4980b4ec205853584d/tags/mlflow.source.name b/mlruns/812028854715931404/0012f3eec07d4e4980b4ec205853584d/tags/mlflow.source.name
new file mode 100644
index 0000000..db800eb
--- /dev/null
+++ b/mlruns/812028854715931404/0012f3eec07d4e4980b4ec205853584d/tags/mlflow.source.name
@@ -0,0 +1 @@
+D:\project\python\tradenote\test\workflow_by_code.py
\ No newline at end of file
diff --git a/mlruns/812028854715931404/0012f3eec07d4e4980b4ec205853584d/tags/mlflow.source.type b/mlruns/812028854715931404/0012f3eec07d4e4980b4ec205853584d/tags/mlflow.source.type
new file mode 100644
index 0000000..0c2c1fe
--- /dev/null
+++ b/mlruns/812028854715931404/0012f3eec07d4e4980b4ec205853584d/tags/mlflow.source.type
@@ -0,0 +1 @@
+LOCAL
\ No newline at end of file
diff --git a/mlruns/812028854715931404/0012f3eec07d4e4980b4ec205853584d/tags/mlflow.user b/mlruns/812028854715931404/0012f3eec07d4e4980b4ec205853584d/tags/mlflow.user
new file mode 100644
index 0000000..b9cec6f
--- /dev/null
+++ b/mlruns/812028854715931404/0012f3eec07d4e4980b4ec205853584d/tags/mlflow.user
@@ -0,0 +1 @@
+abulimity
\ No newline at end of file
diff --git a/mlruns/812028854715931404/00589ed0f1f74dc3a1e2302f49a29e32/artifacts/code_cached.txt b/mlruns/812028854715931404/00589ed0f1f74dc3a1e2302f49a29e32/artifacts/code_cached.txt
new file mode 100644
index 0000000..e69de29
diff --git a/mlruns/812028854715931404/00589ed0f1f74dc3a1e2302f49a29e32/artifacts/code_diff.txt b/mlruns/812028854715931404/00589ed0f1f74dc3a1e2302f49a29e32/artifacts/code_diff.txt
new file mode 100644
index 0000000..928524e
--- /dev/null
+++ b/mlruns/812028854715931404/00589ed0f1f74dc3a1e2302f49a29e32/artifacts/code_diff.txt
@@ -0,0 +1,1638 @@
+diff --git a/github/examples/benchmarks/LightGBM/workflow_config_lightgbm_Alpha1582.yaml b/github/examples/benchmarks/LightGBM/workflow_config_lightgbm_Alpha1582.yaml
+index 8b4e7bf..7a5eee7 100644
+--- a/github/examples/benchmarks/LightGBM/workflow_config_lightgbm_Alpha1582.yaml
++++ b/github/examples/benchmarks/LightGBM/workflow_config_lightgbm_Alpha1582.yaml
+@@ -1,5 +1,5 @@
+ qlib_init:
+-    provider_uri: "D:/project/tradenote/qlib_data/cn_data"
++    provider_uri: "D:/sync/qlib/qlib_data/cn_data"
+     region: cn
+ market: &market csi300
+ benchmark: &benchmark SH000300
+diff --git a/test/README_MA_Strategy.md b/test/README_MA_Strategy.md
+deleted file mode 100644
+index 5facaf7..0000000
+--- a/test/README_MA_Strategy.md
++++ /dev/null
+@@ -1,197 +0,0 @@
+-# 均线交叉策略 (Moving Average Crossover Strategy)
+-
+-## 策略概述
+-
+-这是一个基于qlib框架实现的均线交叉策略，核心逻辑是：
+-- **金叉买入**：短期均线上穿长期均线时买入
+-- **死叉卖出**：短期均线下穿长期均线时卖出
+-
+-## 文件说明
+-
+-### 1. `ma_cross_strategy.py`
+-完整的策略实现，包含：
+-- `MACrossStrategy` 类：继承自qlib的TopkDropoutStrategy
+-- 完整的回测框架
+-- 结果分析和保存
+-
+-### 2. `ma_cross_strategy_improved.py`
+-改进版本，包含：
+-- 更完善的数据获取逻辑
+-- 错误处理机制
+-- 简化版回测功能
+-
+-### 3. `simple_ma_strategy.py` ⭐ **推荐使用**
+-简单实用的版本，包含：
+-- 清晰的数据获取和处理
+-- 均线信号计算
+-- 收益计算和分析
+-- 可视化图表生成
+-- 结果保存功能
+-
+-## 使用方法
+-
+-### 环境准备
+-
+-1. 确保已安装qlib：
+-```bash
+-pip install pyqlib
+-```
+-
+-2. 下载qlib数据（如果还没有）：
+-```bash
+-# 下载中国股票数据
+-python -m qlib.data.dump_bin --csv_path ~/.qlib/qlib_data/cn_data --include_fields close,open,high,low,volume
+-```
+-
+-### 运行策略
+-
+-#### 方法1：运行简单版本（推荐）
+-```bash
+-cd test
+-python simple_ma_strategy.py
+-```
+-
+-#### 方法2：运行完整版本
+-```bash
+-cd test
+-python ma_cross_strategy.py
+-```
+-
+-#### 方法3：运行改进版本
+-```bash
+-cd test
+-python ma_cross_strategy_improved.py
+-```
+-
+-## 策略参数
+-
+-可以在代码中修改以下参数：
+-
+-```python
+-# 均线周期
+-short_window = 5    # 短期均线周期
+-long_window = 20    # 长期均线周期
+-
+-# 回测时间
+-start_date = "2020-01-01"
+-end_date = "2023-12-31"
+-
+-# 初始资金
+-initial_capital = 100000
+-
+-# 股票池
+-instruments = "csi300"  # 沪深300成分股
+-```
+-
+-## 输出结果
+-
+-运行策略后会生成以下文件：
+-
+-1. **CSV文件**：
+-   - `ma_cross_signals.csv`：买卖信号数据
+-   - `ma_cross_cumulative_returns.csv`：累计收益数据
+-   - `ma_cross_capital_curve.csv`：资金曲线数据
+-
+-2. **图表文件**：
+-   - `ma_cross_strategy_results.png`：策略结果可视化图表
+-
+-3. **控制台输出**：
+-   - 策略分析结果
+-   - 收益统计
+-   - 风险指标
+-
+-## 策略分析指标
+-
+-### 收益指标
+-- 总收益率
+-- 年化收益率
+-- 最终资金
+-
+-### 风险指标
+-- 年化波动率
+-- 夏普比率
+-- 胜率
+-- 最大回撤
+-
+-### 交易统计
+-- 买入信号数量
+-- 卖出信号数量
+-- 总交易次数
+-
+-## 策略逻辑详解
+-
+-### 1. 均线计算
+-```python
+-# 计算短期和长期均线
+-short_ma = price_data.rolling(window=short_window).mean()
+-long_ma = price_data.rolling(window=long_window).mean()
+-```
+-
+-### 2. 交叉信号判断
+-```python
+-# 计算均线差值
+-diff = short_ma - long_ma
+-
+-# 金叉：短期均线从下方穿越长期均线
+-if diff.iloc[i-1] < 0 and diff.iloc[i] > 0:
+-    signal = 1  # 买入信号
+-
+-# 死叉：短期均线从上方穿越长期均线
+-elif diff.iloc[i-1] > 0 and diff.iloc[i] < 0:
+-    signal = -1  # 卖出信号
+-```
+-
+-### 3. 收益计算
+-```python
+-# 策略收益（简化处理）
+-strategy_returns = signals * 0.01
+-
+-# 累计收益
+-cumulative_returns = strategy_returns.sum(axis=1).cumsum()
+-```
+-
+-## 注意事项
+-
+-1. **数据依赖**：确保qlib数据已正确下载和配置
+-2. **参数调优**：可以根据不同市场环境调整均线周期
+-3. **风险控制**：实际交易中需要加入止损和仓位管理
+-4. **交易成本**：当前版本未考虑交易费用，实际应用需要考虑
+-
+-## 扩展功能
+-
+-可以基于此策略进行以下扩展：
+-
+-1. **多均线策略**：使用多条均线进行更复杂的信号判断
+-2. **量价配合**：结合成交量指标优化信号
+-3. **止损机制**：添加动态止损策略
+-4. **仓位管理**：根据信号强度调整仓位大小
+-5. **多股票组合**：构建股票组合分散风险
+-
+-## 常见问题
+-
+-### Q: 如何修改股票池？
+-A: 在代码中修改 `instruments` 参数，例如：
+-```python
+-instruments = "csi500"  # 中证500
+-instruments = ["000001.SZ", "000002.SZ"]  # 指定股票列表
+-```
+-
+-### Q: 如何调整均线周期？
+-A: 修改 `short_window` 和 `long_window` 参数：
+-```python
+-short_window = 10  # 10日均线
+-long_window = 30   # 30日均线
+-```
+-
+-### Q: 如何查看详细的交易记录？
+-A: 查看生成的 `ma_cross_signals.csv` 文件，其中包含每日的买卖信号。
+-
+-## 联系方式
+-
+-如有问题或建议，请通过以下方式联系：
+-- 提交Issue到项目仓库
+-- 发送邮件到项目维护者
+-
+----
+-
+-**免责声明**：本策略仅供学习和研究使用，不构成投资建议。实际投资请谨慎决策，并承担相应风险。 
+\ No newline at end of file
+diff --git a/test/damo1.py b/test/damo1.py
+index 03102e1..afa2886 100644
+--- a/test/damo1.py
++++ b/test/damo1.py
+@@ -1,9 +1,35 @@
+-# python scripts/get_data.py qlib_data --target_dir ../qlib_data/cn_data --region cn
+-
+ import qlib
+-# region in [REG_CN, REG_US]
+-from qlib.constant import REG_CN
+-provider_uri = "D:/project/tradenote/qlib_data/cn_data"  # target_dir
+-qlib.init(provider_uri=provider_uri, region=REG_CN)
++from qlib.data import D
++
++# 初始化 Qlib
++qlib.init(provider_uri="D:/sync/qlib/qlib_data/cn_data", region="cn")
++
++# 检查目标股票和基准
++stock_code = "SZ000858"  # 你的BuyHold策略用的股票代码
++benchmark = "SH000300"
++
++print("--- 检查可用股票列表（前10只） ---")
++print(list(D.instruments(market="all"))[:10])
++
++print("--- 检查交易日（2017-01-01 ~ 2020-08-01，前10天） ---")
++print(D.calendar(start_time="2017-01-01", end_time="2020-08-01")[:10])
++
++print(f"--- 检查目标股票 {stock_code} 是否在股票池 ---")
++print(stock_code in D.instruments(market="all"))
++
++print(f"--- 检查基准 {benchmark} 是否在股票池 ---")
++print(benchmark in D.instruments(market="all"))
++
++print(f"--- 检查目标股票 {stock_code} 的行情数据（前5行） ---")
++try:
++    df = D.features([stock_code], ["$close", "$open", "$high", "$low", "$volume"], start_time="2017-01-01", end_time="2020-08-01")
++    print(df.head())
++except Exception as e:
++    print(f"获取行情数据失败: {e}")
+ 
+-# qrun benchmarks/LightGBM/workflow_config_lightgbm_Alpha1582.yaml
++print(f"--- 检查基准 {benchmark} 的行情数据（前5行） ---")
++try:
++    df_bench = D.features([benchmark], ["$close"], start_time="2017-01-01", end_time="2020-08-01")
++    print(df_bench.head())
++except Exception as e:
++    print(f"获取基准行情数据失败: {e}")
+diff --git a/test/demo2.ipynb b/test/demo2.ipynb
+index 66a0215..842a49e 100644
+--- a/test/demo2.ipynb
++++ b/test/demo2.ipynb
+@@ -2,7 +2,7 @@
+  "cells": [
+   {
+    "cell_type": "code",
+-   "execution_count": 4,
++   "execution_count": 12,
+    "id": "6acb4a77",
+    "metadata": {},
+    "outputs": [
+@@ -10,39 +10,205 @@
+      "name": "stderr",
+      "output_type": "stream",
+      "text": [
+-      "[5344:MainThread](2025-06-18 14:41:03,895) INFO - qlib.Initialization - [config.py:420] - default_conf: client.\n",
+-      "[5344:MainThread](2025-06-18 14:41:03,900) INFO - qlib.Initialization - [__init__.py:74] - qlib successfully initialized based on client settings.\n",
+-      "[5344:MainThread](2025-06-18 14:41:03,903) INFO - qlib.Initialization - [__init__.py:76] - data_path={'__DEFAULT_FREQ': WindowsPath('D:/sync/qlib/qlib_data/cn_data')}\n"
++      "[13736:MainThread](2025-06-19 15:30:19,504) INFO - qlib.Initialization - [config.py:420] - default_conf: client.\n",
++      "[13736:MainThread](2025-06-19 15:30:19,506) INFO - qlib.Initialization - [__init__.py:74] - qlib successfully initialized based on client settings.\n",
++      "[13736:MainThread](2025-06-19 15:30:19,508) INFO - qlib.Initialization - [__init__.py:76] - data_path={'__DEFAULT_FREQ': WindowsPath('D:/sync/qlib/qlib_data/cn_data')}\n"
+      ]
+     }
+    ],
+    "source": [
+     "import qlib\n",
+-    "qlib.init(provider_uri=\"D:/sync/qlib/qlib_data/cn_data\", region=\"cn\")"
++    "qlib.init(provider_uri=r\"D:\\sync\\qlib\\qlib_data\\cn_data\", region=\"cn\")"
+    ]
+   },
+   {
+    "cell_type": "code",
+-   "execution_count": 12,
++   "execution_count": 14,
+    "id": "295df9af",
+    "metadata": {},
+    "outputs": [
+     {
+      "data": {
+       "text/plain": [
+-       "array([Timestamp('2020-09-21 00:00:00'), Timestamp('2020-09-22 00:00:00'),\n",
+-       "       Timestamp('2020-09-23 00:00:00'), Timestamp('2020-09-24 00:00:00'),\n",
+-       "       Timestamp('2020-09-25 00:00:00')], dtype=object)"
++       "array([Timestamp('2017-01-03 00:00:00'), Timestamp('2017-01-04 00:00:00'),\n",
++       "       Timestamp('2017-01-05 00:00:00'), Timestamp('2017-01-06 00:00:00'),\n",
++       "       Timestamp('2017-01-09 00:00:00')], dtype=object)"
+       ]
+      },
+-     "execution_count": 12,
++     "execution_count": 14,
+      "metadata": {},
+      "output_type": "execute_result"
+     }
+    ],
+    "source": [
+     "from qlib.data import D\n",
+-    "D.calendar(start_time='2020-09-21', end_time='2020-10-30', freq='day')"
++    "D.calendar(start_time=\"2017-01-01\", end_time=\"2020-08-01\",freq=\"day\")[:5]"
++   ]
++  },
++  {
++   "cell_type": "code",
++   "execution_count": 24,
++   "id": "da009afa",
++   "metadata": {},
++   "outputs": [
++    {
++     "data": {
++      "text/html": [
++       "<div>\n",
++       "<style scoped>\n",
++       "    .dataframe tbody tr th:only-of-type {\n",
++       "        vertical-align: middle;\n",
++       "    }\n",
++       "\n",
++       "    .dataframe tbody tr th {\n",
++       "        vertical-align: top;\n",
++       "    }\n",
++       "\n",
++       "    .dataframe thead th {\n",
++       "        text-align: right;\n",
++       "    }\n",
++       "</style>\n",
++       "<table border=\"1\" class=\"dataframe\">\n",
++       "  <thead>\n",
++       "    <tr style=\"text-align: right;\">\n",
++       "      <th></th>\n",
++       "      <th></th>\n",
++       "      <th>$close</th>\n",
++       "      <th>$open</th>\n",
++       "      <th>$high</th>\n",
++       "      <th>$low</th>\n",
++       "      <th>$volume</th>\n",
++       "    </tr>\n",
++       "    <tr>\n",
++       "      <th>instrument</th>\n",
++       "      <th>datetime</th>\n",
++       "      <th></th>\n",
++       "      <th></th>\n",
++       "      <th></th>\n",
++       "      <th></th>\n",
++       "      <th></th>\n",
++       "    </tr>\n",
++       "  </thead>\n",
++       "  <tbody>\n",
++       "    <tr>\n",
++       "      <th rowspan=\"11\" valign=\"top\">SZ000858</th>\n",
++       "      <th>2017-01-03</th>\n",
++       "      <td>11.301954</td>\n",
++       "      <td>11.243259</td>\n",
++       "      <td>11.373693</td>\n",
++       "      <td>11.184565</td>\n",
++       "      <td>47640796.0</td>\n",
++       "    </tr>\n",
++       "    <tr>\n",
++       "      <th>2017-01-04</th>\n",
++       "      <td>11.706295</td>\n",
++       "      <td>11.301954</td>\n",
++       "      <td>11.722599</td>\n",
++       "      <td>11.266086</td>\n",
++       "      <td>141233984.0</td>\n",
++       "    </tr>\n",
++       "    <tr>\n",
++       "      <th>2017-01-05</th>\n",
++       "      <td>11.716078</td>\n",
++       "      <td>11.748685</td>\n",
++       "      <td>11.817163</td>\n",
++       "      <td>11.641079</td>\n",
++       "      <td>79170360.0</td>\n",
++       "    </tr>\n",
++       "    <tr>\n",
++       "      <th>2017-01-06</th>\n",
++       "      <td>11.771510</td>\n",
++       "      <td>11.716077</td>\n",
++       "      <td>11.934550</td>\n",
++       "      <td>11.660643</td>\n",
++       "      <td>103201592.0</td>\n",
++       "    </tr>\n",
++       "    <tr>\n",
++       "      <th>2017-01-09</th>\n",
++       "      <td>11.885638</td>\n",
++       "      <td>11.738902</td>\n",
++       "      <td>11.999766</td>\n",
++       "      <td>11.716077</td>\n",
++       "      <td>81857808.0</td>\n",
++       "    </tr>\n",
++       "    <tr>\n",
++       "      <th>...</th>\n",
++       "      <td>...</td>\n",
++       "      <td>...</td>\n",
++       "      <td>...</td>\n",
++       "      <td>...</td>\n",
++       "      <td>...</td>\n",
++       "    </tr>\n",
++       "    <tr>\n",
++       "      <th>2020-07-27</th>\n",
++       "      <td>71.358727</td>\n",
++       "      <td>71.110489</td>\n",
++       "      <td>72.302719</td>\n",
++       "      <td>70.418228</td>\n",
++       "      <td>69948368.0</td>\n",
++       "    </tr>\n",
++       "    <tr>\n",
++       "      <th>2020-07-28</th>\n",
++       "      <td>74.816528</td>\n",
++       "      <td>71.984558</td>\n",
++       "      <td>75.847931</td>\n",
++       "      <td>71.558014</td>\n",
++       "      <td>108913296.0</td>\n",
++       "    </tr>\n",
++       "    <tr>\n",
++       "      <th>2020-07-29</th>\n",
++       "      <td>75.173149</td>\n",
++       "      <td>74.942398</td>\n",
++       "      <td>75.337471</td>\n",
++       "      <td>73.075386</td>\n",
++       "      <td>85012816.0</td>\n",
++       "    </tr>\n",
++       "    <tr>\n",
++       "      <th>2020-07-30</th>\n",
++       "      <td>75.704582</td>\n",
++       "      <td>74.820023</td>\n",
++       "      <td>76.236015</td>\n",
++       "      <td>74.470398</td>\n",
++       "      <td>71618128.0</td>\n",
++       "    </tr>\n",
++       "    <tr>\n",
++       "      <th>2020-07-31</th>\n",
++       "      <td>76.054207</td>\n",
++       "      <td>75.697586</td>\n",
++       "      <td>77.270905</td>\n",
++       "      <td>74.917923</td>\n",
++       "      <td>74252152.0</td>\n",
++       "    </tr>\n",
++       "  </tbody>\n",
++       "</table>\n",
++       "<p>871 rows × 5 columns</p>\n",
++       "</div>"
++      ],
++      "text/plain": [
++       "                          $close      $open      $high       $low      $volume\n",
++       "instrument datetime                                                           \n",
++       "SZ000858   2017-01-03  11.301954  11.243259  11.373693  11.184565   47640796.0\n",
++       "           2017-01-04  11.706295  11.301954  11.722599  11.266086  141233984.0\n",
++       "           2017-01-05  11.716078  11.748685  11.817163  11.641079   79170360.0\n",
++       "           2017-01-06  11.771510  11.716077  11.934550  11.660643  103201592.0\n",
++       "           2017-01-09  11.885638  11.738902  11.999766  11.716077   81857808.0\n",
++       "...                          ...        ...        ...        ...          ...\n",
++       "           2020-07-27  71.358727  71.110489  72.302719  70.418228   69948368.0\n",
++       "           2020-07-28  74.816528  71.984558  75.847931  71.558014  108913296.0\n",
++       "           2020-07-29  75.173149  74.942398  75.337471  73.075386   85012816.0\n",
++       "           2020-07-30  75.704582  74.820023  76.236015  74.470398   71618128.0\n",
++       "           2020-07-31  76.054207  75.697586  77.270905  74.917923   74252152.0\n",
++       "\n",
++       "[871 rows x 5 columns]"
++      ]
++     },
++     "execution_count": 24,
++     "metadata": {},
++     "output_type": "execute_result"
++    }
++   ],
++   "source": [
++    "D.features([\"SZ000858\"], [\"$close\", \"$open\", \"$high\", \"$low\", \"$volume\"], start_time=\"2017-01-01\", end_time=\"2020-08-01\")"
+    ]
+   }
+  ],
+diff --git a/test/ma_cross_strategy.py b/test/ma_cross_strategy.py
+deleted file mode 100644
+index 719d849..0000000
+--- a/test/ma_cross_strategy.py
++++ /dev/null
+@@ -1,274 +0,0 @@
+-"""
+-均线交叉策略：金叉买入，死叉卖出
+-使用qlib框架实现
+-"""
+-
+-import qlib
+-from qlib.constant import REG_CN
+-from qlib.utils import init_instance_by_config
+-from qlib.workflow import R
+-from qlib.workflow.record_temp import SignalRecord, PortAnaRecord
+-from qlib.contrib.evaluate import backtest_daily
+-from qlib.contrib.strategy import TopkDropoutStrategy
+-import pandas as pd
+-import numpy as np
+-from typing import Dict, List, Tuple
+-
+-
+-class MACrossStrategy(TopkDropoutStrategy):
+-    """
+-    均线交叉策略
+-    金叉（短期均线上穿长期均线）买入
+-    死叉（短期均线下穿长期均线）卖出
+-    """
+-    
+-    def __init__(self, 
+-                 short_window: int = 5,
+-                 long_window: int = 20,
+-                 topk: int = 50,
+-                 n_drop: int = 5,
+-                 **kwargs):
+-        """
+-        初始化策略参数
+-        
+-        Args:
+-            short_window: 短期均线周期
+-            long_window: 长期均线周期
+-            topk: 选择前k只股票
+-            n_drop: 剔除前n只股票
+-        """
+-        super().__init__(topk=topk, n_drop=n_drop, **kwargs)
+-        self.short_window = short_window
+-        self.long_window = long_window
+-        
+-    def generate_trade_decision(self, score: pd.Series, trade_step: int) -> pd.Series:
+-        """
+-        生成交易决策
+-        
+-        Args:
+-            score: 股票评分
+-            trade_step: 交易步骤
+-            
+-        Returns:
+-            交易决策，1表示买入，-1表示卖出，0表示持有
+-        """
+-        # 获取当前持仓
+-        current_pos = self.get_current_position()
+-        
+-        # 计算均线信号
+-        signal = self._calculate_ma_signal(score.index.tolist(), trade_step)
+-        
+-        # 生成交易决策
+-        decision = pd.Series(0, index=score.index)
+-        
+-        # 金叉买入信号
+-        buy_signal = signal == 1
+-        decision[buy_signal] = 1
+-        
+-        # 死叉卖出信号
+-        sell_signal = signal == -1
+-        decision[sell_signal] = -1
+-        
+-        return decision
+-    
+-    def _calculate_ma_signal(self, instruments: List[str], trade_step: int) -> pd.Series:
+-        """
+-        计算均线交叉信号
+-        
+-        Args:
+-            instruments: 股票代码列表
+-            trade_step: 交易步骤
+-            
+-        Returns:
+-            信号序列：1表示金叉买入，-1表示死叉卖出，0表示无信号
+-        """
+-        # 获取历史数据
+-        data = self._get_historical_data(instruments, trade_step)
+-        
+-        signals = pd.Series(0, index=instruments)
+-        
+-        for instrument in instruments:
+-            if instrument in data.index:
+-                # 计算短期和长期均线
+-                short_ma = data.loc[instrument].rolling(window=self.short_window).mean()
+-                long_ma = data.loc[instrument].rolling(window=self.long_window).mean()
+-                
+-                # 计算交叉信号
+-                if len(short_ma) >= 2 and len(long_ma) >= 2:
+-                    # 当前和前一个时间点的均线差值
+-                    current_diff = short_ma.iloc[-1] - long_ma.iloc[-1]
+-                    prev_diff = short_ma.iloc[-2] - long_ma.iloc[-2]
+-                    
+-                    # 金叉：短期均线从下方穿越长期均线
+-                    if prev_diff < 0 and current_diff > 0:
+-                        signals[instrument] = 1
+-                    # 死叉：短期均线从上方穿越长期均线
+-                    elif prev_diff > 0 and current_diff < 0:
+-                        signals[instrument] = -1
+-        
+-        return signals
+-    
+-    def _get_historical_data(self, instruments: List[str], trade_step: int) -> pd.DataFrame:
+-        """
+-        获取历史价格数据
+-        
+-        Args:
+-            instruments: 股票代码列表
+-            trade_step: 交易步骤
+-            
+-        Returns:
+-            历史价格数据
+-        """
+-        # 这里简化处理，实际应该从qlib数据源获取
+-        # 在实际应用中，您需要使用qlib的数据接口
+-        try:
+-            # 获取最近的数据用于计算均线
+-            # 这里使用模拟数据，实际应该从qlib获取
+-            dates = pd.date_range(end=pd.Timestamp.now(), periods=50, freq='D')
+-            data = pd.DataFrame(
+-                np.random.randn(len(dates), len(instruments)) * 0.02 + 1.0,
+-                index=dates,
+-                columns=instruments
+-            )
+-            return data
+-        except Exception as e:
+-            print(f"获取历史数据失败: {e}")
+-            return pd.DataFrame()
+-
+-
+-def create_ma_cross_strategy_config():
+-    """
+-    创建均线交叉策略配置
+-    """
+-    strategy_config = {
+-        "class": "MACrossStrategy",
+-        "module_path": "test.ma_cross_strategy",
+-        "kwargs": {
+-            "short_window": 5,
+-            "long_window": 20,
+-            "topk": 50,
+-            "n_drop": 5,
+-        }
+-    }
+-    
+-    return strategy_config
+-
+-
+-def run_backtest():
+-    """
+-    运行回测
+-    """
+-    # 初始化qlib
+-    qlib.init(provider_uri='~/.qlib/qlib_data/cn_data', region=REG_CN)
+-    
+-    # 策略配置
+-    strategy_config = create_ma_cross_strategy_config()
+-    
+-    # 回测配置
+-    backtest_config = {
+-        "start_time": "2020-01-01",
+-        "end_time": "2023-12-31",
+-        "benchmark": "SH000300",  # 沪深300作为基准
+-        "account": 100000000,     # 初始资金1亿
+-        "exchange_kwargs": {
+-            "freq": "day",
+-            "limit_threshold": 0.095,
+-            "deal_price": "close",
+-            "open_cost": 0.0005,
+-            "close_cost": 0.0015,
+-            "min_cost": 5,
+-        }
+-    }
+-    
+-    # 创建策略实例
+-    strategy = init_instance_by_config(strategy_config)
+-    
+-    # 运行回测
+-    with R.start(experiment_name="ma_cross_strategy"):
+-        # 记录信号
+-        sr = SignalRecord(model=strategy, dataset=None, recorder=R.get_recorder())
+-        sr.generate()
+-        
+-        # 记录投资组合分析
+-        par = PortAnaRecord(recorder=R.get_recorder(), config=backtest_config, strategy=strategy)
+-        par.generate()
+-        
+-        # 获取回测结果
+-        report_normal, positions_normal = backtest_daily(
+-            account=backtest_config["account"],
+-            benchmark=backtest_config["benchmark"],
+-            start_time=backtest_config["start_time"],
+-            end_time=backtest_config["end_time"],
+-            strategy=strategy,
+-            exchange_kwargs=backtest_config["exchange_kwargs"]
+-        )
+-        
+-        return report_normal, positions_normal
+-
+-
+-def analyze_results(report: pd.DataFrame, positions: pd.DataFrame):
+-    """
+-    分析回测结果
+-    
+-    Args:
+-        report: 回测报告
+-        positions: 持仓信息
+-    """
+-    print("=" * 50)
+-    print("均线交叉策略回测结果")
+-    print("=" * 50)
+-    
+-    # 基本统计信息
+-    print(f"总收益率: {report['return'].sum():.2%}")
+-    print(f"年化收益率: {report['return'].mean() * 252:.2%}")
+-    print(f"最大回撤: {report['drawdown'].min():.2%}")
+-    print(f"夏普比率: {report['sharpe'].iloc[-1]:.2f}")
+-    print(f"胜率: {(report['return'] > 0).mean():.2%}")
+-    
+-    # 风险指标
+-    volatility = report['return'].std() * np.sqrt(252)
+-    print(f"年化波动率: {volatility:.2%}")
+-    
+-    # 最大回撤期间
+-    max_drawdown_idx = report['drawdown'].idxmin()
+-    print(f"最大回撤发生时间: {max_drawdown_idx}")
+-    
+-    # 收益分布
+-    print("\n收益分布统计:")
+-    print(f"平均日收益: {report['return'].mean():.2%}")
+-    print(f"收益标准差: {report['return'].std():.2%}")
+-    print(f"最小日收益: {report['return'].min():.2%}")
+-    print(f"最大日收益: {report['return'].max():.2%}")
+-    
+-    # 交易统计
+-    if 'trade_count' in report.columns:
+-        print(f"\n总交易次数: {report['trade_count'].sum()}")
+-        print(f"平均每日交易次数: {report['trade_count'].mean():.1f}")
+-
+-
+-def main():
+-    """
+-    主函数
+-    """
+-    print("开始运行均线交叉策略回测...")
+-    
+-    try:
+-        # 运行回测
+-        report, positions = run_backtest()
+-        
+-        # 分析结果
+-        analyze_results(report, positions)
+-        
+-        # 保存结果
+-        report.to_csv("ma_cross_strategy_report.csv")
+-        positions.to_csv("ma_cross_strategy_positions.csv")
+-        
+-        print("\n回测完成！结果已保存到CSV文件。")
+-        
+-    except Exception as e:
+-        print(f"回测过程中出现错误: {e}")
+-        print("请确保已正确安装qlib并下载了相应的数据。")
+-
+-
+-if __name__ == "__main__":
+-    main() 
+\ No newline at end of file
+diff --git a/test/ma_cross_strategy_improved.py b/test/ma_cross_strategy_improved.py
+deleted file mode 100644
+index d166c68..0000000
+--- a/test/ma_cross_strategy_improved.py
++++ /dev/null
+@@ -1,443 +0,0 @@
+-"""
+-改进的均线交叉策略：金叉买入，死叉卖出
+-使用qlib框架实现，包含完整的数据获取和信号计算
+-"""
+-
+-import qlib
+-from qlib.constant import REG_CN
+-from qlib.utils import init_instance_by_config
+-from qlib.workflow import R
+-from qlib.workflow.record_temp import SignalRecord, PortAnaRecord
+-from qlib.contrib.evaluate import backtest_daily
+-from qlib.contrib.strategy import TopkDropoutStrategy
+-from qlib.data import D
+-from qlib.data.dataset import DatasetH
+-from qlib.data.dataset.handler import DataHandlerLP
+-import pandas as pd
+-import numpy as np
+-from typing import Dict, List, Tuple
+-import warnings
+-warnings.filterwarnings('ignore')
+-
+-
+-class MACrossStrategyImproved(TopkDropoutStrategy):
+-    """
+-    改进的均线交叉策略
+-    金叉（短期均线上穿长期均线）买入
+-    死叉（短期均线下穿长期均线）卖出
+-    """
+-    
+-    def __init__(self, 
+-                 short_window: int = 5,
+-                 long_window: int = 20,
+-                 topk: int = 50,
+-                 n_drop: int = 5,
+-                 universe: str = "csi300",
+-                 **kwargs):
+-        """
+-        初始化策略参数
+-        
+-        Args:
+-            short_window: 短期均线周期
+-            long_window: 长期均线周期
+-            topk: 选择前k只股票
+-            n_drop: 剔除前n只股票
+-            universe: 股票池
+-        """
+-        super().__init__(topk=topk, n_drop=n_drop, **kwargs)
+-        self.short_window = short_window
+-        self.long_window = long_window
+-        self.universe = universe
+-        self.instruments = None
+-        self.price_cache = {}
+-        
+-    def generate_trade_decision(self, score: pd.Series, trade_step: int) -> pd.Series:
+-        """
+-        生成交易决策
+-        
+-        Args:
+-            score: 股票评分
+-            trade_step: 交易步骤
+-            
+-        Returns:
+-            交易决策，1表示买入，-1表示卖出，0表示持有
+-        """
+-        # 获取当前持仓
+-        current_pos = self.get_current_position()
+-        
+-        # 计算均线信号
+-        signal = self._calculate_ma_signal(score.index.tolist(), trade_step)
+-        
+-        # 生成交易决策
+-        decision = pd.Series(0, index=score.index)
+-        
+-        # 金叉买入信号
+-        buy_signal = signal == 1
+-        decision[buy_signal] = 1
+-        
+-        # 死叉卖出信号
+-        sell_signal = signal == -1
+-        decision[sell_signal] = -1
+-        
+-        return decision
+-    
+-    def _calculate_ma_signal(self, instruments: List[str], trade_step: int) -> pd.Series:
+-        """
+-        计算均线交叉信号
+-        
+-        Args:
+-            instruments: 股票代码列表
+-            trade_step: 交易步骤
+-            
+-        Returns:
+-            信号序列：1表示金叉买入，-1表示死叉卖出，0表示无信号
+-        """
+-        signals = pd.Series(0, index=instruments)
+-        
+-        # 获取当前日期
+-        current_date = self._get_current_date(trade_step)
+-        
+-        for instrument in instruments:
+-            try:
+-                # 获取历史价格数据
+-                price_data = self._get_price_data(instrument, current_date)
+-                
+-                if price_data is not None and len(price_data) >= self.long_window:
+-                    # 计算短期和长期均线
+-                    short_ma = price_data['close'].rolling(window=self.short_window).mean()
+-                    long_ma = price_data['close'].rolling(window=self.long_window).mean()
+-                    
+-                    # 计算交叉信号
+-                    if len(short_ma) >= 2 and len(long_ma) >= 2:
+-                        # 当前和前一个时间点的均线差值
+-                        current_diff = short_ma.iloc[-1] - long_ma.iloc[-1]
+-                        prev_diff = short_ma.iloc[-2] - long_ma.iloc[-2]
+-                        
+-                        # 金叉：短期均线从下方穿越长期均线
+-                        if prev_diff < 0 and current_diff > 0:
+-                            signals[instrument] = 1
+-                        # 死叉：短期均线从上方穿越长期均线
+-                        elif prev_diff > 0 and current_diff < 0:
+-                            signals[instrument] = -1
+-                            
+-            except Exception as e:
+-                print(f"计算{instrument}均线信号时出错: {e}")
+-                continue
+-        
+-        return signals
+-    
+-    def _get_price_data(self, instrument: str, current_date: str) -> pd.DataFrame:
+-        """
+-        获取股票价格数据
+-        
+-        Args:
+-            instrument: 股票代码
+-            current_date: 当前日期
+-            
+-        Returns:
+-            价格数据DataFrame
+-        """
+-        try:
+-            # 计算开始日期（获取足够的历史数据来计算均线）
+-            start_date = pd.Timestamp(current_date) - pd.Timedelta(days=self.long_window * 2)
+-            
+-            # 从qlib获取数据
+-            data = D.features(
+-                instruments=[instrument],
+-                start_time=start_date.strftime('%Y-%m-%d'),
+-                end_time=current_date,
+-                freq='day',
+-                fields=['$close', '$open', '$high', '$low', '$volume']
+-            )
+-            
+-            if data is not None and not data.empty:
+-                # 重命名列
+-                data.columns = ['close', 'open', 'high', 'low', 'volume']
+-                return data
+-            else:
+-                return None
+-                
+-        except Exception as e:
+-            print(f"获取{instrument}价格数据失败: {e}")
+-            return None
+-    
+-    def _get_current_date(self, trade_step: int) -> str:
+-        """
+-        根据交易步骤获取当前日期
+-        
+-        Args:
+-            trade_step: 交易步骤
+-            
+-        Returns:
+-            当前日期字符串
+-        """
+-        # 这里简化处理，实际应该从qlib的日历获取
+-        # 假设从2020-01-01开始，每个trade_step代表一天
+-        start_date = pd.Timestamp('2020-01-01')
+-        current_date = start_date + pd.Timedelta(days=trade_step)
+-        return current_date.strftime('%Y-%m-%d')
+-
+-
+-def create_dataset_config():
+-    """
+-    创建数据集配置
+-    """
+-    dataset_config = {
+-        "class": "DatasetH",
+-        "module_path": "qlib.data.dataset",
+-        "kwargs": {
+-            "handler": {
+-                "class": "DataHandlerLP",
+-                "module_path": "qlib.data.dataset.handler",
+-                "kwargs": {
+-                    "start_time": "2020-01-01",
+-                    "end_time": "2023-12-31",
+-                    "fit_start_time": "2020-01-01",
+-                    "fit_end_time": "2023-12-31",
+-                    "instruments": "csi300",
+-                    "infer_processors": [
+-                        {
+-                            "class": "RobustZScoreNorm",
+-                            "module_path": "qlib.data.dataset.processor",
+-                            "kwargs": {
+-                                "fields_group": "feature",
+-                                "clip_outlier": True,
+-                            },
+-                        },
+-                        {
+-                            "class": "Fillna",
+-                            "module_path": "qlib.data.dataset.processor",
+-                            "kwargs": {
+-                                "fields_group": "feature",
+-                            },
+-                        },
+-                    ],
+-                    "learn_processors": [
+-                        {
+-                            "class": "DropnaLabel",
+-                            "module_path": "qlib.data.dataset.processor",
+-                        },
+-                        {
+-                            "class": "CSRankNorm",
+-                            "module_path": "qlib.data.dataset.processor",
+-                            "kwargs": {
+-                                "fields_group": "label",
+-                            },
+-                        },
+-                    ],
+-                    "instruments": "csi300",
+-                },
+-            },
+-            "segments": {
+-                "train": ("2020-01-01", "2022-12-31"),
+-                "valid": ("2023-01-01", "2023-06-30"),
+-                "test": ("2023-07-01", "2023-12-31"),
+-            },
+-        },
+-    }
+-    
+-    return dataset_config
+-
+-
+-def create_ma_cross_strategy_config():
+-    """
+-    创建均线交叉策略配置
+-    """
+-    strategy_config = {
+-        "class": "MACrossStrategyImproved",
+-        "module_path": "test.ma_cross_strategy_improved",
+-        "kwargs": {
+-            "short_window": 5,
+-            "long_window": 20,
+-            "topk": 50,
+-            "n_drop": 5,
+-            "universe": "csi300",
+-        }
+-    }
+-    
+-    return strategy_config
+-
+-
+-def run_backtest():
+-    """
+-    运行回测
+-    """
+-    # 初始化qlib
+-    qlib.init(provider_uri='~/.qlib/qlib_data/cn_data', region=REG_CN)
+-    
+-    # 策略配置
+-    strategy_config = create_ma_cross_strategy_config()
+-    
+-    # 回测配置
+-    backtest_config = {
+-        "start_time": "2020-01-01",
+-        "end_time": "2023-12-31",
+-        "benchmark": "SH000300",  # 沪深300作为基准
+-        "account": 100000000,     # 初始资金1亿
+-        "exchange_kwargs": {
+-            "freq": "day",
+-            "limit_threshold": 0.095,
+-            "deal_price": "close",
+-            "open_cost": 0.0005,
+-            "close_cost": 0.0015,
+-            "min_cost": 5,
+-        }
+-    }
+-    
+-    # 创建策略实例
+-    strategy = init_instance_by_config(strategy_config)
+-    
+-    # 运行回测
+-    with R.start(experiment_name="ma_cross_strategy_improved"):
+-        # 记录信号
+-        sr = SignalRecord(model=strategy, dataset=None, recorder=R.get_recorder())
+-        sr.generate()
+-        
+-        # 记录投资组合分析
+-        par = PortAnaRecord(recorder=R.get_recorder(), config=backtest_config, strategy=strategy)
+-        par.generate()
+-        
+-        # 获取回测结果
+-        report_normal, positions_normal = backtest_daily(
+-            account=backtest_config["account"],
+-            benchmark=backtest_config["benchmark"],
+-            start_time=backtest_config["start_time"],
+-            end_time=backtest_config["end_time"],
+-            strategy=strategy,
+-            exchange_kwargs=backtest_config["exchange_kwargs"]
+-        )
+-        
+-        return report_normal, positions_normal
+-
+-
+-def analyze_results(report: pd.DataFrame, positions: pd.DataFrame):
+-    """
+-    分析回测结果
+-    
+-    Args:
+-        report: 回测报告
+-        positions: 持仓信息
+-    """
+-    print("=" * 50)
+-    print("均线交叉策略回测结果")
+-    print("=" * 50)
+-    
+-    # 基本统计信息
+-    print(f"总收益率: {report['return'].sum():.2%}")
+-    print(f"年化收益率: {report['return'].mean() * 252:.2%}")
+-    print(f"最大回撤: {report['drawdown'].min():.2%}")
+-    
+-    if 'sharpe' in report.columns:
+-        print(f"夏普比率: {report['sharpe'].iloc[-1]:.2f}")
+-    
+-    print(f"胜率: {(report['return'] > 0).mean():.2%}")
+-    
+-    # 风险指标
+-    volatility = report['return'].std() * np.sqrt(252)
+-    print(f"年化波动率: {volatility:.2%}")
+-    
+-    # 最大回撤期间
+-    max_drawdown_idx = report['drawdown'].idxmin()
+-    print(f"最大回撤发生时间: {max_drawdown_idx}")
+-    
+-    # 收益分布
+-    print("\n收益分布统计:")
+-    print(f"平均日收益: {report['return'].mean():.2%}")
+-    print(f"收益标准差: {report['return'].std():.2%}")
+-    print(f"最小日收益: {report['return'].min():.2%}")
+-    print(f"最大日收益: {report['return'].max():.2%}")
+-    
+-    # 交易统计
+-    if 'trade_count' in report.columns:
+-        print(f"\n总交易次数: {report['trade_count'].sum()}")
+-        print(f"平均每日交易次数: {report['trade_count'].mean():.1f}")
+-
+-
+-def create_simple_backtest():
+-    """
+-    创建简化版回测，用于演示
+-    """
+-    print("创建简化版均线交叉策略回测...")
+-    
+-    # 初始化qlib
+-    qlib.init(provider_uri='~/.qlib/qlib_data/cn_data', region=REG_CN)
+-    
+-    # 获取股票列表
+-    instruments = D.list_instruments(instruments="csi300", start_time="2020-01-01", end_time="2023-12-31")
+-    
+-    print(f"获取到 {len(instruments)} 只股票")
+-    
+-    # 选择前10只股票进行演示
+-    demo_instruments = instruments[:10]
+-    
+-    # 获取价格数据
+-    data = D.features(
+-        instruments=demo_instruments,
+-        start_time="2020-01-01",
+-        end_time="2023-12-31",
+-        freq='day',
+-        fields=['$close']
+-    )
+-    
+-    print(f"获取到价格数据，形状: {data.shape}")
+-    
+-    # 计算均线
+-    short_ma = data.rolling(window=5).mean()
+-    long_ma = data.rolling(window=20).mean()
+-    
+-    # 计算交叉信号
+-    signals = pd.DataFrame(0, index=data.index, columns=data.columns)
+-    
+-    for col in data.columns:
+-        # 计算均线差值
+-        diff = short_ma[col] - long_ma[col]
+-        
+-        # 计算交叉信号
+-        for i in range(1, len(diff)):
+-            if diff.iloc[i-1] < 0 and diff.iloc[i] > 0:
+-                signals.iloc[i, signals.columns.get_loc(col)] = 1  # 金叉买入
+-            elif diff.iloc[i-1] > 0 and diff.iloc[i] < 0:
+-                signals.iloc[i, signals.columns.get_loc(col)] = -1  # 死叉卖出
+-    
+-    # 统计信号
+-    buy_signals = (signals == 1).sum().sum()
+-    sell_signals = (signals == -1).sum().sum()
+-    
+-    print(f"\n信号统计:")
+-    print(f"买入信号数量: {buy_signals}")
+-    print(f"卖出信号数量: {sell_signals}")
+-    
+-    # 计算简单收益（假设每次信号都产生1%的收益）
+-    returns = signals * 0.01
+-    cumulative_returns = returns.sum(axis=1).cumsum()
+-    
+-    print(f"\n累计收益: {cumulative_returns.iloc[-1]:.2%}")
+-    
+-    return signals, cumulative_returns
+-
+-
+-def main():
+-    """
+-    主函数
+-    """
+-    print("开始运行均线交叉策略回测...")
+-    
+-    try:
+-        # 运行简化版回测
+-        signals, cumulative_returns = create_simple_backtest()
+-        
+-        # 保存简化版结果
+-        signals.to_csv("ma_cross_signals.csv")
+-        cumulative_returns.to_csv("ma_cross_cumulative_returns.csv")
+-        
+-        print("\n简化版回测完成！")
+-        print("信号数据已保存到 ma_cross_signals.csv")
+-        print("累计收益已保存到 ma_cross_cumulative_returns.csv")
+-        
+-    except Exception as e:
+-        print(f"回测过程中出现错误: {e}")
+-        print("请确保已正确安装qlib并下载了相应的数据。")
+-
+-
+-if __name__ == "__main__":
+-    main() 
+\ No newline at end of file
+diff --git a/test/ma_strategy_demo.py b/test/ma_strategy_demo.py
+deleted file mode 100644
+index 1fa4fb4..0000000
+Binary files a/test/ma_strategy_demo.py and /dev/null differ
+diff --git a/test/simple_ma_strategy.py b/test/simple_ma_strategy.py
+deleted file mode 100644
+index 8d03f6b..0000000
+--- a/test/simple_ma_strategy.py
++++ /dev/null
+@@ -1,298 +0,0 @@
+-"""
+-简单实用的均线交叉策略
+-金叉买入，死叉卖出
+-"""
+-
+-import qlib
+-from qlib.constant import REG_CN
+-from qlib.data import D
+-import pandas as pd
+-import numpy as np
+-import matplotlib.pyplot as plt
+-from datetime import datetime, timedelta
+-
+-
+-def init_qlib():
+-    """初始化qlib"""
+-    try:
+-        qlib.init(provider_uri='~/.qlib/qlib_data/cn_data', region=REG_CN)
+-        print("qlib初始化成功")
+-        return True
+-    except Exception as e:
+-        print(f"qlib初始化失败: {e}")
+-        print("请确保已安装qlib并下载了数据")
+-        return False
+-
+-
+-def get_stock_data(instruments, start_date, end_date):
+-    """
+-    获取股票数据
+-    
+-    Args:
+-        instruments: 股票代码列表
+-        start_date: 开始日期
+-        end_date: 结束日期
+-    
+-    Returns:
+-        股票价格数据
+-    """
+-    try:
+-        data = D.features(
+-            instruments=instruments,
+-            start_time=start_date,
+-            end_time=end_date,
+-            freq='day',
+-            fields=['$close', '$open', '$high', '$low', '$volume']
+-        )
+-        
+-        if data is not None and not data.empty:
+-            # 重命名列
+-            data.columns = ['close', 'open', 'high', 'low', 'volume']
+-            return data
+-        else:
+-            print("未获取到数据")
+-            return None
+-            
+-    except Exception as e:
+-        print(f"获取数据失败: {e}")
+-        return None
+-
+-
+-def calculate_ma_signals(data, short_window=5, long_window=20):
+-    """
+-    计算均线交叉信号
+-    
+-    Args:
+-        data: 价格数据
+-        short_window: 短期均线周期
+-        long_window: 长期均线周期
+-    
+-    Returns:
+-        信号DataFrame，1表示买入，-1表示卖出，0表示无信号
+-    """
+-    signals = pd.DataFrame(0, index=data.index, columns=data.columns)
+-    
+-    for col in data.columns:
+-        if col == 'close':
+-            continue
+-            
+-        # 计算均线
+-        short_ma = data[col].rolling(window=short_window).mean()
+-        long_ma = data[col].rolling(window=long_window).mean()
+-        
+-        # 计算均线差值
+-        diff = short_ma - long_ma
+-        
+-        # 计算交叉信号
+-        for i in range(1, len(diff)):
+-            if pd.notna(diff.iloc[i-1]) and pd.notna(diff.iloc[i]):
+-                # 金叉：短期均线从下方穿越长期均线
+-                if diff.iloc[i-1] < 0 and diff.iloc[i] > 0:
+-                    signals.iloc[i, signals.columns.get_loc(col)] = 1
+-                # 死叉：短期均线从上方穿越长期均线
+-                elif diff.iloc[i-1] > 0 and diff.iloc[i] < 0:
+-                    signals.iloc[i, signals.columns.get_loc(col)] = -1
+-    
+-    return signals
+-
+-
+-def calculate_returns(data, signals, initial_capital=100000):
+-    """
+-    计算策略收益
+-    
+-    Args:
+-        data: 价格数据
+-        signals: 信号数据
+-        initial_capital: 初始资金
+-    
+-    Returns:
+-        收益数据
+-    """
+-    # 计算日收益率
+-    returns = data.pct_change()
+-    
+-    # 策略收益（假设每次信号产生1%的收益）
+-    strategy_returns = signals * 0.01
+-    
+-    # 累计收益
+-    cumulative_returns = strategy_returns.sum(axis=1).cumsum()
+-    
+-    # 资金曲线
+-    capital_curve = initial_capital * (1 + cumulative_returns)
+-    
+-    return {
+-        'strategy_returns': strategy_returns,
+-        'cumulative_returns': cumulative_returns,
+-        'capital_curve': capital_curve
+-    }
+-
+-
+-def analyze_strategy(signals, returns_data):
+-    """
+-    分析策略表现
+-    
+-    Args:
+-        signals: 信号数据
+-        returns_data: 收益数据
+-    """
+-    print("=" * 50)
+-    print("均线交叉策略分析结果")
+-    print("=" * 50)
+-    
+-    # 信号统计
+-    buy_signals = (signals == 1).sum().sum()
+-    sell_signals = (signals == -1).sum().sum()
+-    
+-    print(f"买入信号数量: {buy_signals}")
+-    print(f"卖出信号数量: {sell_signals}")
+-    print(f"总信号数量: {buy_signals + sell_signals}")
+-    
+-    # 收益统计
+-    cumulative_returns = returns_data['cumulative_returns']
+-    capital_curve = returns_data['capital_curve']
+-    
+-    total_return = cumulative_returns.iloc[-1]
+-    annual_return = total_return / (len(cumulative_returns) / 252)
+-    
+-    print(f"\n收益统计:")
+-    print(f"总收益率: {total_return:.2%}")
+-    print(f"年化收益率: {annual_return:.2%}")
+-    print(f"最终资金: {capital_curve.iloc[-1]:,.0f}")
+-    
+-    # 风险统计
+-    daily_returns = returns_data['strategy_returns'].sum(axis=1)
+-    volatility = daily_returns.std() * np.sqrt(252)
+-    sharpe_ratio = annual_return / volatility if volatility > 0 else 0
+-    
+-    print(f"\n风险统计:")
+-    print(f"年化波动率: {volatility:.2%}")
+-    print(f"夏普比率: {sharpe_ratio:.2f}")
+-    print(f"胜率: {(daily_returns > 0).mean():.2%}")
+-
+-
+-def plot_results(data, signals, returns_data, stock_code):
+-    """
+-    绘制结果图表
+-    
+-    Args:
+-        data: 价格数据
+-        signals: 信号数据
+-        returns_data: 收益数据
+-        stock_code: 股票代码
+-    """
+-    fig, axes = plt.subplots(3, 1, figsize=(12, 10))
+-    
+-    # 绘制价格和均线
+-    axes[0].plot(data.index, data[stock_code], label='收盘价', alpha=0.7)
+-    short_ma = data[stock_code].rolling(window=5).mean()
+-    long_ma = data[stock_code].rolling(window=20).mean()
+-    axes[0].plot(data.index, short_ma, label='5日均线', alpha=0.8)
+-    axes[0].plot(data.index, long_ma, label='20日均线', alpha=0.8)
+-    
+-    # 标记买卖信号
+-    buy_signals = signals[stock_code] == 1
+-    sell_signals = signals[stock_code] == -1
+-    
+-    axes[0].scatter(data.index[buy_signals], data.loc[buy_signals, stock_code], 
+-                   color='red', marker='^', s=100, label='买入信号', alpha=0.8)
+-    axes[0].scatter(data.index[sell_signals], data.loc[sell_signals, stock_code], 
+-                   color='green', marker='v', s=100, label='卖出信号', alpha=0.8)
+-    
+-    axes[0].set_title(f'{stock_code} 价格走势与均线交叉信号')
+-    axes[0].legend()
+-    axes[0].grid(True, alpha=0.3)
+-    
+-    # 绘制累计收益
+-    axes[1].plot(returns_data['cumulative_returns'].index, 
+-                returns_data['cumulative_returns'].values, 
+-                label='累计收益', color='blue')
+-    axes[1].set_title('策略累计收益')
+-    axes[1].legend()
+-    axes[1].grid(True, alpha=0.3)
+-    
+-    # 绘制资金曲线
+-    axes[2].plot(returns_data['capital_curve'].index, 
+-                returns_data['capital_curve'].values, 
+-                label='资金曲线', color='green')
+-    axes[2].set_title('资金曲线')
+-    axes[2].legend()
+-    axes[2].grid(True, alpha=0.3)
+-    
+-    plt.tight_layout()
+-    plt.savefig('ma_cross_strategy_results.png', dpi=300, bbox_inches='tight')
+-    plt.show()
+-
+-
+-def main():
+-    """
+-    主函数
+-    """
+-    print("开始运行均线交叉策略...")
+-    
+-    # 初始化qlib
+-    if not init_qlib():
+-        return
+-    
+-    # 策略参数
+-    start_date = "2020-01-01"
+-    end_date = "2023-12-31"
+-    short_window = 5
+-    long_window = 20
+-    initial_capital = 100000
+-    
+-    # 获取股票列表
+-    try:
+-        instruments = D.list_instruments(instruments="csi300", start_time=start_date, end_time=end_date)
+-        print(f"获取到 {len(instruments)} 只股票")
+-        
+-        # 选择前5只股票进行演示
+-        demo_instruments = instruments[:5]
+-        print(f"选择演示股票: {demo_instruments}")
+-        
+-    except Exception as e:
+-        print(f"获取股票列表失败: {e}")
+-        # 使用默认股票列表
+-        demo_instruments = ['000001.SZ', '000002.SZ', '000858.SZ', '002415.SZ', '600036.SH']
+-        print(f"使用默认股票列表: {demo_instruments}")
+-    
+-    # 获取价格数据
+-    data = get_stock_data(demo_instruments, start_date, end_date)
+-    
+-    if data is None:
+-        print("无法获取数据，程序退出")
+-        return
+-    
+-    print(f"获取到价格数据，形状: {data.shape}")
+-    
+-    # 计算均线信号
+-    signals = calculate_ma_signals(data, short_window, long_window)
+-    
+-    # 计算收益
+-    returns_data = calculate_returns(data, signals, initial_capital)
+-    
+-    # 分析策略
+-    analyze_strategy(signals, returns_data)
+-    
+-    # 保存结果
+-    signals.to_csv("ma_cross_signals.csv")
+-    returns_data['cumulative_returns'].to_csv("ma_cross_cumulative_returns.csv")
+-    returns_data['capital_curve'].to_csv("ma_cross_capital_curve.csv")
+-    
+-    print("\n结果已保存到CSV文件:")
+-    print("- ma_cross_signals.csv: 买卖信号")
+-    print("- ma_cross_cumulative_returns.csv: 累计收益")
+-    print("- ma_cross_capital_curve.csv: 资金曲线")
+-    
+-    # 绘制图表（选择第一只股票）
+-    if len(demo_instruments) > 0:
+-        try:
+-            plot_results(data, signals, returns_data, demo_instruments[0])
+-            print("图表已保存为 ma_cross_strategy_results.png")
+-        except Exception as e:
+-            print(f"绘制图表失败: {e}")
+-    
+-    print("\n策略回测完成！")
+-
+-
+-if __name__ == "__main__":
+-    main() 
+\ No newline at end of file
+diff --git a/test/two_ema_stragety.py b/test/two_ema_stragety.py
+index a72e7e8..a9890c7 100644
+--- a/test/two_ema_stragety.py
++++ b/test/two_ema_stragety.py
+@@ -1,2 +1,98 @@
+-from qlib.contrib.strategy import 
+-from qlib.backtest import backtest
+\ No newline at end of file
++import pandas as pd
++
++from abc import ABC
++from typing import Dict, List, Text, Tuple, Union
++from qlib.data.dataset import Dataset
++from qlib.model.base import BaseModel
++from qlib.backtest.signal import Signal, create_signal_from
++from qlib.strategy.base import BaseStrategy
++from qlib.backtest.decision import Order, OrderDir, OrderHelper, TradeDecisionWO
++# from qlib.strategy import 
++# from qlib.backtest import backtest
++
++class InnerStrategy(BaseStrategy):
++    """
++    Inner strategy for order execution:
++    - Buy: if price < 200, buy all cash; else buy 200,000 worth.
++    - Sell: if price > 200, sell all; else sell half.
++    """
++    STOCK_CODE = "000858.SZ"
++
++    def generate_trade_decision(self, execute_result: list = None, action: str = None, amount: float = None):
++        # action: 'buy' or 'sell', amount: suggested amount (shares) from outer
++        position = self.trade_position
++        trade_step = self.trade_calendar.get_trade_step()
++        trade_start_time, trade_end_time = self.trade_calendar.get_step_time(trade_step)
++        order_helper = self.trade_exchange.get_order_helper()
++        orders = []
++        price = self.trade_exchange.get_deal_price(self.STOCK_CODE, trade_start_time, trade_end_time)
++        if action == 'buy':
++            cash = position.get_cash()
++            if price <= 0:
++                return TradeDecisionWO([], self)
++            if price < 200:
++                buy_amount = cash // price
++            else:
++                buy_amount = min(cash // price, 200000 // price)
++            buy_amount = int(buy_amount)
++            if buy_amount > 0:
++                order = order_helper.create(
++                    code=self.STOCK_CODE,
++                    amount=buy_amount,
++                    direction=OrderDir.BUY,
++                    start_time=trade_start_time,
++                    end_time=trade_end_time,
++                )
++                orders.append(order)
++        elif action == 'sell':
++            held_amount = position.get_stock_amount(self.STOCK_CODE)
++            if held_amount <= 0 or price <= 0:
++                return TradeDecisionWO([], self)
++            if price > 200:
++                sell_amount = held_amount
++            else:
++                sell_amount = held_amount // 2
++            sell_amount = int(sell_amount)
++            if sell_amount > 0:
++                order = order_helper.create(
++                    code=self.STOCK_CODE,
++                    amount=sell_amount,
++                    direction=OrderDir.SELL,
++                    start_time=trade_start_time,
++                    end_time=trade_end_time,
++                )
++                orders.append(order)
++        return TradeDecisionWO(orders, self)
++
++class OuterStrategy(BaseStrategy):
++    """
++    Outer strategy:
++    - If not holding Wuliangye, issues a buy order via inner strategy.
++    - If holding, checks if held for 25 days, if so, issues a sell order via inner strategy.
++    - Otherwise, holds.
++    """
++    STOCK_CODE = "000858.SZ"
++    HOLD_DAYS = 25
++    BAR = "day"
++
++    def __init__(self, *args, **kwargs):
++        super().__init__(*args, **kwargs)
++        self.inner_strategy = InnerStrategy()
++
++    def generate_trade_decision(self, execute_result: list = None):
++        position = self.trade_position
++        stock_list = position.get_stock_list()
++        trade_step = self.trade_calendar.get_trade_step()
++        trade_start_time, trade_end_time = self.trade_calendar.get_step_time(trade_step)
++        # Pass infra to inner strategy
++        self.inner_strategy.reset(level_infra=self.level_infra, common_infra=self.common_infra)
++        if self.STOCK_CODE in stock_list:
++            hold_days = position.get_stock_count(self.STOCK_CODE, self.BAR)
++            if hold_days >= self.HOLD_DAYS:
++                # Sell via inner strategy
++                return self.inner_strategy.generate_trade_decision(action='sell')
++        else:
++            # Buy via inner strategy
++            return self.inner_strategy.generate_trade_decision(action='buy')
++        # Otherwise, hold
++        return TradeDecisionWO([], self)
+\ No newline at end of file
diff --git a/mlruns/812028854715931404/00589ed0f1f74dc3a1e2302f49a29e32/artifacts/code_status.txt b/mlruns/812028854715931404/00589ed0f1f74dc3a1e2302f49a29e32/artifacts/code_status.txt
new file mode 100644
index 0000000..d9b6458
--- /dev/null
+++ b/mlruns/812028854715931404/00589ed0f1f74dc3a1e2302f49a29e32/artifacts/code_status.txt
@@ -0,0 +1,25 @@
+On branch main
+Your branch is up to date with 'origin/main'.
+
+Changes not staged for commit:
+  (use "git add/rm <file>..." to update what will be committed)
+  (use "git restore <file>..." to discard changes in working directory)
+	modified:   github/examples/benchmarks/LightGBM/workflow_config_lightgbm_Alpha1582.yaml
+	deleted:    test/README_MA_Strategy.md
+	modified:   test/damo1.py
+	modified:   test/demo2.ipynb
+	deleted:    test/ma_cross_strategy.py
+	deleted:    test/ma_cross_strategy_improved.py
+	deleted:    test/ma_strategy_demo.py
+	deleted:    test/simple_ma_strategy.py
+	modified:   test/two_ema_stragety.py
+
+Untracked files:
+  (use "git add <file>..." to include in what will be committed)
+	github/examples/mlruns/881301994755452456/157579a2201241aaafcff94e93d7da0e/
+	mlruns/
+	test/__pycache__/
+	test/buy_and_hold.py
+	test/workflow_by_code.py
+
+no changes added to commit (use "git add" and/or "git commit -a")
diff --git a/mlruns/812028854715931404/00589ed0f1f74dc3a1e2302f49a29e32/meta.yaml b/mlruns/812028854715931404/00589ed0f1f74dc3a1e2302f49a29e32/meta.yaml
new file mode 100644
index 0000000..5b45ec1
--- /dev/null
+++ b/mlruns/812028854715931404/00589ed0f1f74dc3a1e2302f49a29e32/meta.yaml
@@ -0,0 +1,14 @@
+artifact_uri: file:D:\project\python\tradenote\mlruns/812028854715931404/00589ed0f1f74dc3a1e2302f49a29e32/artifacts
+end_time: 1750320256156
+entry_point_name: ''
+experiment_id: '812028854715931404'
+lifecycle_stage: active
+run_id: 00589ed0f1f74dc3a1e2302f49a29e32
+run_name: mlflow_recorder
+source_name: ''
+source_type: 4
+source_version: ''
+start_time: 1750320255941
+status: 3
+tags: []
+user_id: abulimity
diff --git a/mlruns/812028854715931404/00589ed0f1f74dc3a1e2302f49a29e32/params/cmd-sys.argv b/mlruns/812028854715931404/00589ed0f1f74dc3a1e2302f49a29e32/params/cmd-sys.argv
new file mode 100644
index 0000000..db800eb
--- /dev/null
+++ b/mlruns/812028854715931404/00589ed0f1f74dc3a1e2302f49a29e32/params/cmd-sys.argv
@@ -0,0 +1 @@
+D:\project\python\tradenote\test\workflow_by_code.py
\ No newline at end of file
diff --git a/mlruns/812028854715931404/00589ed0f1f74dc3a1e2302f49a29e32/tags/mlflow.runName b/mlruns/812028854715931404/00589ed0f1f74dc3a1e2302f49a29e32/tags/mlflow.runName
new file mode 100644
index 0000000..25487e4
--- /dev/null
+++ b/mlruns/812028854715931404/00589ed0f1f74dc3a1e2302f49a29e32/tags/mlflow.runName
@@ -0,0 +1 @@
+mlflow_recorder
\ No newline at end of file
diff --git a/mlruns/812028854715931404/00589ed0f1f74dc3a1e2302f49a29e32/tags/mlflow.source.git.commit b/mlruns/812028854715931404/00589ed0f1f74dc3a1e2302f49a29e32/tags/mlflow.source.git.commit
new file mode 100644
index 0000000..288ce21
--- /dev/null
+++ b/mlruns/812028854715931404/00589ed0f1f74dc3a1e2302f49a29e32/tags/mlflow.source.git.commit
@@ -0,0 +1 @@
+0daea9b5bbb40120a1bc07c702d171abc1f219c7
\ No newline at end of file
diff --git a/mlruns/812028854715931404/00589ed0f1f74dc3a1e2302f49a29e32/tags/mlflow.source.name b/mlruns/812028854715931404/00589ed0f1f74dc3a1e2302f49a29e32/tags/mlflow.source.name
new file mode 100644
index 0000000..db800eb
--- /dev/null
+++ b/mlruns/812028854715931404/00589ed0f1f74dc3a1e2302f49a29e32/tags/mlflow.source.name
@@ -0,0 +1 @@
+D:\project\python\tradenote\test\workflow_by_code.py
\ No newline at end of file
diff --git a/mlruns/812028854715931404/00589ed0f1f74dc3a1e2302f49a29e32/tags/mlflow.source.type b/mlruns/812028854715931404/00589ed0f1f74dc3a1e2302f49a29e32/tags/mlflow.source.type
new file mode 100644
index 0000000..0c2c1fe
--- /dev/null
+++ b/mlruns/812028854715931404/00589ed0f1f74dc3a1e2302f49a29e32/tags/mlflow.source.type
@@ -0,0 +1 @@
+LOCAL
\ No newline at end of file
diff --git a/mlruns/812028854715931404/00589ed0f1f74dc3a1e2302f49a29e32/tags/mlflow.user b/mlruns/812028854715931404/00589ed0f1f74dc3a1e2302f49a29e32/tags/mlflow.user
new file mode 100644
index 0000000..b9cec6f
--- /dev/null
+++ b/mlruns/812028854715931404/00589ed0f1f74dc3a1e2302f49a29e32/tags/mlflow.user
@@ -0,0 +1 @@
+abulimity
\ No newline at end of file
diff --git a/mlruns/812028854715931404/1dca43fd8d16419688b3de890200d985/artifacts/code_cached.txt b/mlruns/812028854715931404/1dca43fd8d16419688b3de890200d985/artifacts/code_cached.txt
new file mode 100644
index 0000000..e69de29
diff --git a/mlruns/812028854715931404/1dca43fd8d16419688b3de890200d985/artifacts/code_diff.txt b/mlruns/812028854715931404/1dca43fd8d16419688b3de890200d985/artifacts/code_diff.txt
new file mode 100644
index 0000000..067487e
--- /dev/null
+++ b/mlruns/812028854715931404/1dca43fd8d16419688b3de890200d985/artifacts/code_diff.txt
@@ -0,0 +1,1508 @@
+diff --git a/github/examples/benchmarks/LightGBM/workflow_config_lightgbm_Alpha1582.yaml b/github/examples/benchmarks/LightGBM/workflow_config_lightgbm_Alpha1582.yaml
+index 8b4e7bf..7a5eee7 100644
+--- a/github/examples/benchmarks/LightGBM/workflow_config_lightgbm_Alpha1582.yaml
++++ b/github/examples/benchmarks/LightGBM/workflow_config_lightgbm_Alpha1582.yaml
+@@ -1,5 +1,5 @@
+ qlib_init:
+-    provider_uri: "D:/project/tradenote/qlib_data/cn_data"
++    provider_uri: "D:/sync/qlib/qlib_data/cn_data"
+     region: cn
+ market: &market csi300
+ benchmark: &benchmark SH000300
+diff --git a/test/README_MA_Strategy.md b/test/README_MA_Strategy.md
+deleted file mode 100644
+index 5facaf7..0000000
+--- a/test/README_MA_Strategy.md
++++ /dev/null
+@@ -1,197 +0,0 @@
+-# 均线交叉策略 (Moving Average Crossover Strategy)
+-
+-## 策略概述
+-
+-这是一个基于qlib框架实现的均线交叉策略，核心逻辑是：
+-- **金叉买入**：短期均线上穿长期均线时买入
+-- **死叉卖出**：短期均线下穿长期均线时卖出
+-
+-## 文件说明
+-
+-### 1. `ma_cross_strategy.py`
+-完整的策略实现，包含：
+-- `MACrossStrategy` 类：继承自qlib的TopkDropoutStrategy
+-- 完整的回测框架
+-- 结果分析和保存
+-
+-### 2. `ma_cross_strategy_improved.py`
+-改进版本，包含：
+-- 更完善的数据获取逻辑
+-- 错误处理机制
+-- 简化版回测功能
+-
+-### 3. `simple_ma_strategy.py` ⭐ **推荐使用**
+-简单实用的版本，包含：
+-- 清晰的数据获取和处理
+-- 均线信号计算
+-- 收益计算和分析
+-- 可视化图表生成
+-- 结果保存功能
+-
+-## 使用方法
+-
+-### 环境准备
+-
+-1. 确保已安装qlib：
+-```bash
+-pip install pyqlib
+-```
+-
+-2. 下载qlib数据（如果还没有）：
+-```bash
+-# 下载中国股票数据
+-python -m qlib.data.dump_bin --csv_path ~/.qlib/qlib_data/cn_data --include_fields close,open,high,low,volume
+-```
+-
+-### 运行策略
+-
+-#### 方法1：运行简单版本（推荐）
+-```bash
+-cd test
+-python simple_ma_strategy.py
+-```
+-
+-#### 方法2：运行完整版本
+-```bash
+-cd test
+-python ma_cross_strategy.py
+-```
+-
+-#### 方法3：运行改进版本
+-```bash
+-cd test
+-python ma_cross_strategy_improved.py
+-```
+-
+-## 策略参数
+-
+-可以在代码中修改以下参数：
+-
+-```python
+-# 均线周期
+-short_window = 5    # 短期均线周期
+-long_window = 20    # 长期均线周期
+-
+-# 回测时间
+-start_date = "2020-01-01"
+-end_date = "2023-12-31"
+-
+-# 初始资金
+-initial_capital = 100000
+-
+-# 股票池
+-instruments = "csi300"  # 沪深300成分股
+-```
+-
+-## 输出结果
+-
+-运行策略后会生成以下文件：
+-
+-1. **CSV文件**：
+-   - `ma_cross_signals.csv`：买卖信号数据
+-   - `ma_cross_cumulative_returns.csv`：累计收益数据
+-   - `ma_cross_capital_curve.csv`：资金曲线数据
+-
+-2. **图表文件**：
+-   - `ma_cross_strategy_results.png`：策略结果可视化图表
+-
+-3. **控制台输出**：
+-   - 策略分析结果
+-   - 收益统计
+-   - 风险指标
+-
+-## 策略分析指标
+-
+-### 收益指标
+-- 总收益率
+-- 年化收益率
+-- 最终资金
+-
+-### 风险指标
+-- 年化波动率
+-- 夏普比率
+-- 胜率
+-- 最大回撤
+-
+-### 交易统计
+-- 买入信号数量
+-- 卖出信号数量
+-- 总交易次数
+-
+-## 策略逻辑详解
+-
+-### 1. 均线计算
+-```python
+-# 计算短期和长期均线
+-short_ma = price_data.rolling(window=short_window).mean()
+-long_ma = price_data.rolling(window=long_window).mean()
+-```
+-
+-### 2. 交叉信号判断
+-```python
+-# 计算均线差值
+-diff = short_ma - long_ma
+-
+-# 金叉：短期均线从下方穿越长期均线
+-if diff.iloc[i-1] < 0 and diff.iloc[i] > 0:
+-    signal = 1  # 买入信号
+-
+-# 死叉：短期均线从上方穿越长期均线
+-elif diff.iloc[i-1] > 0 and diff.iloc[i] < 0:
+-    signal = -1  # 卖出信号
+-```
+-
+-### 3. 收益计算
+-```python
+-# 策略收益（简化处理）
+-strategy_returns = signals * 0.01
+-
+-# 累计收益
+-cumulative_returns = strategy_returns.sum(axis=1).cumsum()
+-```
+-
+-## 注意事项
+-
+-1. **数据依赖**：确保qlib数据已正确下载和配置
+-2. **参数调优**：可以根据不同市场环境调整均线周期
+-3. **风险控制**：实际交易中需要加入止损和仓位管理
+-4. **交易成本**：当前版本未考虑交易费用，实际应用需要考虑
+-
+-## 扩展功能
+-
+-可以基于此策略进行以下扩展：
+-
+-1. **多均线策略**：使用多条均线进行更复杂的信号判断
+-2. **量价配合**：结合成交量指标优化信号
+-3. **止损机制**：添加动态止损策略
+-4. **仓位管理**：根据信号强度调整仓位大小
+-5. **多股票组合**：构建股票组合分散风险
+-
+-## 常见问题
+-
+-### Q: 如何修改股票池？
+-A: 在代码中修改 `instruments` 参数，例如：
+-```python
+-instruments = "csi500"  # 中证500
+-instruments = ["000001.SZ", "000002.SZ"]  # 指定股票列表
+-```
+-
+-### Q: 如何调整均线周期？
+-A: 修改 `short_window` 和 `long_window` 参数：
+-```python
+-short_window = 10  # 10日均线
+-long_window = 30   # 30日均线
+-```
+-
+-### Q: 如何查看详细的交易记录？
+-A: 查看生成的 `ma_cross_signals.csv` 文件，其中包含每日的买卖信号。
+-
+-## 联系方式
+-
+-如有问题或建议，请通过以下方式联系：
+-- 提交Issue到项目仓库
+-- 发送邮件到项目维护者
+-
+----
+-
+-**免责声明**：本策略仅供学习和研究使用，不构成投资建议。实际投资请谨慎决策，并承担相应风险。 
+\ No newline at end of file
+diff --git a/test/damo1.py b/test/damo1.py
+index 03102e1..afa2886 100644
+--- a/test/damo1.py
++++ b/test/damo1.py
+@@ -1,9 +1,35 @@
+-# python scripts/get_data.py qlib_data --target_dir ../qlib_data/cn_data --region cn
+-
+ import qlib
+-# region in [REG_CN, REG_US]
+-from qlib.constant import REG_CN
+-provider_uri = "D:/project/tradenote/qlib_data/cn_data"  # target_dir
+-qlib.init(provider_uri=provider_uri, region=REG_CN)
++from qlib.data import D
++
++# 初始化 Qlib
++qlib.init(provider_uri="D:/sync/qlib/qlib_data/cn_data", region="cn")
++
++# 检查目标股票和基准
++stock_code = "SZ000858"  # 你的BuyHold策略用的股票代码
++benchmark = "SH000300"
++
++print("--- 检查可用股票列表（前10只） ---")
++print(list(D.instruments(market="all"))[:10])
++
++print("--- 检查交易日（2017-01-01 ~ 2020-08-01，前10天） ---")
++print(D.calendar(start_time="2017-01-01", end_time="2020-08-01")[:10])
++
++print(f"--- 检查目标股票 {stock_code} 是否在股票池 ---")
++print(stock_code in D.instruments(market="all"))
++
++print(f"--- 检查基准 {benchmark} 是否在股票池 ---")
++print(benchmark in D.instruments(market="all"))
++
++print(f"--- 检查目标股票 {stock_code} 的行情数据（前5行） ---")
++try:
++    df = D.features([stock_code], ["$close", "$open", "$high", "$low", "$volume"], start_time="2017-01-01", end_time="2020-08-01")
++    print(df.head())
++except Exception as e:
++    print(f"获取行情数据失败: {e}")
+ 
+-# qrun benchmarks/LightGBM/workflow_config_lightgbm_Alpha1582.yaml
++print(f"--- 检查基准 {benchmark} 的行情数据（前5行） ---")
++try:
++    df_bench = D.features([benchmark], ["$close"], start_time="2017-01-01", end_time="2020-08-01")
++    print(df_bench.head())
++except Exception as e:
++    print(f"获取基准行情数据失败: {e}")
+diff --git a/test/demo2.ipynb b/test/demo2.ipynb
+index 66a0215..ad02df5 100644
+--- a/test/demo2.ipynb
++++ b/test/demo2.ipynb
+@@ -2,7 +2,7 @@
+  "cells": [
+   {
+    "cell_type": "code",
+-   "execution_count": 4,
++   "execution_count": 12,
+    "id": "6acb4a77",
+    "metadata": {},
+    "outputs": [
+@@ -10,39 +10,75 @@
+      "name": "stderr",
+      "output_type": "stream",
+      "text": [
+-      "[5344:MainThread](2025-06-18 14:41:03,895) INFO - qlib.Initialization - [config.py:420] - default_conf: client.\n",
+-      "[5344:MainThread](2025-06-18 14:41:03,900) INFO - qlib.Initialization - [__init__.py:74] - qlib successfully initialized based on client settings.\n",
+-      "[5344:MainThread](2025-06-18 14:41:03,903) INFO - qlib.Initialization - [__init__.py:76] - data_path={'__DEFAULT_FREQ': WindowsPath('D:/sync/qlib/qlib_data/cn_data')}\n"
++      "[13736:MainThread](2025-06-19 15:30:19,504) INFO - qlib.Initialization - [config.py:420] - default_conf: client.\n",
++      "[13736:MainThread](2025-06-19 15:30:19,506) INFO - qlib.Initialization - [__init__.py:74] - qlib successfully initialized based on client settings.\n",
++      "[13736:MainThread](2025-06-19 15:30:19,508) INFO - qlib.Initialization - [__init__.py:76] - data_path={'__DEFAULT_FREQ': WindowsPath('D:/sync/qlib/qlib_data/cn_data')}\n"
+      ]
+     }
+    ],
+    "source": [
+     "import qlib\n",
+-    "qlib.init(provider_uri=\"D:/sync/qlib/qlib_data/cn_data\", region=\"cn\")"
++    "qlib.init(provider_uri=r\"D:\\sync\\qlib\\qlib_data\\cn_data\", region=\"cn\")"
+    ]
+   },
+   {
+    "cell_type": "code",
+-   "execution_count": 12,
++   "execution_count": 14,
+    "id": "295df9af",
+    "metadata": {},
+    "outputs": [
+     {
+      "data": {
+       "text/plain": [
+-       "array([Timestamp('2020-09-21 00:00:00'), Timestamp('2020-09-22 00:00:00'),\n",
+-       "       Timestamp('2020-09-23 00:00:00'), Timestamp('2020-09-24 00:00:00'),\n",
+-       "       Timestamp('2020-09-25 00:00:00')], dtype=object)"
++       "array([Timestamp('2017-01-03 00:00:00'), Timestamp('2017-01-04 00:00:00'),\n",
++       "       Timestamp('2017-01-05 00:00:00'), Timestamp('2017-01-06 00:00:00'),\n",
++       "       Timestamp('2017-01-09 00:00:00')], dtype=object)"
+       ]
+      },
+-     "execution_count": 12,
++     "execution_count": 14,
+      "metadata": {},
+      "output_type": "execute_result"
+     }
+    ],
+    "source": [
+     "from qlib.data import D\n",
+-    "D.calendar(start_time='2020-09-21', end_time='2020-10-30', freq='day')"
++    "D.calendar(start_time=\"2017-01-01\", end_time=\"2020-08-01\",freq=\"day\")[:5]"
++   ]
++  },
++  {
++   "cell_type": "code",
++   "execution_count": 21,
++   "id": "da009afa",
++   "metadata": {},
++   "outputs": [
++    {
++     "ename": "error",
++     "evalue": "nothing to repeat at position 0",
++     "output_type": "error",
++     "traceback": [
++      "\u001b[31m---------------------------------------------------------------------------\u001b[39m",
++      "\u001b[31merror\u001b[39m                                     Traceback (most recent call last)",
++      "\u001b[36mCell\u001b[39m\u001b[36m \u001b[39m\u001b[32mIn[21]\u001b[39m\u001b[32m, line 4\u001b[39m\n\u001b[32m      2\u001b[39m nameDFilter = NameDFilter(name_rule_re=\u001b[33m'\u001b[39m\u001b[33m*000858\u001b[39m\u001b[33m'\u001b[39m)\n\u001b[32m      3\u001b[39m instruments = D.instruments(market=\u001b[33m'\u001b[39m\u001b[33mall\u001b[39m\u001b[33m'\u001b[39m,filter_pipe=[nameDFilter])\n\u001b[32m----> \u001b[39m\u001b[32m4\u001b[39m \u001b[43mD\u001b[49m\u001b[43m.\u001b[49m\u001b[43mlist_instruments\u001b[49m\u001b[43m(\u001b[49m\u001b[43minstruments\u001b[49m\u001b[43m=\u001b[49m\u001b[43minstruments\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mstart_time\u001b[49m\u001b[43m=\u001b[49m\u001b[33;43m'\u001b[39;49m\u001b[33;43m2015-01-01\u001b[39;49m\u001b[33;43m'\u001b[39;49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mend_time\u001b[49m\u001b[43m=\u001b[49m\u001b[33;43m'\u001b[39;49m\u001b[33;43m2016-02-15\u001b[39;49m\u001b[33;43m'\u001b[39;49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mas_list\u001b[49m\u001b[43m=\u001b[49m\u001b[38;5;28;43;01mTrue\u001b[39;49;00m\u001b[43m)\u001b[49m\n",
++      "\u001b[36mFile \u001b[39m\u001b[32md:\\project\\python\\tradenote\\.venv\\Lib\\site-packages\\qlib\\data\\data.py:1160\u001b[39m, in \u001b[36mBaseProvider.list_instruments\u001b[39m\u001b[34m(self, instruments, start_time, end_time, freq, as_list)\u001b[39m\n\u001b[32m   1159\u001b[39m \u001b[38;5;28;01mdef\u001b[39;00m\u001b[38;5;250m \u001b[39m\u001b[34mlist_instruments\u001b[39m(\u001b[38;5;28mself\u001b[39m, instruments, start_time=\u001b[38;5;28;01mNone\u001b[39;00m, end_time=\u001b[38;5;28;01mNone\u001b[39;00m, freq=\u001b[33m\"\u001b[39m\u001b[33mday\u001b[39m\u001b[33m\"\u001b[39m, as_list=\u001b[38;5;28;01mFalse\u001b[39;00m):\n\u001b[32m-> \u001b[39m\u001b[32m1160\u001b[39m     \u001b[38;5;28;01mreturn\u001b[39;00m \u001b[43mInst\u001b[49m\u001b[43m.\u001b[49m\u001b[43mlist_instruments\u001b[49m\u001b[43m(\u001b[49m\u001b[43minstruments\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mstart_time\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mend_time\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mfreq\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mas_list\u001b[49m\u001b[43m)\u001b[49m\n",
++      "\u001b[36mFile \u001b[39m\u001b[32md:\\project\\python\\tradenote\\.venv\\Lib\\site-packages\\qlib\\data\\data.py:719\u001b[39m, in \u001b[36mLocalInstrumentProvider.list_instruments\u001b[39m\u001b[34m(self, instruments, start_time, end_time, freq, as_list)\u001b[39m\n\u001b[32m    716\u001b[39m     \u001b[38;5;28;01mfrom\u001b[39;00m\u001b[38;5;250m \u001b[39m\u001b[34;01m.\u001b[39;00m\u001b[38;5;250m \u001b[39m\u001b[38;5;28;01mimport\u001b[39;00m \u001b[38;5;28mfilter\u001b[39m \u001b[38;5;28;01mas\u001b[39;00m F  \u001b[38;5;66;03m# pylint: disable=C0415\u001b[39;00m\n\u001b[32m    718\u001b[39m     filter_t = \u001b[38;5;28mgetattr\u001b[39m(F, filter_config[\u001b[33m\"\u001b[39m\u001b[33mfilter_type\u001b[39m\u001b[33m\"\u001b[39m]).from_config(filter_config)\n\u001b[32m--> \u001b[39m\u001b[32m719\u001b[39m     _instruments_filtered = \u001b[43mfilter_t\u001b[49m\u001b[43m(\u001b[49m\u001b[43m_instruments_filtered\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mstart_time\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mend_time\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mfreq\u001b[49m\u001b[43m)\u001b[49m\n\u001b[32m    720\u001b[39m \u001b[38;5;66;03m# as list\u001b[39;00m\n\u001b[32m    721\u001b[39m \u001b[38;5;28;01mif\u001b[39;00m as_list:\n",
++      "\u001b[36mFile \u001b[39m\u001b[32md:\\project\\python\\tradenote\\.venv\\Lib\\site-packages\\qlib\\data\\filter.py:192\u001b[39m, in \u001b[36mSeriesDFilter.__call__\u001b[39m\u001b[34m(self, instruments, start_time, end_time, freq)\u001b[39m\n\u001b[32m    190\u001b[39m \u001b[38;5;250m\u001b[39m\u001b[33;03m\"\"\"Call this filter to get filtered instruments list\"\"\"\u001b[39;00m\n\u001b[32m    191\u001b[39m \u001b[38;5;28mself\u001b[39m.filter_freq = freq\n\u001b[32m--> \u001b[39m\u001b[32m192\u001b[39m \u001b[38;5;28;01mreturn\u001b[39;00m \u001b[38;5;28;43mself\u001b[39;49m\u001b[43m.\u001b[49m\u001b[43mfilter_main\u001b[49m\u001b[43m(\u001b[49m\u001b[43minstruments\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mstart_time\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mend_time\u001b[49m\u001b[43m)\u001b[49m\n",
++      "\u001b[36mFile \u001b[39m\u001b[32md:\\project\\python\\tradenote\\.venv\\Lib\\site-packages\\qlib\\data\\filter.py:243\u001b[39m, in \u001b[36mSeriesDFilter.filter_main\u001b[39m\u001b[34m(self, instruments, start_time, end_time)\u001b[39m\n\u001b[32m    237\u001b[39m _all_calendar = Cal.calendar(start_time=start_time, end_time=end_time, freq=\u001b[38;5;28mself\u001b[39m.filter_freq)\n\u001b[32m    238\u001b[39m _filter_calendar = Cal.calendar(\n\u001b[32m    239\u001b[39m     start_time=\u001b[38;5;28mself\u001b[39m.filter_start_time \u001b[38;5;129;01mand\u001b[39;00m \u001b[38;5;28mmax\u001b[39m(\u001b[38;5;28mself\u001b[39m.filter_start_time, _all_calendar[\u001b[32m0\u001b[39m]) \u001b[38;5;129;01mor\u001b[39;00m _all_calendar[\u001b[32m0\u001b[39m],\n\u001b[32m    240\u001b[39m     end_time=\u001b[38;5;28mself\u001b[39m.filter_end_time \u001b[38;5;129;01mand\u001b[39;00m \u001b[38;5;28mmin\u001b[39m(\u001b[38;5;28mself\u001b[39m.filter_end_time, _all_calendar[-\u001b[32m1\u001b[39m]) \u001b[38;5;129;01mor\u001b[39;00m _all_calendar[-\u001b[32m1\u001b[39m],\n\u001b[32m    241\u001b[39m     freq=\u001b[38;5;28mself\u001b[39m.filter_freq,\n\u001b[32m    242\u001b[39m )\n\u001b[32m--> \u001b[39m\u001b[32m243\u001b[39m _all_filter_series = \u001b[38;5;28;43mself\u001b[39;49m\u001b[43m.\u001b[49m\u001b[43m_getFilterSeries\u001b[49m\u001b[43m(\u001b[49m\u001b[43minstruments\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43m_filter_calendar\u001b[49m\u001b[43m[\u001b[49m\u001b[32;43m0\u001b[39;49m\u001b[43m]\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43m_filter_calendar\u001b[49m\u001b[43m[\u001b[49m\u001b[43m-\u001b[49m\u001b[32;43m1\u001b[39;49m\u001b[43m]\u001b[49m\u001b[43m)\u001b[49m\n\u001b[32m    244\u001b[39m \u001b[38;5;28;01mfor\u001b[39;00m inst, timestamp \u001b[38;5;129;01min\u001b[39;00m instruments.items():\n\u001b[32m    245\u001b[39m     \u001b[38;5;66;03m# Construct a whole map of date\u001b[39;00m\n\u001b[32m    246\u001b[39m     _timestamp_series = \u001b[38;5;28mself\u001b[39m._toSeries(_all_calendar, timestamp)\n",
++      "\u001b[36mFile \u001b[39m\u001b[32md:\\project\\python\\tradenote\\.venv\\Lib\\site-packages\\qlib\\data\\filter.py:288\u001b[39m, in \u001b[36mNameDFilter._getFilterSeries\u001b[39m\u001b[34m(self, instruments, fstart, fend)\u001b[39m\n\u001b[32m    286\u001b[39m filter_calendar = Cal.calendar(start_time=fstart, end_time=fend, freq=\u001b[38;5;28mself\u001b[39m.filter_freq)\n\u001b[32m    287\u001b[39m \u001b[38;5;28;01mfor\u001b[39;00m inst, timestamp \u001b[38;5;129;01min\u001b[39;00m instruments.items():\n\u001b[32m--> \u001b[39m\u001b[32m288\u001b[39m     \u001b[38;5;28;01mif\u001b[39;00m \u001b[43mre\u001b[49m\u001b[43m.\u001b[49m\u001b[43mmatch\u001b[49m\u001b[43m(\u001b[49m\u001b[38;5;28;43mself\u001b[39;49m\u001b[43m.\u001b[49m\u001b[43mname_rule_re\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43minst\u001b[49m\u001b[43m)\u001b[49m:\n\u001b[32m    289\u001b[39m         _filter_series = pd.Series({timestamp: \u001b[38;5;28;01mTrue\u001b[39;00m \u001b[38;5;28;01mfor\u001b[39;00m timestamp \u001b[38;5;129;01min\u001b[39;00m filter_calendar})\n\u001b[32m    290\u001b[39m     \u001b[38;5;28;01melse\u001b[39;00m:\n",
++      "\u001b[36mFile \u001b[39m\u001b[32m~\\AppData\\Roaming\\uv\\python\\cpython-3.12.11-windows-x86_64-none\\Lib\\re\\__init__.py:167\u001b[39m, in \u001b[36mmatch\u001b[39m\u001b[34m(pattern, string, flags)\u001b[39m\n\u001b[32m    164\u001b[39m \u001b[38;5;28;01mdef\u001b[39;00m\u001b[38;5;250m \u001b[39m\u001b[34mmatch\u001b[39m(pattern, string, flags=\u001b[32m0\u001b[39m):\n\u001b[32m    165\u001b[39m \u001b[38;5;250m    \u001b[39m\u001b[33;03m\"\"\"Try to apply the pattern at the start of the string, returning\u001b[39;00m\n\u001b[32m    166\u001b[39m \u001b[33;03m    a Match object, or None if no match was found.\"\"\"\u001b[39;00m\n\u001b[32m--> \u001b[39m\u001b[32m167\u001b[39m     \u001b[38;5;28;01mreturn\u001b[39;00m \u001b[43m_compile\u001b[49m\u001b[43m(\u001b[49m\u001b[43mpattern\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mflags\u001b[49m\u001b[43m)\u001b[49m.match(string)\n",
++      "\u001b[36mFile \u001b[39m\u001b[32m~\\AppData\\Roaming\\uv\\python\\cpython-3.12.11-windows-x86_64-none\\Lib\\re\\__init__.py:307\u001b[39m, in \u001b[36m_compile\u001b[39m\u001b[34m(pattern, flags)\u001b[39m\n\u001b[32m    301\u001b[39m     \u001b[38;5;28;01mimport\u001b[39;00m\u001b[38;5;250m \u001b[39m\u001b[34;01mwarnings\u001b[39;00m\n\u001b[32m    302\u001b[39m     warnings.warn(\u001b[33m\"\u001b[39m\u001b[33mThe re.TEMPLATE/re.T flag is deprecated \u001b[39m\u001b[33m\"\u001b[39m\n\u001b[32m    303\u001b[39m             \u001b[33m\"\u001b[39m\u001b[33mas it is an undocumented flag \u001b[39m\u001b[33m\"\u001b[39m\n\u001b[32m    304\u001b[39m             \u001b[33m\"\u001b[39m\u001b[33mwithout an obvious purpose. \u001b[39m\u001b[33m\"\u001b[39m\n\u001b[32m    305\u001b[39m             \u001b[33m\"\u001b[39m\u001b[33mDon\u001b[39m\u001b[33m'\u001b[39m\u001b[33mt use it.\u001b[39m\u001b[33m\"\u001b[39m,\n\u001b[32m    306\u001b[39m             \u001b[38;5;167;01mDeprecationWarning\u001b[39;00m)\n\u001b[32m--> \u001b[39m\u001b[32m307\u001b[39m p = \u001b[43m_compiler\u001b[49m\u001b[43m.\u001b[49m\u001b[43mcompile\u001b[49m\u001b[43m(\u001b[49m\u001b[43mpattern\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mflags\u001b[49m\u001b[43m)\u001b[49m\n\u001b[32m    308\u001b[39m \u001b[38;5;28;01mif\u001b[39;00m flags & DEBUG:\n\u001b[32m    309\u001b[39m     \u001b[38;5;28;01mreturn\u001b[39;00m p\n",
++      "\u001b[36mFile \u001b[39m\u001b[32m~\\AppData\\Roaming\\uv\\python\\cpython-3.12.11-windows-x86_64-none\\Lib\\re\\_compiler.py:750\u001b[39m, in \u001b[36mcompile\u001b[39m\u001b[34m(p, flags)\u001b[39m\n\u001b[32m    748\u001b[39m \u001b[38;5;28;01mif\u001b[39;00m isstring(p):\n\u001b[32m    749\u001b[39m     pattern = p\n\u001b[32m--> \u001b[39m\u001b[32m750\u001b[39m     p = \u001b[43m_parser\u001b[49m\u001b[43m.\u001b[49m\u001b[43mparse\u001b[49m\u001b[43m(\u001b[49m\u001b[43mp\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mflags\u001b[49m\u001b[43m)\u001b[49m\n\u001b[32m    751\u001b[39m \u001b[38;5;28;01melse\u001b[39;00m:\n\u001b[32m    752\u001b[39m     pattern = \u001b[38;5;28;01mNone\u001b[39;00m\n",
++      "\u001b[36mFile \u001b[39m\u001b[32m~\\AppData\\Roaming\\uv\\python\\cpython-3.12.11-windows-x86_64-none\\Lib\\re\\_parser.py:979\u001b[39m, in \u001b[36mparse\u001b[39m\u001b[34m(str, flags, state)\u001b[39m\n\u001b[32m    976\u001b[39m state.flags = flags\n\u001b[32m    977\u001b[39m state.str = \u001b[38;5;28mstr\u001b[39m\n\u001b[32m--> \u001b[39m\u001b[32m979\u001b[39m p = \u001b[43m_parse_sub\u001b[49m\u001b[43m(\u001b[49m\u001b[43msource\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mstate\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mflags\u001b[49m\u001b[43m \u001b[49m\u001b[43m&\u001b[49m\u001b[43m \u001b[49m\u001b[43mSRE_FLAG_VERBOSE\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[32;43m0\u001b[39;49m\u001b[43m)\u001b[49m\n\u001b[32m    980\u001b[39m p.state.flags = fix_flags(\u001b[38;5;28mstr\u001b[39m, p.state.flags)\n\u001b[32m    982\u001b[39m \u001b[38;5;28;01mif\u001b[39;00m source.next \u001b[38;5;129;01mis\u001b[39;00m \u001b[38;5;129;01mnot\u001b[39;00m \u001b[38;5;28;01mNone\u001b[39;00m:\n",
++      "\u001b[36mFile \u001b[39m\u001b[32m~\\AppData\\Roaming\\uv\\python\\cpython-3.12.11-windows-x86_64-none\\Lib\\re\\_parser.py:460\u001b[39m, in \u001b[36m_parse_sub\u001b[39m\u001b[34m(source, state, verbose, nested)\u001b[39m\n\u001b[32m    458\u001b[39m start = source.tell()\n\u001b[32m    459\u001b[39m \u001b[38;5;28;01mwhile\u001b[39;00m \u001b[38;5;28;01mTrue\u001b[39;00m:\n\u001b[32m--> \u001b[39m\u001b[32m460\u001b[39m     itemsappend(\u001b[43m_parse\u001b[49m\u001b[43m(\u001b[49m\u001b[43msource\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mstate\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mverbose\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mnested\u001b[49m\u001b[43m \u001b[49m\u001b[43m+\u001b[49m\u001b[43m \u001b[49m\u001b[32;43m1\u001b[39;49m\u001b[43m,\u001b[49m\n\u001b[32m    461\u001b[39m \u001b[43m                       \u001b[49m\u001b[38;5;129;43;01mnot\u001b[39;49;00m\u001b[43m \u001b[49m\u001b[43mnested\u001b[49m\u001b[43m \u001b[49m\u001b[38;5;129;43;01mand\u001b[39;49;00m\u001b[43m \u001b[49m\u001b[38;5;129;43;01mnot\u001b[39;49;00m\u001b[43m \u001b[49m\u001b[43mitems\u001b[49m\u001b[43m)\u001b[49m)\n\u001b[32m    462\u001b[39m     \u001b[38;5;28;01mif\u001b[39;00m \u001b[38;5;129;01mnot\u001b[39;00m sourcematch(\u001b[33m\"\u001b[39m\u001b[33m|\u001b[39m\u001b[33m\"\u001b[39m):\n\u001b[32m    463\u001b[39m         \u001b[38;5;28;01mbreak\u001b[39;00m\n",
++      "\u001b[36mFile \u001b[39m\u001b[32m~\\AppData\\Roaming\\uv\\python\\cpython-3.12.11-windows-x86_64-none\\Lib\\re\\_parser.py:687\u001b[39m, in \u001b[36m_parse\u001b[39m\u001b[34m(source, state, verbose, nested, first)\u001b[39m\n\u001b[32m    685\u001b[39m     item = \u001b[38;5;28;01mNone\u001b[39;00m\n\u001b[32m    686\u001b[39m \u001b[38;5;28;01mif\u001b[39;00m \u001b[38;5;129;01mnot\u001b[39;00m item \u001b[38;5;129;01mor\u001b[39;00m item[\u001b[32m0\u001b[39m][\u001b[32m0\u001b[39m] \u001b[38;5;129;01mis\u001b[39;00m AT:\n\u001b[32m--> \u001b[39m\u001b[32m687\u001b[39m     \u001b[38;5;28;01mraise\u001b[39;00m source.error(\u001b[33m\"\u001b[39m\u001b[33mnothing to repeat\u001b[39m\u001b[33m\"\u001b[39m,\n\u001b[32m    688\u001b[39m                        source.tell() - here + \u001b[38;5;28mlen\u001b[39m(this))\n\u001b[32m    689\u001b[39m \u001b[38;5;28;01mif\u001b[39;00m item[\u001b[32m0\u001b[39m][\u001b[32m0\u001b[39m] \u001b[38;5;129;01min\u001b[39;00m _REPEATCODES:\n\u001b[32m    690\u001b[39m     \u001b[38;5;28;01mraise\u001b[39;00m source.error(\u001b[33m\"\u001b[39m\u001b[33mmultiple repeat\u001b[39m\u001b[33m\"\u001b[39m,\n\u001b[32m    691\u001b[39m                        source.tell() - here + \u001b[38;5;28mlen\u001b[39m(this))\n",
++      "\u001b[31merror\u001b[39m: nothing to repeat at position 0"
++     ]
++    }
++   ],
++   "source": [
++    "from qlib.data.filter import NameDFilter\n",
++    "nameDFilter = NameDFilter(name_rule_re='*000858')\n",
++    "instruments = D.instruments(market='all',filter_pipe=[nameDFilter])\n",
++    "D.list_instruments(instruments=instruments, start_time='2015-01-01', end_time='2016-02-15', as_list=True)\n"
+    ]
+   }
+  ],
+diff --git a/test/ma_cross_strategy.py b/test/ma_cross_strategy.py
+deleted file mode 100644
+index 719d849..0000000
+--- a/test/ma_cross_strategy.py
++++ /dev/null
+@@ -1,274 +0,0 @@
+-"""
+-均线交叉策略：金叉买入，死叉卖出
+-使用qlib框架实现
+-"""
+-
+-import qlib
+-from qlib.constant import REG_CN
+-from qlib.utils import init_instance_by_config
+-from qlib.workflow import R
+-from qlib.workflow.record_temp import SignalRecord, PortAnaRecord
+-from qlib.contrib.evaluate import backtest_daily
+-from qlib.contrib.strategy import TopkDropoutStrategy
+-import pandas as pd
+-import numpy as np
+-from typing import Dict, List, Tuple
+-
+-
+-class MACrossStrategy(TopkDropoutStrategy):
+-    """
+-    均线交叉策略
+-    金叉（短期均线上穿长期均线）买入
+-    死叉（短期均线下穿长期均线）卖出
+-    """
+-    
+-    def __init__(self, 
+-                 short_window: int = 5,
+-                 long_window: int = 20,
+-                 topk: int = 50,
+-                 n_drop: int = 5,
+-                 **kwargs):
+-        """
+-        初始化策略参数
+-        
+-        Args:
+-            short_window: 短期均线周期
+-            long_window: 长期均线周期
+-            topk: 选择前k只股票
+-            n_drop: 剔除前n只股票
+-        """
+-        super().__init__(topk=topk, n_drop=n_drop, **kwargs)
+-        self.short_window = short_window
+-        self.long_window = long_window
+-        
+-    def generate_trade_decision(self, score: pd.Series, trade_step: int) -> pd.Series:
+-        """
+-        生成交易决策
+-        
+-        Args:
+-            score: 股票评分
+-            trade_step: 交易步骤
+-            
+-        Returns:
+-            交易决策，1表示买入，-1表示卖出，0表示持有
+-        """
+-        # 获取当前持仓
+-        current_pos = self.get_current_position()
+-        
+-        # 计算均线信号
+-        signal = self._calculate_ma_signal(score.index.tolist(), trade_step)
+-        
+-        # 生成交易决策
+-        decision = pd.Series(0, index=score.index)
+-        
+-        # 金叉买入信号
+-        buy_signal = signal == 1
+-        decision[buy_signal] = 1
+-        
+-        # 死叉卖出信号
+-        sell_signal = signal == -1
+-        decision[sell_signal] = -1
+-        
+-        return decision
+-    
+-    def _calculate_ma_signal(self, instruments: List[str], trade_step: int) -> pd.Series:
+-        """
+-        计算均线交叉信号
+-        
+-        Args:
+-            instruments: 股票代码列表
+-            trade_step: 交易步骤
+-            
+-        Returns:
+-            信号序列：1表示金叉买入，-1表示死叉卖出，0表示无信号
+-        """
+-        # 获取历史数据
+-        data = self._get_historical_data(instruments, trade_step)
+-        
+-        signals = pd.Series(0, index=instruments)
+-        
+-        for instrument in instruments:
+-            if instrument in data.index:
+-                # 计算短期和长期均线
+-                short_ma = data.loc[instrument].rolling(window=self.short_window).mean()
+-                long_ma = data.loc[instrument].rolling(window=self.long_window).mean()
+-                
+-                # 计算交叉信号
+-                if len(short_ma) >= 2 and len(long_ma) >= 2:
+-                    # 当前和前一个时间点的均线差值
+-                    current_diff = short_ma.iloc[-1] - long_ma.iloc[-1]
+-                    prev_diff = short_ma.iloc[-2] - long_ma.iloc[-2]
+-                    
+-                    # 金叉：短期均线从下方穿越长期均线
+-                    if prev_diff < 0 and current_diff > 0:
+-                        signals[instrument] = 1
+-                    # 死叉：短期均线从上方穿越长期均线
+-                    elif prev_diff > 0 and current_diff < 0:
+-                        signals[instrument] = -1
+-        
+-        return signals
+-    
+-    def _get_historical_data(self, instruments: List[str], trade_step: int) -> pd.DataFrame:
+-        """
+-        获取历史价格数据
+-        
+-        Args:
+-            instruments: 股票代码列表
+-            trade_step: 交易步骤
+-            
+-        Returns:
+-            历史价格数据
+-        """
+-        # 这里简化处理，实际应该从qlib数据源获取
+-        # 在实际应用中，您需要使用qlib的数据接口
+-        try:
+-            # 获取最近的数据用于计算均线
+-            # 这里使用模拟数据，实际应该从qlib获取
+-            dates = pd.date_range(end=pd.Timestamp.now(), periods=50, freq='D')
+-            data = pd.DataFrame(
+-                np.random.randn(len(dates), len(instruments)) * 0.02 + 1.0,
+-                index=dates,
+-                columns=instruments
+-            )
+-            return data
+-        except Exception as e:
+-            print(f"获取历史数据失败: {e}")
+-            return pd.DataFrame()
+-
+-
+-def create_ma_cross_strategy_config():
+-    """
+-    创建均线交叉策略配置
+-    """
+-    strategy_config = {
+-        "class": "MACrossStrategy",
+-        "module_path": "test.ma_cross_strategy",
+-        "kwargs": {
+-            "short_window": 5,
+-            "long_window": 20,
+-            "topk": 50,
+-            "n_drop": 5,
+-        }
+-    }
+-    
+-    return strategy_config
+-
+-
+-def run_backtest():
+-    """
+-    运行回测
+-    """
+-    # 初始化qlib
+-    qlib.init(provider_uri='~/.qlib/qlib_data/cn_data', region=REG_CN)
+-    
+-    # 策略配置
+-    strategy_config = create_ma_cross_strategy_config()
+-    
+-    # 回测配置
+-    backtest_config = {
+-        "start_time": "2020-01-01",
+-        "end_time": "2023-12-31",
+-        "benchmark": "SH000300",  # 沪深300作为基准
+-        "account": 100000000,     # 初始资金1亿
+-        "exchange_kwargs": {
+-            "freq": "day",
+-            "limit_threshold": 0.095,
+-            "deal_price": "close",
+-            "open_cost": 0.0005,
+-            "close_cost": 0.0015,
+-            "min_cost": 5,
+-        }
+-    }
+-    
+-    # 创建策略实例
+-    strategy = init_instance_by_config(strategy_config)
+-    
+-    # 运行回测
+-    with R.start(experiment_name="ma_cross_strategy"):
+-        # 记录信号
+-        sr = SignalRecord(model=strategy, dataset=None, recorder=R.get_recorder())
+-        sr.generate()
+-        
+-        # 记录投资组合分析
+-        par = PortAnaRecord(recorder=R.get_recorder(), config=backtest_config, strategy=strategy)
+-        par.generate()
+-        
+-        # 获取回测结果
+-        report_normal, positions_normal = backtest_daily(
+-            account=backtest_config["account"],
+-            benchmark=backtest_config["benchmark"],
+-            start_time=backtest_config["start_time"],
+-            end_time=backtest_config["end_time"],
+-            strategy=strategy,
+-            exchange_kwargs=backtest_config["exchange_kwargs"]
+-        )
+-        
+-        return report_normal, positions_normal
+-
+-
+-def analyze_results(report: pd.DataFrame, positions: pd.DataFrame):
+-    """
+-    分析回测结果
+-    
+-    Args:
+-        report: 回测报告
+-        positions: 持仓信息
+-    """
+-    print("=" * 50)
+-    print("均线交叉策略回测结果")
+-    print("=" * 50)
+-    
+-    # 基本统计信息
+-    print(f"总收益率: {report['return'].sum():.2%}")
+-    print(f"年化收益率: {report['return'].mean() * 252:.2%}")
+-    print(f"最大回撤: {report['drawdown'].min():.2%}")
+-    print(f"夏普比率: {report['sharpe'].iloc[-1]:.2f}")
+-    print(f"胜率: {(report['return'] > 0).mean():.2%}")
+-    
+-    # 风险指标
+-    volatility = report['return'].std() * np.sqrt(252)
+-    print(f"年化波动率: {volatility:.2%}")
+-    
+-    # 最大回撤期间
+-    max_drawdown_idx = report['drawdown'].idxmin()
+-    print(f"最大回撤发生时间: {max_drawdown_idx}")
+-    
+-    # 收益分布
+-    print("\n收益分布统计:")
+-    print(f"平均日收益: {report['return'].mean():.2%}")
+-    print(f"收益标准差: {report['return'].std():.2%}")
+-    print(f"最小日收益: {report['return'].min():.2%}")
+-    print(f"最大日收益: {report['return'].max():.2%}")
+-    
+-    # 交易统计
+-    if 'trade_count' in report.columns:
+-        print(f"\n总交易次数: {report['trade_count'].sum()}")
+-        print(f"平均每日交易次数: {report['trade_count'].mean():.1f}")
+-
+-
+-def main():
+-    """
+-    主函数
+-    """
+-    print("开始运行均线交叉策略回测...")
+-    
+-    try:
+-        # 运行回测
+-        report, positions = run_backtest()
+-        
+-        # 分析结果
+-        analyze_results(report, positions)
+-        
+-        # 保存结果
+-        report.to_csv("ma_cross_strategy_report.csv")
+-        positions.to_csv("ma_cross_strategy_positions.csv")
+-        
+-        print("\n回测完成！结果已保存到CSV文件。")
+-        
+-    except Exception as e:
+-        print(f"回测过程中出现错误: {e}")
+-        print("请确保已正确安装qlib并下载了相应的数据。")
+-
+-
+-if __name__ == "__main__":
+-    main() 
+\ No newline at end of file
+diff --git a/test/ma_cross_strategy_improved.py b/test/ma_cross_strategy_improved.py
+deleted file mode 100644
+index d166c68..0000000
+--- a/test/ma_cross_strategy_improved.py
++++ /dev/null
+@@ -1,443 +0,0 @@
+-"""
+-改进的均线交叉策略：金叉买入，死叉卖出
+-使用qlib框架实现，包含完整的数据获取和信号计算
+-"""
+-
+-import qlib
+-from qlib.constant import REG_CN
+-from qlib.utils import init_instance_by_config
+-from qlib.workflow import R
+-from qlib.workflow.record_temp import SignalRecord, PortAnaRecord
+-from qlib.contrib.evaluate import backtest_daily
+-from qlib.contrib.strategy import TopkDropoutStrategy
+-from qlib.data import D
+-from qlib.data.dataset import DatasetH
+-from qlib.data.dataset.handler import DataHandlerLP
+-import pandas as pd
+-import numpy as np
+-from typing import Dict, List, Tuple
+-import warnings
+-warnings.filterwarnings('ignore')
+-
+-
+-class MACrossStrategyImproved(TopkDropoutStrategy):
+-    """
+-    改进的均线交叉策略
+-    金叉（短期均线上穿长期均线）买入
+-    死叉（短期均线下穿长期均线）卖出
+-    """
+-    
+-    def __init__(self, 
+-                 short_window: int = 5,
+-                 long_window: int = 20,
+-                 topk: int = 50,
+-                 n_drop: int = 5,
+-                 universe: str = "csi300",
+-                 **kwargs):
+-        """
+-        初始化策略参数
+-        
+-        Args:
+-            short_window: 短期均线周期
+-            long_window: 长期均线周期
+-            topk: 选择前k只股票
+-            n_drop: 剔除前n只股票
+-            universe: 股票池
+-        """
+-        super().__init__(topk=topk, n_drop=n_drop, **kwargs)
+-        self.short_window = short_window
+-        self.long_window = long_window
+-        self.universe = universe
+-        self.instruments = None
+-        self.price_cache = {}
+-        
+-    def generate_trade_decision(self, score: pd.Series, trade_step: int) -> pd.Series:
+-        """
+-        生成交易决策
+-        
+-        Args:
+-            score: 股票评分
+-            trade_step: 交易步骤
+-            
+-        Returns:
+-            交易决策，1表示买入，-1表示卖出，0表示持有
+-        """
+-        # 获取当前持仓
+-        current_pos = self.get_current_position()
+-        
+-        # 计算均线信号
+-        signal = self._calculate_ma_signal(score.index.tolist(), trade_step)
+-        
+-        # 生成交易决策
+-        decision = pd.Series(0, index=score.index)
+-        
+-        # 金叉买入信号
+-        buy_signal = signal == 1
+-        decision[buy_signal] = 1
+-        
+-        # 死叉卖出信号
+-        sell_signal = signal == -1
+-        decision[sell_signal] = -1
+-        
+-        return decision
+-    
+-    def _calculate_ma_signal(self, instruments: List[str], trade_step: int) -> pd.Series:
+-        """
+-        计算均线交叉信号
+-        
+-        Args:
+-            instruments: 股票代码列表
+-            trade_step: 交易步骤
+-            
+-        Returns:
+-            信号序列：1表示金叉买入，-1表示死叉卖出，0表示无信号
+-        """
+-        signals = pd.Series(0, index=instruments)
+-        
+-        # 获取当前日期
+-        current_date = self._get_current_date(trade_step)
+-        
+-        for instrument in instruments:
+-            try:
+-                # 获取历史价格数据
+-                price_data = self._get_price_data(instrument, current_date)
+-                
+-                if price_data is not None and len(price_data) >= self.long_window:
+-                    # 计算短期和长期均线
+-                    short_ma = price_data['close'].rolling(window=self.short_window).mean()
+-                    long_ma = price_data['close'].rolling(window=self.long_window).mean()
+-                    
+-                    # 计算交叉信号
+-                    if len(short_ma) >= 2 and len(long_ma) >= 2:
+-                        # 当前和前一个时间点的均线差值
+-                        current_diff = short_ma.iloc[-1] - long_ma.iloc[-1]
+-                        prev_diff = short_ma.iloc[-2] - long_ma.iloc[-2]
+-                        
+-                        # 金叉：短期均线从下方穿越长期均线
+-                        if prev_diff < 0 and current_diff > 0:
+-                            signals[instrument] = 1
+-                        # 死叉：短期均线从上方穿越长期均线
+-                        elif prev_diff > 0 and current_diff < 0:
+-                            signals[instrument] = -1
+-                            
+-            except Exception as e:
+-                print(f"计算{instrument}均线信号时出错: {e}")
+-                continue
+-        
+-        return signals
+-    
+-    def _get_price_data(self, instrument: str, current_date: str) -> pd.DataFrame:
+-        """
+-        获取股票价格数据
+-        
+-        Args:
+-            instrument: 股票代码
+-            current_date: 当前日期
+-            
+-        Returns:
+-            价格数据DataFrame
+-        """
+-        try:
+-            # 计算开始日期（获取足够的历史数据来计算均线）
+-            start_date = pd.Timestamp(current_date) - pd.Timedelta(days=self.long_window * 2)
+-            
+-            # 从qlib获取数据
+-            data = D.features(
+-                instruments=[instrument],
+-                start_time=start_date.strftime('%Y-%m-%d'),
+-                end_time=current_date,
+-                freq='day',
+-                fields=['$close', '$open', '$high', '$low', '$volume']
+-            )
+-            
+-            if data is not None and not data.empty:
+-                # 重命名列
+-                data.columns = ['close', 'open', 'high', 'low', 'volume']
+-                return data
+-            else:
+-                return None
+-                
+-        except Exception as e:
+-            print(f"获取{instrument}价格数据失败: {e}")
+-            return None
+-    
+-    def _get_current_date(self, trade_step: int) -> str:
+-        """
+-        根据交易步骤获取当前日期
+-        
+-        Args:
+-            trade_step: 交易步骤
+-            
+-        Returns:
+-            当前日期字符串
+-        """
+-        # 这里简化处理，实际应该从qlib的日历获取
+-        # 假设从2020-01-01开始，每个trade_step代表一天
+-        start_date = pd.Timestamp('2020-01-01')
+-        current_date = start_date + pd.Timedelta(days=trade_step)
+-        return current_date.strftime('%Y-%m-%d')
+-
+-
+-def create_dataset_config():
+-    """
+-    创建数据集配置
+-    """
+-    dataset_config = {
+-        "class": "DatasetH",
+-        "module_path": "qlib.data.dataset",
+-        "kwargs": {
+-            "handler": {
+-                "class": "DataHandlerLP",
+-                "module_path": "qlib.data.dataset.handler",
+-                "kwargs": {
+-                    "start_time": "2020-01-01",
+-                    "end_time": "2023-12-31",
+-                    "fit_start_time": "2020-01-01",
+-                    "fit_end_time": "2023-12-31",
+-                    "instruments": "csi300",
+-                    "infer_processors": [
+-                        {
+-                            "class": "RobustZScoreNorm",
+-                            "module_path": "qlib.data.dataset.processor",
+-                            "kwargs": {
+-                                "fields_group": "feature",
+-                                "clip_outlier": True,
+-                            },
+-                        },
+-                        {
+-                            "class": "Fillna",
+-                            "module_path": "qlib.data.dataset.processor",
+-                            "kwargs": {
+-                                "fields_group": "feature",
+-                            },
+-                        },
+-                    ],
+-                    "learn_processors": [
+-                        {
+-                            "class": "DropnaLabel",
+-                            "module_path": "qlib.data.dataset.processor",
+-                        },
+-                        {
+-                            "class": "CSRankNorm",
+-                            "module_path": "qlib.data.dataset.processor",
+-                            "kwargs": {
+-                                "fields_group": "label",
+-                            },
+-                        },
+-                    ],
+-                    "instruments": "csi300",
+-                },
+-            },
+-            "segments": {
+-                "train": ("2020-01-01", "2022-12-31"),
+-                "valid": ("2023-01-01", "2023-06-30"),
+-                "test": ("2023-07-01", "2023-12-31"),
+-            },
+-        },
+-    }
+-    
+-    return dataset_config
+-
+-
+-def create_ma_cross_strategy_config():
+-    """
+-    创建均线交叉策略配置
+-    """
+-    strategy_config = {
+-        "class": "MACrossStrategyImproved",
+-        "module_path": "test.ma_cross_strategy_improved",
+-        "kwargs": {
+-            "short_window": 5,
+-            "long_window": 20,
+-            "topk": 50,
+-            "n_drop": 5,
+-            "universe": "csi300",
+-        }
+-    }
+-    
+-    return strategy_config
+-
+-
+-def run_backtest():
+-    """
+-    运行回测
+-    """
+-    # 初始化qlib
+-    qlib.init(provider_uri='~/.qlib/qlib_data/cn_data', region=REG_CN)
+-    
+-    # 策略配置
+-    strategy_config = create_ma_cross_strategy_config()
+-    
+-    # 回测配置
+-    backtest_config = {
+-        "start_time": "2020-01-01",
+-        "end_time": "2023-12-31",
+-        "benchmark": "SH000300",  # 沪深300作为基准
+-        "account": 100000000,     # 初始资金1亿
+-        "exchange_kwargs": {
+-            "freq": "day",
+-            "limit_threshold": 0.095,
+-            "deal_price": "close",
+-            "open_cost": 0.0005,
+-            "close_cost": 0.0015,
+-            "min_cost": 5,
+-        }
+-    }
+-    
+-    # 创建策略实例
+-    strategy = init_instance_by_config(strategy_config)
+-    
+-    # 运行回测
+-    with R.start(experiment_name="ma_cross_strategy_improved"):
+-        # 记录信号
+-        sr = SignalRecord(model=strategy, dataset=None, recorder=R.get_recorder())
+-        sr.generate()
+-        
+-        # 记录投资组合分析
+-        par = PortAnaRecord(recorder=R.get_recorder(), config=backtest_config, strategy=strategy)
+-        par.generate()
+-        
+-        # 获取回测结果
+-        report_normal, positions_normal = backtest_daily(
+-            account=backtest_config["account"],
+-            benchmark=backtest_config["benchmark"],
+-            start_time=backtest_config["start_time"],
+-            end_time=backtest_config["end_time"],
+-            strategy=strategy,
+-            exchange_kwargs=backtest_config["exchange_kwargs"]
+-        )
+-        
+-        return report_normal, positions_normal
+-
+-
+-def analyze_results(report: pd.DataFrame, positions: pd.DataFrame):
+-    """
+-    分析回测结果
+-    
+-    Args:
+-        report: 回测报告
+-        positions: 持仓信息
+-    """
+-    print("=" * 50)
+-    print("均线交叉策略回测结果")
+-    print("=" * 50)
+-    
+-    # 基本统计信息
+-    print(f"总收益率: {report['return'].sum():.2%}")
+-    print(f"年化收益率: {report['return'].mean() * 252:.2%}")
+-    print(f"最大回撤: {report['drawdown'].min():.2%}")
+-    
+-    if 'sharpe' in report.columns:
+-        print(f"夏普比率: {report['sharpe'].iloc[-1]:.2f}")
+-    
+-    print(f"胜率: {(report['return'] > 0).mean():.2%}")
+-    
+-    # 风险指标
+-    volatility = report['return'].std() * np.sqrt(252)
+-    print(f"年化波动率: {volatility:.2%}")
+-    
+-    # 最大回撤期间
+-    max_drawdown_idx = report['drawdown'].idxmin()
+-    print(f"最大回撤发生时间: {max_drawdown_idx}")
+-    
+-    # 收益分布
+-    print("\n收益分布统计:")
+-    print(f"平均日收益: {report['return'].mean():.2%}")
+-    print(f"收益标准差: {report['return'].std():.2%}")
+-    print(f"最小日收益: {report['return'].min():.2%}")
+-    print(f"最大日收益: {report['return'].max():.2%}")
+-    
+-    # 交易统计
+-    if 'trade_count' in report.columns:
+-        print(f"\n总交易次数: {report['trade_count'].sum()}")
+-        print(f"平均每日交易次数: {report['trade_count'].mean():.1f}")
+-
+-
+-def create_simple_backtest():
+-    """
+-    创建简化版回测，用于演示
+-    """
+-    print("创建简化版均线交叉策略回测...")
+-    
+-    # 初始化qlib
+-    qlib.init(provider_uri='~/.qlib/qlib_data/cn_data', region=REG_CN)
+-    
+-    # 获取股票列表
+-    instruments = D.list_instruments(instruments="csi300", start_time="2020-01-01", end_time="2023-12-31")
+-    
+-    print(f"获取到 {len(instruments)} 只股票")
+-    
+-    # 选择前10只股票进行演示
+-    demo_instruments = instruments[:10]
+-    
+-    # 获取价格数据
+-    data = D.features(
+-        instruments=demo_instruments,
+-        start_time="2020-01-01",
+-        end_time="2023-12-31",
+-        freq='day',
+-        fields=['$close']
+-    )
+-    
+-    print(f"获取到价格数据，形状: {data.shape}")
+-    
+-    # 计算均线
+-    short_ma = data.rolling(window=5).mean()
+-    long_ma = data.rolling(window=20).mean()
+-    
+-    # 计算交叉信号
+-    signals = pd.DataFrame(0, index=data.index, columns=data.columns)
+-    
+-    for col in data.columns:
+-        # 计算均线差值
+-        diff = short_ma[col] - long_ma[col]
+-        
+-        # 计算交叉信号
+-        for i in range(1, len(diff)):
+-            if diff.iloc[i-1] < 0 and diff.iloc[i] > 0:
+-                signals.iloc[i, signals.columns.get_loc(col)] = 1  # 金叉买入
+-            elif diff.iloc[i-1] > 0 and diff.iloc[i] < 0:
+-                signals.iloc[i, signals.columns.get_loc(col)] = -1  # 死叉卖出
+-    
+-    # 统计信号
+-    buy_signals = (signals == 1).sum().sum()
+-    sell_signals = (signals == -1).sum().sum()
+-    
+-    print(f"\n信号统计:")
+-    print(f"买入信号数量: {buy_signals}")
+-    print(f"卖出信号数量: {sell_signals}")
+-    
+-    # 计算简单收益（假设每次信号都产生1%的收益）
+-    returns = signals * 0.01
+-    cumulative_returns = returns.sum(axis=1).cumsum()
+-    
+-    print(f"\n累计收益: {cumulative_returns.iloc[-1]:.2%}")
+-    
+-    return signals, cumulative_returns
+-
+-
+-def main():
+-    """
+-    主函数
+-    """
+-    print("开始运行均线交叉策略回测...")
+-    
+-    try:
+-        # 运行简化版回测
+-        signals, cumulative_returns = create_simple_backtest()
+-        
+-        # 保存简化版结果
+-        signals.to_csv("ma_cross_signals.csv")
+-        cumulative_returns.to_csv("ma_cross_cumulative_returns.csv")
+-        
+-        print("\n简化版回测完成！")
+-        print("信号数据已保存到 ma_cross_signals.csv")
+-        print("累计收益已保存到 ma_cross_cumulative_returns.csv")
+-        
+-    except Exception as e:
+-        print(f"回测过程中出现错误: {e}")
+-        print("请确保已正确安装qlib并下载了相应的数据。")
+-
+-
+-if __name__ == "__main__":
+-    main() 
+\ No newline at end of file
+diff --git a/test/ma_strategy_demo.py b/test/ma_strategy_demo.py
+deleted file mode 100644
+index 1fa4fb4..0000000
+Binary files a/test/ma_strategy_demo.py and /dev/null differ
+diff --git a/test/simple_ma_strategy.py b/test/simple_ma_strategy.py
+deleted file mode 100644
+index 8d03f6b..0000000
+--- a/test/simple_ma_strategy.py
++++ /dev/null
+@@ -1,298 +0,0 @@
+-"""
+-简单实用的均线交叉策略
+-金叉买入，死叉卖出
+-"""
+-
+-import qlib
+-from qlib.constant import REG_CN
+-from qlib.data import D
+-import pandas as pd
+-import numpy as np
+-import matplotlib.pyplot as plt
+-from datetime import datetime, timedelta
+-
+-
+-def init_qlib():
+-    """初始化qlib"""
+-    try:
+-        qlib.init(provider_uri='~/.qlib/qlib_data/cn_data', region=REG_CN)
+-        print("qlib初始化成功")
+-        return True
+-    except Exception as e:
+-        print(f"qlib初始化失败: {e}")
+-        print("请确保已安装qlib并下载了数据")
+-        return False
+-
+-
+-def get_stock_data(instruments, start_date, end_date):
+-    """
+-    获取股票数据
+-    
+-    Args:
+-        instruments: 股票代码列表
+-        start_date: 开始日期
+-        end_date: 结束日期
+-    
+-    Returns:
+-        股票价格数据
+-    """
+-    try:
+-        data = D.features(
+-            instruments=instruments,
+-            start_time=start_date,
+-            end_time=end_date,
+-            freq='day',
+-            fields=['$close', '$open', '$high', '$low', '$volume']
+-        )
+-        
+-        if data is not None and not data.empty:
+-            # 重命名列
+-            data.columns = ['close', 'open', 'high', 'low', 'volume']
+-            return data
+-        else:
+-            print("未获取到数据")
+-            return None
+-            
+-    except Exception as e:
+-        print(f"获取数据失败: {e}")
+-        return None
+-
+-
+-def calculate_ma_signals(data, short_window=5, long_window=20):
+-    """
+-    计算均线交叉信号
+-    
+-    Args:
+-        data: 价格数据
+-        short_window: 短期均线周期
+-        long_window: 长期均线周期
+-    
+-    Returns:
+-        信号DataFrame，1表示买入，-1表示卖出，0表示无信号
+-    """
+-    signals = pd.DataFrame(0, index=data.index, columns=data.columns)
+-    
+-    for col in data.columns:
+-        if col == 'close':
+-            continue
+-            
+-        # 计算均线
+-        short_ma = data[col].rolling(window=short_window).mean()
+-        long_ma = data[col].rolling(window=long_window).mean()
+-        
+-        # 计算均线差值
+-        diff = short_ma - long_ma
+-        
+-        # 计算交叉信号
+-        for i in range(1, len(diff)):
+-            if pd.notna(diff.iloc[i-1]) and pd.notna(diff.iloc[i]):
+-                # 金叉：短期均线从下方穿越长期均线
+-                if diff.iloc[i-1] < 0 and diff.iloc[i] > 0:
+-                    signals.iloc[i, signals.columns.get_loc(col)] = 1
+-                # 死叉：短期均线从上方穿越长期均线
+-                elif diff.iloc[i-1] > 0 and diff.iloc[i] < 0:
+-                    signals.iloc[i, signals.columns.get_loc(col)] = -1
+-    
+-    return signals
+-
+-
+-def calculate_returns(data, signals, initial_capital=100000):
+-    """
+-    计算策略收益
+-    
+-    Args:
+-        data: 价格数据
+-        signals: 信号数据
+-        initial_capital: 初始资金
+-    
+-    Returns:
+-        收益数据
+-    """
+-    # 计算日收益率
+-    returns = data.pct_change()
+-    
+-    # 策略收益（假设每次信号产生1%的收益）
+-    strategy_returns = signals * 0.01
+-    
+-    # 累计收益
+-    cumulative_returns = strategy_returns.sum(axis=1).cumsum()
+-    
+-    # 资金曲线
+-    capital_curve = initial_capital * (1 + cumulative_returns)
+-    
+-    return {
+-        'strategy_returns': strategy_returns,
+-        'cumulative_returns': cumulative_returns,
+-        'capital_curve': capital_curve
+-    }
+-
+-
+-def analyze_strategy(signals, returns_data):
+-    """
+-    分析策略表现
+-    
+-    Args:
+-        signals: 信号数据
+-        returns_data: 收益数据
+-    """
+-    print("=" * 50)
+-    print("均线交叉策略分析结果")
+-    print("=" * 50)
+-    
+-    # 信号统计
+-    buy_signals = (signals == 1).sum().sum()
+-    sell_signals = (signals == -1).sum().sum()
+-    
+-    print(f"买入信号数量: {buy_signals}")
+-    print(f"卖出信号数量: {sell_signals}")
+-    print(f"总信号数量: {buy_signals + sell_signals}")
+-    
+-    # 收益统计
+-    cumulative_returns = returns_data['cumulative_returns']
+-    capital_curve = returns_data['capital_curve']
+-    
+-    total_return = cumulative_returns.iloc[-1]
+-    annual_return = total_return / (len(cumulative_returns) / 252)
+-    
+-    print(f"\n收益统计:")
+-    print(f"总收益率: {total_return:.2%}")
+-    print(f"年化收益率: {annual_return:.2%}")
+-    print(f"最终资金: {capital_curve.iloc[-1]:,.0f}")
+-    
+-    # 风险统计
+-    daily_returns = returns_data['strategy_returns'].sum(axis=1)
+-    volatility = daily_returns.std() * np.sqrt(252)
+-    sharpe_ratio = annual_return / volatility if volatility > 0 else 0
+-    
+-    print(f"\n风险统计:")
+-    print(f"年化波动率: {volatility:.2%}")
+-    print(f"夏普比率: {sharpe_ratio:.2f}")
+-    print(f"胜率: {(daily_returns > 0).mean():.2%}")
+-
+-
+-def plot_results(data, signals, returns_data, stock_code):
+-    """
+-    绘制结果图表
+-    
+-    Args:
+-        data: 价格数据
+-        signals: 信号数据
+-        returns_data: 收益数据
+-        stock_code: 股票代码
+-    """
+-    fig, axes = plt.subplots(3, 1, figsize=(12, 10))
+-    
+-    # 绘制价格和均线
+-    axes[0].plot(data.index, data[stock_code], label='收盘价', alpha=0.7)
+-    short_ma = data[stock_code].rolling(window=5).mean()
+-    long_ma = data[stock_code].rolling(window=20).mean()
+-    axes[0].plot(data.index, short_ma, label='5日均线', alpha=0.8)
+-    axes[0].plot(data.index, long_ma, label='20日均线', alpha=0.8)
+-    
+-    # 标记买卖信号
+-    buy_signals = signals[stock_code] == 1
+-    sell_signals = signals[stock_code] == -1
+-    
+-    axes[0].scatter(data.index[buy_signals], data.loc[buy_signals, stock_code], 
+-                   color='red', marker='^', s=100, label='买入信号', alpha=0.8)
+-    axes[0].scatter(data.index[sell_signals], data.loc[sell_signals, stock_code], 
+-                   color='green', marker='v', s=100, label='卖出信号', alpha=0.8)
+-    
+-    axes[0].set_title(f'{stock_code} 价格走势与均线交叉信号')
+-    axes[0].legend()
+-    axes[0].grid(True, alpha=0.3)
+-    
+-    # 绘制累计收益
+-    axes[1].plot(returns_data['cumulative_returns'].index, 
+-                returns_data['cumulative_returns'].values, 
+-                label='累计收益', color='blue')
+-    axes[1].set_title('策略累计收益')
+-    axes[1].legend()
+-    axes[1].grid(True, alpha=0.3)
+-    
+-    # 绘制资金曲线
+-    axes[2].plot(returns_data['capital_curve'].index, 
+-                returns_data['capital_curve'].values, 
+-                label='资金曲线', color='green')
+-    axes[2].set_title('资金曲线')
+-    axes[2].legend()
+-    axes[2].grid(True, alpha=0.3)
+-    
+-    plt.tight_layout()
+-    plt.savefig('ma_cross_strategy_results.png', dpi=300, bbox_inches='tight')
+-    plt.show()
+-
+-
+-def main():
+-    """
+-    主函数
+-    """
+-    print("开始运行均线交叉策略...")
+-    
+-    # 初始化qlib
+-    if not init_qlib():
+-        return
+-    
+-    # 策略参数
+-    start_date = "2020-01-01"
+-    end_date = "2023-12-31"
+-    short_window = 5
+-    long_window = 20
+-    initial_capital = 100000
+-    
+-    # 获取股票列表
+-    try:
+-        instruments = D.list_instruments(instruments="csi300", start_time=start_date, end_time=end_date)
+-        print(f"获取到 {len(instruments)} 只股票")
+-        
+-        # 选择前5只股票进行演示
+-        demo_instruments = instruments[:5]
+-        print(f"选择演示股票: {demo_instruments}")
+-        
+-    except Exception as e:
+-        print(f"获取股票列表失败: {e}")
+-        # 使用默认股票列表
+-        demo_instruments = ['000001.SZ', '000002.SZ', '000858.SZ', '002415.SZ', '600036.SH']
+-        print(f"使用默认股票列表: {demo_instruments}")
+-    
+-    # 获取价格数据
+-    data = get_stock_data(demo_instruments, start_date, end_date)
+-    
+-    if data is None:
+-        print("无法获取数据，程序退出")
+-        return
+-    
+-    print(f"获取到价格数据，形状: {data.shape}")
+-    
+-    # 计算均线信号
+-    signals = calculate_ma_signals(data, short_window, long_window)
+-    
+-    # 计算收益
+-    returns_data = calculate_returns(data, signals, initial_capital)
+-    
+-    # 分析策略
+-    analyze_strategy(signals, returns_data)
+-    
+-    # 保存结果
+-    signals.to_csv("ma_cross_signals.csv")
+-    returns_data['cumulative_returns'].to_csv("ma_cross_cumulative_returns.csv")
+-    returns_data['capital_curve'].to_csv("ma_cross_capital_curve.csv")
+-    
+-    print("\n结果已保存到CSV文件:")
+-    print("- ma_cross_signals.csv: 买卖信号")
+-    print("- ma_cross_cumulative_returns.csv: 累计收益")
+-    print("- ma_cross_capital_curve.csv: 资金曲线")
+-    
+-    # 绘制图表（选择第一只股票）
+-    if len(demo_instruments) > 0:
+-        try:
+-            plot_results(data, signals, returns_data, demo_instruments[0])
+-            print("图表已保存为 ma_cross_strategy_results.png")
+-        except Exception as e:
+-            print(f"绘制图表失败: {e}")
+-    
+-    print("\n策略回测完成！")
+-
+-
+-if __name__ == "__main__":
+-    main() 
+\ No newline at end of file
+diff --git a/test/two_ema_stragety.py b/test/two_ema_stragety.py
+index a72e7e8..a9890c7 100644
+--- a/test/two_ema_stragety.py
++++ b/test/two_ema_stragety.py
+@@ -1,2 +1,98 @@
+-from qlib.contrib.strategy import 
+-from qlib.backtest import backtest
+\ No newline at end of file
++import pandas as pd
++
++from abc import ABC
++from typing import Dict, List, Text, Tuple, Union
++from qlib.data.dataset import Dataset
++from qlib.model.base import BaseModel
++from qlib.backtest.signal import Signal, create_signal_from
++from qlib.strategy.base import BaseStrategy
++from qlib.backtest.decision import Order, OrderDir, OrderHelper, TradeDecisionWO
++# from qlib.strategy import 
++# from qlib.backtest import backtest
++
++class InnerStrategy(BaseStrategy):
++    """
++    Inner strategy for order execution:
++    - Buy: if price < 200, buy all cash; else buy 200,000 worth.
++    - Sell: if price > 200, sell all; else sell half.
++    """
++    STOCK_CODE = "000858.SZ"
++
++    def generate_trade_decision(self, execute_result: list = None, action: str = None, amount: float = None):
++        # action: 'buy' or 'sell', amount: suggested amount (shares) from outer
++        position = self.trade_position
++        trade_step = self.trade_calendar.get_trade_step()
++        trade_start_time, trade_end_time = self.trade_calendar.get_step_time(trade_step)
++        order_helper = self.trade_exchange.get_order_helper()
++        orders = []
++        price = self.trade_exchange.get_deal_price(self.STOCK_CODE, trade_start_time, trade_end_time)
++        if action == 'buy':
++            cash = position.get_cash()
++            if price <= 0:
++                return TradeDecisionWO([], self)
++            if price < 200:
++                buy_amount = cash // price
++            else:
++                buy_amount = min(cash // price, 200000 // price)
++            buy_amount = int(buy_amount)
++            if buy_amount > 0:
++                order = order_helper.create(
++                    code=self.STOCK_CODE,
++                    amount=buy_amount,
++                    direction=OrderDir.BUY,
++                    start_time=trade_start_time,
++                    end_time=trade_end_time,
++                )
++                orders.append(order)
++        elif action == 'sell':
++            held_amount = position.get_stock_amount(self.STOCK_CODE)
++            if held_amount <= 0 or price <= 0:
++                return TradeDecisionWO([], self)
++            if price > 200:
++                sell_amount = held_amount
++            else:
++                sell_amount = held_amount // 2
++            sell_amount = int(sell_amount)
++            if sell_amount > 0:
++                order = order_helper.create(
++                    code=self.STOCK_CODE,
++                    amount=sell_amount,
++                    direction=OrderDir.SELL,
++                    start_time=trade_start_time,
++                    end_time=trade_end_time,
++                )
++                orders.append(order)
++        return TradeDecisionWO(orders, self)
++
++class OuterStrategy(BaseStrategy):
++    """
++    Outer strategy:
++    - If not holding Wuliangye, issues a buy order via inner strategy.
++    - If holding, checks if held for 25 days, if so, issues a sell order via inner strategy.
++    - Otherwise, holds.
++    """
++    STOCK_CODE = "000858.SZ"
++    HOLD_DAYS = 25
++    BAR = "day"
++
++    def __init__(self, *args, **kwargs):
++        super().__init__(*args, **kwargs)
++        self.inner_strategy = InnerStrategy()
++
++    def generate_trade_decision(self, execute_result: list = None):
++        position = self.trade_position
++        stock_list = position.get_stock_list()
++        trade_step = self.trade_calendar.get_trade_step()
++        trade_start_time, trade_end_time = self.trade_calendar.get_step_time(trade_step)
++        # Pass infra to inner strategy
++        self.inner_strategy.reset(level_infra=self.level_infra, common_infra=self.common_infra)
++        if self.STOCK_CODE in stock_list:
++            hold_days = position.get_stock_count(self.STOCK_CODE, self.BAR)
++            if hold_days >= self.HOLD_DAYS:
++                # Sell via inner strategy
++                return self.inner_strategy.generate_trade_decision(action='sell')
++        else:
++            # Buy via inner strategy
++            return self.inner_strategy.generate_trade_decision(action='buy')
++        # Otherwise, hold
++        return TradeDecisionWO([], self)
+\ No newline at end of file
diff --git a/mlruns/812028854715931404/1dca43fd8d16419688b3de890200d985/artifacts/code_status.txt b/mlruns/812028854715931404/1dca43fd8d16419688b3de890200d985/artifacts/code_status.txt
new file mode 100644
index 0000000..d9b6458
--- /dev/null
+++ b/mlruns/812028854715931404/1dca43fd8d16419688b3de890200d985/artifacts/code_status.txt
@@ -0,0 +1,25 @@
+On branch main
+Your branch is up to date with 'origin/main'.
+
+Changes not staged for commit:
+  (use "git add/rm <file>..." to update what will be committed)
+  (use "git restore <file>..." to discard changes in working directory)
+	modified:   github/examples/benchmarks/LightGBM/workflow_config_lightgbm_Alpha1582.yaml
+	deleted:    test/README_MA_Strategy.md
+	modified:   test/damo1.py
+	modified:   test/demo2.ipynb
+	deleted:    test/ma_cross_strategy.py
+	deleted:    test/ma_cross_strategy_improved.py
+	deleted:    test/ma_strategy_demo.py
+	deleted:    test/simple_ma_strategy.py
+	modified:   test/two_ema_stragety.py
+
+Untracked files:
+  (use "git add <file>..." to include in what will be committed)
+	github/examples/mlruns/881301994755452456/157579a2201241aaafcff94e93d7da0e/
+	mlruns/
+	test/__pycache__/
+	test/buy_and_hold.py
+	test/workflow_by_code.py
+
+no changes added to commit (use "git add" and/or "git commit -a")
diff --git a/mlruns/812028854715931404/1dca43fd8d16419688b3de890200d985/meta.yaml b/mlruns/812028854715931404/1dca43fd8d16419688b3de890200d985/meta.yaml
new file mode 100644
index 0000000..5095fa1
--- /dev/null
+++ b/mlruns/812028854715931404/1dca43fd8d16419688b3de890200d985/meta.yaml
@@ -0,0 +1,14 @@
+artifact_uri: file:D:\project\python\tradenote\mlruns/812028854715931404/1dca43fd8d16419688b3de890200d985/artifacts
+end_time: 1750319911945
+entry_point_name: ''
+experiment_id: '812028854715931404'
+lifecycle_stage: active
+run_id: 1dca43fd8d16419688b3de890200d985
+run_name: mlflow_recorder
+source_name: ''
+source_type: 4
+source_version: ''
+start_time: 1750319911725
+status: 3
+tags: []
+user_id: abulimity
diff --git a/mlruns/812028854715931404/1dca43fd8d16419688b3de890200d985/params/cmd-sys.argv b/mlruns/812028854715931404/1dca43fd8d16419688b3de890200d985/params/cmd-sys.argv
new file mode 100644
index 0000000..db800eb
--- /dev/null
+++ b/mlruns/812028854715931404/1dca43fd8d16419688b3de890200d985/params/cmd-sys.argv
@@ -0,0 +1 @@
+D:\project\python\tradenote\test\workflow_by_code.py
\ No newline at end of file
diff --git a/mlruns/812028854715931404/1dca43fd8d16419688b3de890200d985/tags/mlflow.runName b/mlruns/812028854715931404/1dca43fd8d16419688b3de890200d985/tags/mlflow.runName
new file mode 100644
index 0000000..25487e4
--- /dev/null
+++ b/mlruns/812028854715931404/1dca43fd8d16419688b3de890200d985/tags/mlflow.runName
@@ -0,0 +1 @@
+mlflow_recorder
\ No newline at end of file
diff --git a/mlruns/812028854715931404/1dca43fd8d16419688b3de890200d985/tags/mlflow.source.git.commit b/mlruns/812028854715931404/1dca43fd8d16419688b3de890200d985/tags/mlflow.source.git.commit
new file mode 100644
index 0000000..288ce21
--- /dev/null
+++ b/mlruns/812028854715931404/1dca43fd8d16419688b3de890200d985/tags/mlflow.source.git.commit
@@ -0,0 +1 @@
+0daea9b5bbb40120a1bc07c702d171abc1f219c7
\ No newline at end of file
diff --git a/mlruns/812028854715931404/1dca43fd8d16419688b3de890200d985/tags/mlflow.source.name b/mlruns/812028854715931404/1dca43fd8d16419688b3de890200d985/tags/mlflow.source.name
new file mode 100644
index 0000000..db800eb
--- /dev/null
+++ b/mlruns/812028854715931404/1dca43fd8d16419688b3de890200d985/tags/mlflow.source.name
@@ -0,0 +1 @@
+D:\project\python\tradenote\test\workflow_by_code.py
\ No newline at end of file
diff --git a/mlruns/812028854715931404/1dca43fd8d16419688b3de890200d985/tags/mlflow.source.type b/mlruns/812028854715931404/1dca43fd8d16419688b3de890200d985/tags/mlflow.source.type
new file mode 100644
index 0000000..0c2c1fe
--- /dev/null
+++ b/mlruns/812028854715931404/1dca43fd8d16419688b3de890200d985/tags/mlflow.source.type
@@ -0,0 +1 @@
+LOCAL
\ No newline at end of file
diff --git a/mlruns/812028854715931404/1dca43fd8d16419688b3de890200d985/tags/mlflow.user b/mlruns/812028854715931404/1dca43fd8d16419688b3de890200d985/tags/mlflow.user
new file mode 100644
index 0000000..b9cec6f
--- /dev/null
+++ b/mlruns/812028854715931404/1dca43fd8d16419688b3de890200d985/tags/mlflow.user
@@ -0,0 +1 @@
+abulimity
\ No newline at end of file
diff --git a/mlruns/812028854715931404/248ec674001f45e3b852fd116a695edb/artifacts/code_cached.txt b/mlruns/812028854715931404/248ec674001f45e3b852fd116a695edb/artifacts/code_cached.txt
new file mode 100644
index 0000000..e69de29
diff --git a/mlruns/812028854715931404/248ec674001f45e3b852fd116a695edb/artifacts/code_diff.txt b/mlruns/812028854715931404/248ec674001f45e3b852fd116a695edb/artifacts/code_diff.txt
new file mode 100644
index 0000000..07526f9
--- /dev/null
+++ b/mlruns/812028854715931404/248ec674001f45e3b852fd116a695edb/artifacts/code_diff.txt
@@ -0,0 +1,1363 @@
+diff --git a/test/README_MA_Strategy.md b/test/README_MA_Strategy.md
+deleted file mode 100644
+index 5facaf7..0000000
+--- a/test/README_MA_Strategy.md
++++ /dev/null
+@@ -1,197 +0,0 @@
+-# 均线交叉策略 (Moving Average Crossover Strategy)
+-
+-## 策略概述
+-
+-这是一个基于qlib框架实现的均线交叉策略，核心逻辑是：
+-- **金叉买入**：短期均线上穿长期均线时买入
+-- **死叉卖出**：短期均线下穿长期均线时卖出
+-
+-## 文件说明
+-
+-### 1. `ma_cross_strategy.py`
+-完整的策略实现，包含：
+-- `MACrossStrategy` 类：继承自qlib的TopkDropoutStrategy
+-- 完整的回测框架
+-- 结果分析和保存
+-
+-### 2. `ma_cross_strategy_improved.py`
+-改进版本，包含：
+-- 更完善的数据获取逻辑
+-- 错误处理机制
+-- 简化版回测功能
+-
+-### 3. `simple_ma_strategy.py` ⭐ **推荐使用**
+-简单实用的版本，包含：
+-- 清晰的数据获取和处理
+-- 均线信号计算
+-- 收益计算和分析
+-- 可视化图表生成
+-- 结果保存功能
+-
+-## 使用方法
+-
+-### 环境准备
+-
+-1. 确保已安装qlib：
+-```bash
+-pip install pyqlib
+-```
+-
+-2. 下载qlib数据（如果还没有）：
+-```bash
+-# 下载中国股票数据
+-python -m qlib.data.dump_bin --csv_path ~/.qlib/qlib_data/cn_data --include_fields close,open,high,low,volume
+-```
+-
+-### 运行策略
+-
+-#### 方法1：运行简单版本（推荐）
+-```bash
+-cd test
+-python simple_ma_strategy.py
+-```
+-
+-#### 方法2：运行完整版本
+-```bash
+-cd test
+-python ma_cross_strategy.py
+-```
+-
+-#### 方法3：运行改进版本
+-```bash
+-cd test
+-python ma_cross_strategy_improved.py
+-```
+-
+-## 策略参数
+-
+-可以在代码中修改以下参数：
+-
+-```python
+-# 均线周期
+-short_window = 5    # 短期均线周期
+-long_window = 20    # 长期均线周期
+-
+-# 回测时间
+-start_date = "2020-01-01"
+-end_date = "2023-12-31"
+-
+-# 初始资金
+-initial_capital = 100000
+-
+-# 股票池
+-instruments = "csi300"  # 沪深300成分股
+-```
+-
+-## 输出结果
+-
+-运行策略后会生成以下文件：
+-
+-1. **CSV文件**：
+-   - `ma_cross_signals.csv`：买卖信号数据
+-   - `ma_cross_cumulative_returns.csv`：累计收益数据
+-   - `ma_cross_capital_curve.csv`：资金曲线数据
+-
+-2. **图表文件**：
+-   - `ma_cross_strategy_results.png`：策略结果可视化图表
+-
+-3. **控制台输出**：
+-   - 策略分析结果
+-   - 收益统计
+-   - 风险指标
+-
+-## 策略分析指标
+-
+-### 收益指标
+-- 总收益率
+-- 年化收益率
+-- 最终资金
+-
+-### 风险指标
+-- 年化波动率
+-- 夏普比率
+-- 胜率
+-- 最大回撤
+-
+-### 交易统计
+-- 买入信号数量
+-- 卖出信号数量
+-- 总交易次数
+-
+-## 策略逻辑详解
+-
+-### 1. 均线计算
+-```python
+-# 计算短期和长期均线
+-short_ma = price_data.rolling(window=short_window).mean()
+-long_ma = price_data.rolling(window=long_window).mean()
+-```
+-
+-### 2. 交叉信号判断
+-```python
+-# 计算均线差值
+-diff = short_ma - long_ma
+-
+-# 金叉：短期均线从下方穿越长期均线
+-if diff.iloc[i-1] < 0 and diff.iloc[i] > 0:
+-    signal = 1  # 买入信号
+-
+-# 死叉：短期均线从上方穿越长期均线
+-elif diff.iloc[i-1] > 0 and diff.iloc[i] < 0:
+-    signal = -1  # 卖出信号
+-```
+-
+-### 3. 收益计算
+-```python
+-# 策略收益（简化处理）
+-strategy_returns = signals * 0.01
+-
+-# 累计收益
+-cumulative_returns = strategy_returns.sum(axis=1).cumsum()
+-```
+-
+-## 注意事项
+-
+-1. **数据依赖**：确保qlib数据已正确下载和配置
+-2. **参数调优**：可以根据不同市场环境调整均线周期
+-3. **风险控制**：实际交易中需要加入止损和仓位管理
+-4. **交易成本**：当前版本未考虑交易费用，实际应用需要考虑
+-
+-## 扩展功能
+-
+-可以基于此策略进行以下扩展：
+-
+-1. **多均线策略**：使用多条均线进行更复杂的信号判断
+-2. **量价配合**：结合成交量指标优化信号
+-3. **止损机制**：添加动态止损策略
+-4. **仓位管理**：根据信号强度调整仓位大小
+-5. **多股票组合**：构建股票组合分散风险
+-
+-## 常见问题
+-
+-### Q: 如何修改股票池？
+-A: 在代码中修改 `instruments` 参数，例如：
+-```python
+-instruments = "csi500"  # 中证500
+-instruments = ["000001.SZ", "000002.SZ"]  # 指定股票列表
+-```
+-
+-### Q: 如何调整均线周期？
+-A: 修改 `short_window` 和 `long_window` 参数：
+-```python
+-short_window = 10  # 10日均线
+-long_window = 30   # 30日均线
+-```
+-
+-### Q: 如何查看详细的交易记录？
+-A: 查看生成的 `ma_cross_signals.csv` 文件，其中包含每日的买卖信号。
+-
+-## 联系方式
+-
+-如有问题或建议，请通过以下方式联系：
+-- 提交Issue到项目仓库
+-- 发送邮件到项目维护者
+-
+----
+-
+-**免责声明**：本策略仅供学习和研究使用，不构成投资建议。实际投资请谨慎决策，并承担相应风险。 
+\ No newline at end of file
+diff --git a/test/damo1.py b/test/damo1.py
+index 03102e1..7142dd1 100644
+--- a/test/damo1.py
++++ b/test/damo1.py
+@@ -1,5 +1,5 @@
+-# python scripts/get_data.py qlib_data --target_dir ../qlib_data/cn_data --region cn
+-
++# python github/scripts/get_data.py qlib_data --target_dir D:/sync/qlib/qlib_data/cn_data --region cn
++D:/sync/qlib/qlib_data/cn_data
+ import qlib
+ # region in [REG_CN, REG_US]
+ from qlib.constant import REG_CN
+diff --git a/test/ma_cross_strategy.py b/test/ma_cross_strategy.py
+deleted file mode 100644
+index 719d849..0000000
+--- a/test/ma_cross_strategy.py
++++ /dev/null
+@@ -1,274 +0,0 @@
+-"""
+-均线交叉策略：金叉买入，死叉卖出
+-使用qlib框架实现
+-"""
+-
+-import qlib
+-from qlib.constant import REG_CN
+-from qlib.utils import init_instance_by_config
+-from qlib.workflow import R
+-from qlib.workflow.record_temp import SignalRecord, PortAnaRecord
+-from qlib.contrib.evaluate import backtest_daily
+-from qlib.contrib.strategy import TopkDropoutStrategy
+-import pandas as pd
+-import numpy as np
+-from typing import Dict, List, Tuple
+-
+-
+-class MACrossStrategy(TopkDropoutStrategy):
+-    """
+-    均线交叉策略
+-    金叉（短期均线上穿长期均线）买入
+-    死叉（短期均线下穿长期均线）卖出
+-    """
+-    
+-    def __init__(self, 
+-                 short_window: int = 5,
+-                 long_window: int = 20,
+-                 topk: int = 50,
+-                 n_drop: int = 5,
+-                 **kwargs):
+-        """
+-        初始化策略参数
+-        
+-        Args:
+-            short_window: 短期均线周期
+-            long_window: 长期均线周期
+-            topk: 选择前k只股票
+-            n_drop: 剔除前n只股票
+-        """
+-        super().__init__(topk=topk, n_drop=n_drop, **kwargs)
+-        self.short_window = short_window
+-        self.long_window = long_window
+-        
+-    def generate_trade_decision(self, score: pd.Series, trade_step: int) -> pd.Series:
+-        """
+-        生成交易决策
+-        
+-        Args:
+-            score: 股票评分
+-            trade_step: 交易步骤
+-            
+-        Returns:
+-            交易决策，1表示买入，-1表示卖出，0表示持有
+-        """
+-        # 获取当前持仓
+-        current_pos = self.get_current_position()
+-        
+-        # 计算均线信号
+-        signal = self._calculate_ma_signal(score.index.tolist(), trade_step)
+-        
+-        # 生成交易决策
+-        decision = pd.Series(0, index=score.index)
+-        
+-        # 金叉买入信号
+-        buy_signal = signal == 1
+-        decision[buy_signal] = 1
+-        
+-        # 死叉卖出信号
+-        sell_signal = signal == -1
+-        decision[sell_signal] = -1
+-        
+-        return decision
+-    
+-    def _calculate_ma_signal(self, instruments: List[str], trade_step: int) -> pd.Series:
+-        """
+-        计算均线交叉信号
+-        
+-        Args:
+-            instruments: 股票代码列表
+-            trade_step: 交易步骤
+-            
+-        Returns:
+-            信号序列：1表示金叉买入，-1表示死叉卖出，0表示无信号
+-        """
+-        # 获取历史数据
+-        data = self._get_historical_data(instruments, trade_step)
+-        
+-        signals = pd.Series(0, index=instruments)
+-        
+-        for instrument in instruments:
+-            if instrument in data.index:
+-                # 计算短期和长期均线
+-                short_ma = data.loc[instrument].rolling(window=self.short_window).mean()
+-                long_ma = data.loc[instrument].rolling(window=self.long_window).mean()
+-                
+-                # 计算交叉信号
+-                if len(short_ma) >= 2 and len(long_ma) >= 2:
+-                    # 当前和前一个时间点的均线差值
+-                    current_diff = short_ma.iloc[-1] - long_ma.iloc[-1]
+-                    prev_diff = short_ma.iloc[-2] - long_ma.iloc[-2]
+-                    
+-                    # 金叉：短期均线从下方穿越长期均线
+-                    if prev_diff < 0 and current_diff > 0:
+-                        signals[instrument] = 1
+-                    # 死叉：短期均线从上方穿越长期均线
+-                    elif prev_diff > 0 and current_diff < 0:
+-                        signals[instrument] = -1
+-        
+-        return signals
+-    
+-    def _get_historical_data(self, instruments: List[str], trade_step: int) -> pd.DataFrame:
+-        """
+-        获取历史价格数据
+-        
+-        Args:
+-            instruments: 股票代码列表
+-            trade_step: 交易步骤
+-            
+-        Returns:
+-            历史价格数据
+-        """
+-        # 这里简化处理，实际应该从qlib数据源获取
+-        # 在实际应用中，您需要使用qlib的数据接口
+-        try:
+-            # 获取最近的数据用于计算均线
+-            # 这里使用模拟数据，实际应该从qlib获取
+-            dates = pd.date_range(end=pd.Timestamp.now(), periods=50, freq='D')
+-            data = pd.DataFrame(
+-                np.random.randn(len(dates), len(instruments)) * 0.02 + 1.0,
+-                index=dates,
+-                columns=instruments
+-            )
+-            return data
+-        except Exception as e:
+-            print(f"获取历史数据失败: {e}")
+-            return pd.DataFrame()
+-
+-
+-def create_ma_cross_strategy_config():
+-    """
+-    创建均线交叉策略配置
+-    """
+-    strategy_config = {
+-        "class": "MACrossStrategy",
+-        "module_path": "test.ma_cross_strategy",
+-        "kwargs": {
+-            "short_window": 5,
+-            "long_window": 20,
+-            "topk": 50,
+-            "n_drop": 5,
+-        }
+-    }
+-    
+-    return strategy_config
+-
+-
+-def run_backtest():
+-    """
+-    运行回测
+-    """
+-    # 初始化qlib
+-    qlib.init(provider_uri='~/.qlib/qlib_data/cn_data', region=REG_CN)
+-    
+-    # 策略配置
+-    strategy_config = create_ma_cross_strategy_config()
+-    
+-    # 回测配置
+-    backtest_config = {
+-        "start_time": "2020-01-01",
+-        "end_time": "2023-12-31",
+-        "benchmark": "SH000300",  # 沪深300作为基准
+-        "account": 100000000,     # 初始资金1亿
+-        "exchange_kwargs": {
+-            "freq": "day",
+-            "limit_threshold": 0.095,
+-            "deal_price": "close",
+-            "open_cost": 0.0005,
+-            "close_cost": 0.0015,
+-            "min_cost": 5,
+-        }
+-    }
+-    
+-    # 创建策略实例
+-    strategy = init_instance_by_config(strategy_config)
+-    
+-    # 运行回测
+-    with R.start(experiment_name="ma_cross_strategy"):
+-        # 记录信号
+-        sr = SignalRecord(model=strategy, dataset=None, recorder=R.get_recorder())
+-        sr.generate()
+-        
+-        # 记录投资组合分析
+-        par = PortAnaRecord(recorder=R.get_recorder(), config=backtest_config, strategy=strategy)
+-        par.generate()
+-        
+-        # 获取回测结果
+-        report_normal, positions_normal = backtest_daily(
+-            account=backtest_config["account"],
+-            benchmark=backtest_config["benchmark"],
+-            start_time=backtest_config["start_time"],
+-            end_time=backtest_config["end_time"],
+-            strategy=strategy,
+-            exchange_kwargs=backtest_config["exchange_kwargs"]
+-        )
+-        
+-        return report_normal, positions_normal
+-
+-
+-def analyze_results(report: pd.DataFrame, positions: pd.DataFrame):
+-    """
+-    分析回测结果
+-    
+-    Args:
+-        report: 回测报告
+-        positions: 持仓信息
+-    """
+-    print("=" * 50)
+-    print("均线交叉策略回测结果")
+-    print("=" * 50)
+-    
+-    # 基本统计信息
+-    print(f"总收益率: {report['return'].sum():.2%}")
+-    print(f"年化收益率: {report['return'].mean() * 252:.2%}")
+-    print(f"最大回撤: {report['drawdown'].min():.2%}")
+-    print(f"夏普比率: {report['sharpe'].iloc[-1]:.2f}")
+-    print(f"胜率: {(report['return'] > 0).mean():.2%}")
+-    
+-    # 风险指标
+-    volatility = report['return'].std() * np.sqrt(252)
+-    print(f"年化波动率: {volatility:.2%}")
+-    
+-    # 最大回撤期间
+-    max_drawdown_idx = report['drawdown'].idxmin()
+-    print(f"最大回撤发生时间: {max_drawdown_idx}")
+-    
+-    # 收益分布
+-    print("\n收益分布统计:")
+-    print(f"平均日收益: {report['return'].mean():.2%}")
+-    print(f"收益标准差: {report['return'].std():.2%}")
+-    print(f"最小日收益: {report['return'].min():.2%}")
+-    print(f"最大日收益: {report['return'].max():.2%}")
+-    
+-    # 交易统计
+-    if 'trade_count' in report.columns:
+-        print(f"\n总交易次数: {report['trade_count'].sum()}")
+-        print(f"平均每日交易次数: {report['trade_count'].mean():.1f}")
+-
+-
+-def main():
+-    """
+-    主函数
+-    """
+-    print("开始运行均线交叉策略回测...")
+-    
+-    try:
+-        # 运行回测
+-        report, positions = run_backtest()
+-        
+-        # 分析结果
+-        analyze_results(report, positions)
+-        
+-        # 保存结果
+-        report.to_csv("ma_cross_strategy_report.csv")
+-        positions.to_csv("ma_cross_strategy_positions.csv")
+-        
+-        print("\n回测完成！结果已保存到CSV文件。")
+-        
+-    except Exception as e:
+-        print(f"回测过程中出现错误: {e}")
+-        print("请确保已正确安装qlib并下载了相应的数据。")
+-
+-
+-if __name__ == "__main__":
+-    main() 
+\ No newline at end of file
+diff --git a/test/ma_cross_strategy_improved.py b/test/ma_cross_strategy_improved.py
+deleted file mode 100644
+index d166c68..0000000
+--- a/test/ma_cross_strategy_improved.py
++++ /dev/null
+@@ -1,443 +0,0 @@
+-"""
+-改进的均线交叉策略：金叉买入，死叉卖出
+-使用qlib框架实现，包含完整的数据获取和信号计算
+-"""
+-
+-import qlib
+-from qlib.constant import REG_CN
+-from qlib.utils import init_instance_by_config
+-from qlib.workflow import R
+-from qlib.workflow.record_temp import SignalRecord, PortAnaRecord
+-from qlib.contrib.evaluate import backtest_daily
+-from qlib.contrib.strategy import TopkDropoutStrategy
+-from qlib.data import D
+-from qlib.data.dataset import DatasetH
+-from qlib.data.dataset.handler import DataHandlerLP
+-import pandas as pd
+-import numpy as np
+-from typing import Dict, List, Tuple
+-import warnings
+-warnings.filterwarnings('ignore')
+-
+-
+-class MACrossStrategyImproved(TopkDropoutStrategy):
+-    """
+-    改进的均线交叉策略
+-    金叉（短期均线上穿长期均线）买入
+-    死叉（短期均线下穿长期均线）卖出
+-    """
+-    
+-    def __init__(self, 
+-                 short_window: int = 5,
+-                 long_window: int = 20,
+-                 topk: int = 50,
+-                 n_drop: int = 5,
+-                 universe: str = "csi300",
+-                 **kwargs):
+-        """
+-        初始化策略参数
+-        
+-        Args:
+-            short_window: 短期均线周期
+-            long_window: 长期均线周期
+-            topk: 选择前k只股票
+-            n_drop: 剔除前n只股票
+-            universe: 股票池
+-        """
+-        super().__init__(topk=topk, n_drop=n_drop, **kwargs)
+-        self.short_window = short_window
+-        self.long_window = long_window
+-        self.universe = universe
+-        self.instruments = None
+-        self.price_cache = {}
+-        
+-    def generate_trade_decision(self, score: pd.Series, trade_step: int) -> pd.Series:
+-        """
+-        生成交易决策
+-        
+-        Args:
+-            score: 股票评分
+-            trade_step: 交易步骤
+-            
+-        Returns:
+-            交易决策，1表示买入，-1表示卖出，0表示持有
+-        """
+-        # 获取当前持仓
+-        current_pos = self.get_current_position()
+-        
+-        # 计算均线信号
+-        signal = self._calculate_ma_signal(score.index.tolist(), trade_step)
+-        
+-        # 生成交易决策
+-        decision = pd.Series(0, index=score.index)
+-        
+-        # 金叉买入信号
+-        buy_signal = signal == 1
+-        decision[buy_signal] = 1
+-        
+-        # 死叉卖出信号
+-        sell_signal = signal == -1
+-        decision[sell_signal] = -1
+-        
+-        return decision
+-    
+-    def _calculate_ma_signal(self, instruments: List[str], trade_step: int) -> pd.Series:
+-        """
+-        计算均线交叉信号
+-        
+-        Args:
+-            instruments: 股票代码列表
+-            trade_step: 交易步骤
+-            
+-        Returns:
+-            信号序列：1表示金叉买入，-1表示死叉卖出，0表示无信号
+-        """
+-        signals = pd.Series(0, index=instruments)
+-        
+-        # 获取当前日期
+-        current_date = self._get_current_date(trade_step)
+-        
+-        for instrument in instruments:
+-            try:
+-                # 获取历史价格数据
+-                price_data = self._get_price_data(instrument, current_date)
+-                
+-                if price_data is not None and len(price_data) >= self.long_window:
+-                    # 计算短期和长期均线
+-                    short_ma = price_data['close'].rolling(window=self.short_window).mean()
+-                    long_ma = price_data['close'].rolling(window=self.long_window).mean()
+-                    
+-                    # 计算交叉信号
+-                    if len(short_ma) >= 2 and len(long_ma) >= 2:
+-                        # 当前和前一个时间点的均线差值
+-                        current_diff = short_ma.iloc[-1] - long_ma.iloc[-1]
+-                        prev_diff = short_ma.iloc[-2] - long_ma.iloc[-2]
+-                        
+-                        # 金叉：短期均线从下方穿越长期均线
+-                        if prev_diff < 0 and current_diff > 0:
+-                            signals[instrument] = 1
+-                        # 死叉：短期均线从上方穿越长期均线
+-                        elif prev_diff > 0 and current_diff < 0:
+-                            signals[instrument] = -1
+-                            
+-            except Exception as e:
+-                print(f"计算{instrument}均线信号时出错: {e}")
+-                continue
+-        
+-        return signals
+-    
+-    def _get_price_data(self, instrument: str, current_date: str) -> pd.DataFrame:
+-        """
+-        获取股票价格数据
+-        
+-        Args:
+-            instrument: 股票代码
+-            current_date: 当前日期
+-            
+-        Returns:
+-            价格数据DataFrame
+-        """
+-        try:
+-            # 计算开始日期（获取足够的历史数据来计算均线）
+-            start_date = pd.Timestamp(current_date) - pd.Timedelta(days=self.long_window * 2)
+-            
+-            # 从qlib获取数据
+-            data = D.features(
+-                instruments=[instrument],
+-                start_time=start_date.strftime('%Y-%m-%d'),
+-                end_time=current_date,
+-                freq='day',
+-                fields=['$close', '$open', '$high', '$low', '$volume']
+-            )
+-            
+-            if data is not None and not data.empty:
+-                # 重命名列
+-                data.columns = ['close', 'open', 'high', 'low', 'volume']
+-                return data
+-            else:
+-                return None
+-                
+-        except Exception as e:
+-            print(f"获取{instrument}价格数据失败: {e}")
+-            return None
+-    
+-    def _get_current_date(self, trade_step: int) -> str:
+-        """
+-        根据交易步骤获取当前日期
+-        
+-        Args:
+-            trade_step: 交易步骤
+-            
+-        Returns:
+-            当前日期字符串
+-        """
+-        # 这里简化处理，实际应该从qlib的日历获取
+-        # 假设从2020-01-01开始，每个trade_step代表一天
+-        start_date = pd.Timestamp('2020-01-01')
+-        current_date = start_date + pd.Timedelta(days=trade_step)
+-        return current_date.strftime('%Y-%m-%d')
+-
+-
+-def create_dataset_config():
+-    """
+-    创建数据集配置
+-    """
+-    dataset_config = {
+-        "class": "DatasetH",
+-        "module_path": "qlib.data.dataset",
+-        "kwargs": {
+-            "handler": {
+-                "class": "DataHandlerLP",
+-                "module_path": "qlib.data.dataset.handler",
+-                "kwargs": {
+-                    "start_time": "2020-01-01",
+-                    "end_time": "2023-12-31",
+-                    "fit_start_time": "2020-01-01",
+-                    "fit_end_time": "2023-12-31",
+-                    "instruments": "csi300",
+-                    "infer_processors": [
+-                        {
+-                            "class": "RobustZScoreNorm",
+-                            "module_path": "qlib.data.dataset.processor",
+-                            "kwargs": {
+-                                "fields_group": "feature",
+-                                "clip_outlier": True,
+-                            },
+-                        },
+-                        {
+-                            "class": "Fillna",
+-                            "module_path": "qlib.data.dataset.processor",
+-                            "kwargs": {
+-                                "fields_group": "feature",
+-                            },
+-                        },
+-                    ],
+-                    "learn_processors": [
+-                        {
+-                            "class": "DropnaLabel",
+-                            "module_path": "qlib.data.dataset.processor",
+-                        },
+-                        {
+-                            "class": "CSRankNorm",
+-                            "module_path": "qlib.data.dataset.processor",
+-                            "kwargs": {
+-                                "fields_group": "label",
+-                            },
+-                        },
+-                    ],
+-                    "instruments": "csi300",
+-                },
+-            },
+-            "segments": {
+-                "train": ("2020-01-01", "2022-12-31"),
+-                "valid": ("2023-01-01", "2023-06-30"),
+-                "test": ("2023-07-01", "2023-12-31"),
+-            },
+-        },
+-    }
+-    
+-    return dataset_config
+-
+-
+-def create_ma_cross_strategy_config():
+-    """
+-    创建均线交叉策略配置
+-    """
+-    strategy_config = {
+-        "class": "MACrossStrategyImproved",
+-        "module_path": "test.ma_cross_strategy_improved",
+-        "kwargs": {
+-            "short_window": 5,
+-            "long_window": 20,
+-            "topk": 50,
+-            "n_drop": 5,
+-            "universe": "csi300",
+-        }
+-    }
+-    
+-    return strategy_config
+-
+-
+-def run_backtest():
+-    """
+-    运行回测
+-    """
+-    # 初始化qlib
+-    qlib.init(provider_uri='~/.qlib/qlib_data/cn_data', region=REG_CN)
+-    
+-    # 策略配置
+-    strategy_config = create_ma_cross_strategy_config()
+-    
+-    # 回测配置
+-    backtest_config = {
+-        "start_time": "2020-01-01",
+-        "end_time": "2023-12-31",
+-        "benchmark": "SH000300",  # 沪深300作为基准
+-        "account": 100000000,     # 初始资金1亿
+-        "exchange_kwargs": {
+-            "freq": "day",
+-            "limit_threshold": 0.095,
+-            "deal_price": "close",
+-            "open_cost": 0.0005,
+-            "close_cost": 0.0015,
+-            "min_cost": 5,
+-        }
+-    }
+-    
+-    # 创建策略实例
+-    strategy = init_instance_by_config(strategy_config)
+-    
+-    # 运行回测
+-    with R.start(experiment_name="ma_cross_strategy_improved"):
+-        # 记录信号
+-        sr = SignalRecord(model=strategy, dataset=None, recorder=R.get_recorder())
+-        sr.generate()
+-        
+-        # 记录投资组合分析
+-        par = PortAnaRecord(recorder=R.get_recorder(), config=backtest_config, strategy=strategy)
+-        par.generate()
+-        
+-        # 获取回测结果
+-        report_normal, positions_normal = backtest_daily(
+-            account=backtest_config["account"],
+-            benchmark=backtest_config["benchmark"],
+-            start_time=backtest_config["start_time"],
+-            end_time=backtest_config["end_time"],
+-            strategy=strategy,
+-            exchange_kwargs=backtest_config["exchange_kwargs"]
+-        )
+-        
+-        return report_normal, positions_normal
+-
+-
+-def analyze_results(report: pd.DataFrame, positions: pd.DataFrame):
+-    """
+-    分析回测结果
+-    
+-    Args:
+-        report: 回测报告
+-        positions: 持仓信息
+-    """
+-    print("=" * 50)
+-    print("均线交叉策略回测结果")
+-    print("=" * 50)
+-    
+-    # 基本统计信息
+-    print(f"总收益率: {report['return'].sum():.2%}")
+-    print(f"年化收益率: {report['return'].mean() * 252:.2%}")
+-    print(f"最大回撤: {report['drawdown'].min():.2%}")
+-    
+-    if 'sharpe' in report.columns:
+-        print(f"夏普比率: {report['sharpe'].iloc[-1]:.2f}")
+-    
+-    print(f"胜率: {(report['return'] > 0).mean():.2%}")
+-    
+-    # 风险指标
+-    volatility = report['return'].std() * np.sqrt(252)
+-    print(f"年化波动率: {volatility:.2%}")
+-    
+-    # 最大回撤期间
+-    max_drawdown_idx = report['drawdown'].idxmin()
+-    print(f"最大回撤发生时间: {max_drawdown_idx}")
+-    
+-    # 收益分布
+-    print("\n收益分布统计:")
+-    print(f"平均日收益: {report['return'].mean():.2%}")
+-    print(f"收益标准差: {report['return'].std():.2%}")
+-    print(f"最小日收益: {report['return'].min():.2%}")
+-    print(f"最大日收益: {report['return'].max():.2%}")
+-    
+-    # 交易统计
+-    if 'trade_count' in report.columns:
+-        print(f"\n总交易次数: {report['trade_count'].sum()}")
+-        print(f"平均每日交易次数: {report['trade_count'].mean():.1f}")
+-
+-
+-def create_simple_backtest():
+-    """
+-    创建简化版回测，用于演示
+-    """
+-    print("创建简化版均线交叉策略回测...")
+-    
+-    # 初始化qlib
+-    qlib.init(provider_uri='~/.qlib/qlib_data/cn_data', region=REG_CN)
+-    
+-    # 获取股票列表
+-    instruments = D.list_instruments(instruments="csi300", start_time="2020-01-01", end_time="2023-12-31")
+-    
+-    print(f"获取到 {len(instruments)} 只股票")
+-    
+-    # 选择前10只股票进行演示
+-    demo_instruments = instruments[:10]
+-    
+-    # 获取价格数据
+-    data = D.features(
+-        instruments=demo_instruments,
+-        start_time="2020-01-01",
+-        end_time="2023-12-31",
+-        freq='day',
+-        fields=['$close']
+-    )
+-    
+-    print(f"获取到价格数据，形状: {data.shape}")
+-    
+-    # 计算均线
+-    short_ma = data.rolling(window=5).mean()
+-    long_ma = data.rolling(window=20).mean()
+-    
+-    # 计算交叉信号
+-    signals = pd.DataFrame(0, index=data.index, columns=data.columns)
+-    
+-    for col in data.columns:
+-        # 计算均线差值
+-        diff = short_ma[col] - long_ma[col]
+-        
+-        # 计算交叉信号
+-        for i in range(1, len(diff)):
+-            if diff.iloc[i-1] < 0 and diff.iloc[i] > 0:
+-                signals.iloc[i, signals.columns.get_loc(col)] = 1  # 金叉买入
+-            elif diff.iloc[i-1] > 0 and diff.iloc[i] < 0:
+-                signals.iloc[i, signals.columns.get_loc(col)] = -1  # 死叉卖出
+-    
+-    # 统计信号
+-    buy_signals = (signals == 1).sum().sum()
+-    sell_signals = (signals == -1).sum().sum()
+-    
+-    print(f"\n信号统计:")
+-    print(f"买入信号数量: {buy_signals}")
+-    print(f"卖出信号数量: {sell_signals}")
+-    
+-    # 计算简单收益（假设每次信号都产生1%的收益）
+-    returns = signals * 0.01
+-    cumulative_returns = returns.sum(axis=1).cumsum()
+-    
+-    print(f"\n累计收益: {cumulative_returns.iloc[-1]:.2%}")
+-    
+-    return signals, cumulative_returns
+-
+-
+-def main():
+-    """
+-    主函数
+-    """
+-    print("开始运行均线交叉策略回测...")
+-    
+-    try:
+-        # 运行简化版回测
+-        signals, cumulative_returns = create_simple_backtest()
+-        
+-        # 保存简化版结果
+-        signals.to_csv("ma_cross_signals.csv")
+-        cumulative_returns.to_csv("ma_cross_cumulative_returns.csv")
+-        
+-        print("\n简化版回测完成！")
+-        print("信号数据已保存到 ma_cross_signals.csv")
+-        print("累计收益已保存到 ma_cross_cumulative_returns.csv")
+-        
+-    except Exception as e:
+-        print(f"回测过程中出现错误: {e}")
+-        print("请确保已正确安装qlib并下载了相应的数据。")
+-
+-
+-if __name__ == "__main__":
+-    main() 
+\ No newline at end of file
+diff --git a/test/ma_strategy_demo.py b/test/ma_strategy_demo.py
+deleted file mode 100644
+index 1fa4fb4..0000000
+Binary files a/test/ma_strategy_demo.py and /dev/null differ
+diff --git a/test/simple_ma_strategy.py b/test/simple_ma_strategy.py
+deleted file mode 100644
+index 8d03f6b..0000000
+--- a/test/simple_ma_strategy.py
++++ /dev/null
+@@ -1,298 +0,0 @@
+-"""
+-简单实用的均线交叉策略
+-金叉买入，死叉卖出
+-"""
+-
+-import qlib
+-from qlib.constant import REG_CN
+-from qlib.data import D
+-import pandas as pd
+-import numpy as np
+-import matplotlib.pyplot as plt
+-from datetime import datetime, timedelta
+-
+-
+-def init_qlib():
+-    """初始化qlib"""
+-    try:
+-        qlib.init(provider_uri='~/.qlib/qlib_data/cn_data', region=REG_CN)
+-        print("qlib初始化成功")
+-        return True
+-    except Exception as e:
+-        print(f"qlib初始化失败: {e}")
+-        print("请确保已安装qlib并下载了数据")
+-        return False
+-
+-
+-def get_stock_data(instruments, start_date, end_date):
+-    """
+-    获取股票数据
+-    
+-    Args:
+-        instruments: 股票代码列表
+-        start_date: 开始日期
+-        end_date: 结束日期
+-    
+-    Returns:
+-        股票价格数据
+-    """
+-    try:
+-        data = D.features(
+-            instruments=instruments,
+-            start_time=start_date,
+-            end_time=end_date,
+-            freq='day',
+-            fields=['$close', '$open', '$high', '$low', '$volume']
+-        )
+-        
+-        if data is not None and not data.empty:
+-            # 重命名列
+-            data.columns = ['close', 'open', 'high', 'low', 'volume']
+-            return data
+-        else:
+-            print("未获取到数据")
+-            return None
+-            
+-    except Exception as e:
+-        print(f"获取数据失败: {e}")
+-        return None
+-
+-
+-def calculate_ma_signals(data, short_window=5, long_window=20):
+-    """
+-    计算均线交叉信号
+-    
+-    Args:
+-        data: 价格数据
+-        short_window: 短期均线周期
+-        long_window: 长期均线周期
+-    
+-    Returns:
+-        信号DataFrame，1表示买入，-1表示卖出，0表示无信号
+-    """
+-    signals = pd.DataFrame(0, index=data.index, columns=data.columns)
+-    
+-    for col in data.columns:
+-        if col == 'close':
+-            continue
+-            
+-        # 计算均线
+-        short_ma = data[col].rolling(window=short_window).mean()
+-        long_ma = data[col].rolling(window=long_window).mean()
+-        
+-        # 计算均线差值
+-        diff = short_ma - long_ma
+-        
+-        # 计算交叉信号
+-        for i in range(1, len(diff)):
+-            if pd.notna(diff.iloc[i-1]) and pd.notna(diff.iloc[i]):
+-                # 金叉：短期均线从下方穿越长期均线
+-                if diff.iloc[i-1] < 0 and diff.iloc[i] > 0:
+-                    signals.iloc[i, signals.columns.get_loc(col)] = 1
+-                # 死叉：短期均线从上方穿越长期均线
+-                elif diff.iloc[i-1] > 0 and diff.iloc[i] < 0:
+-                    signals.iloc[i, signals.columns.get_loc(col)] = -1
+-    
+-    return signals
+-
+-
+-def calculate_returns(data, signals, initial_capital=100000):
+-    """
+-    计算策略收益
+-    
+-    Args:
+-        data: 价格数据
+-        signals: 信号数据
+-        initial_capital: 初始资金
+-    
+-    Returns:
+-        收益数据
+-    """
+-    # 计算日收益率
+-    returns = data.pct_change()
+-    
+-    # 策略收益（假设每次信号产生1%的收益）
+-    strategy_returns = signals * 0.01
+-    
+-    # 累计收益
+-    cumulative_returns = strategy_returns.sum(axis=1).cumsum()
+-    
+-    # 资金曲线
+-    capital_curve = initial_capital * (1 + cumulative_returns)
+-    
+-    return {
+-        'strategy_returns': strategy_returns,
+-        'cumulative_returns': cumulative_returns,
+-        'capital_curve': capital_curve
+-    }
+-
+-
+-def analyze_strategy(signals, returns_data):
+-    """
+-    分析策略表现
+-    
+-    Args:
+-        signals: 信号数据
+-        returns_data: 收益数据
+-    """
+-    print("=" * 50)
+-    print("均线交叉策略分析结果")
+-    print("=" * 50)
+-    
+-    # 信号统计
+-    buy_signals = (signals == 1).sum().sum()
+-    sell_signals = (signals == -1).sum().sum()
+-    
+-    print(f"买入信号数量: {buy_signals}")
+-    print(f"卖出信号数量: {sell_signals}")
+-    print(f"总信号数量: {buy_signals + sell_signals}")
+-    
+-    # 收益统计
+-    cumulative_returns = returns_data['cumulative_returns']
+-    capital_curve = returns_data['capital_curve']
+-    
+-    total_return = cumulative_returns.iloc[-1]
+-    annual_return = total_return / (len(cumulative_returns) / 252)
+-    
+-    print(f"\n收益统计:")
+-    print(f"总收益率: {total_return:.2%}")
+-    print(f"年化收益率: {annual_return:.2%}")
+-    print(f"最终资金: {capital_curve.iloc[-1]:,.0f}")
+-    
+-    # 风险统计
+-    daily_returns = returns_data['strategy_returns'].sum(axis=1)
+-    volatility = daily_returns.std() * np.sqrt(252)
+-    sharpe_ratio = annual_return / volatility if volatility > 0 else 0
+-    
+-    print(f"\n风险统计:")
+-    print(f"年化波动率: {volatility:.2%}")
+-    print(f"夏普比率: {sharpe_ratio:.2f}")
+-    print(f"胜率: {(daily_returns > 0).mean():.2%}")
+-
+-
+-def plot_results(data, signals, returns_data, stock_code):
+-    """
+-    绘制结果图表
+-    
+-    Args:
+-        data: 价格数据
+-        signals: 信号数据
+-        returns_data: 收益数据
+-        stock_code: 股票代码
+-    """
+-    fig, axes = plt.subplots(3, 1, figsize=(12, 10))
+-    
+-    # 绘制价格和均线
+-    axes[0].plot(data.index, data[stock_code], label='收盘价', alpha=0.7)
+-    short_ma = data[stock_code].rolling(window=5).mean()
+-    long_ma = data[stock_code].rolling(window=20).mean()
+-    axes[0].plot(data.index, short_ma, label='5日均线', alpha=0.8)
+-    axes[0].plot(data.index, long_ma, label='20日均线', alpha=0.8)
+-    
+-    # 标记买卖信号
+-    buy_signals = signals[stock_code] == 1
+-    sell_signals = signals[stock_code] == -1
+-    
+-    axes[0].scatter(data.index[buy_signals], data.loc[buy_signals, stock_code], 
+-                   color='red', marker='^', s=100, label='买入信号', alpha=0.8)
+-    axes[0].scatter(data.index[sell_signals], data.loc[sell_signals, stock_code], 
+-                   color='green', marker='v', s=100, label='卖出信号', alpha=0.8)
+-    
+-    axes[0].set_title(f'{stock_code} 价格走势与均线交叉信号')
+-    axes[0].legend()
+-    axes[0].grid(True, alpha=0.3)
+-    
+-    # 绘制累计收益
+-    axes[1].plot(returns_data['cumulative_returns'].index, 
+-                returns_data['cumulative_returns'].values, 
+-                label='累计收益', color='blue')
+-    axes[1].set_title('策略累计收益')
+-    axes[1].legend()
+-    axes[1].grid(True, alpha=0.3)
+-    
+-    # 绘制资金曲线
+-    axes[2].plot(returns_data['capital_curve'].index, 
+-                returns_data['capital_curve'].values, 
+-                label='资金曲线', color='green')
+-    axes[2].set_title('资金曲线')
+-    axes[2].legend()
+-    axes[2].grid(True, alpha=0.3)
+-    
+-    plt.tight_layout()
+-    plt.savefig('ma_cross_strategy_results.png', dpi=300, bbox_inches='tight')
+-    plt.show()
+-
+-
+-def main():
+-    """
+-    主函数
+-    """
+-    print("开始运行均线交叉策略...")
+-    
+-    # 初始化qlib
+-    if not init_qlib():
+-        return
+-    
+-    # 策略参数
+-    start_date = "2020-01-01"
+-    end_date = "2023-12-31"
+-    short_window = 5
+-    long_window = 20
+-    initial_capital = 100000
+-    
+-    # 获取股票列表
+-    try:
+-        instruments = D.list_instruments(instruments="csi300", start_time=start_date, end_time=end_date)
+-        print(f"获取到 {len(instruments)} 只股票")
+-        
+-        # 选择前5只股票进行演示
+-        demo_instruments = instruments[:5]
+-        print(f"选择演示股票: {demo_instruments}")
+-        
+-    except Exception as e:
+-        print(f"获取股票列表失败: {e}")
+-        # 使用默认股票列表
+-        demo_instruments = ['000001.SZ', '000002.SZ', '000858.SZ', '002415.SZ', '600036.SH']
+-        print(f"使用默认股票列表: {demo_instruments}")
+-    
+-    # 获取价格数据
+-    data = get_stock_data(demo_instruments, start_date, end_date)
+-    
+-    if data is None:
+-        print("无法获取数据，程序退出")
+-        return
+-    
+-    print(f"获取到价格数据，形状: {data.shape}")
+-    
+-    # 计算均线信号
+-    signals = calculate_ma_signals(data, short_window, long_window)
+-    
+-    # 计算收益
+-    returns_data = calculate_returns(data, signals, initial_capital)
+-    
+-    # 分析策略
+-    analyze_strategy(signals, returns_data)
+-    
+-    # 保存结果
+-    signals.to_csv("ma_cross_signals.csv")
+-    returns_data['cumulative_returns'].to_csv("ma_cross_cumulative_returns.csv")
+-    returns_data['capital_curve'].to_csv("ma_cross_capital_curve.csv")
+-    
+-    print("\n结果已保存到CSV文件:")
+-    print("- ma_cross_signals.csv: 买卖信号")
+-    print("- ma_cross_cumulative_returns.csv: 累计收益")
+-    print("- ma_cross_capital_curve.csv: 资金曲线")
+-    
+-    # 绘制图表（选择第一只股票）
+-    if len(demo_instruments) > 0:
+-        try:
+-            plot_results(data, signals, returns_data, demo_instruments[0])
+-            print("图表已保存为 ma_cross_strategy_results.png")
+-        except Exception as e:
+-            print(f"绘制图表失败: {e}")
+-    
+-    print("\n策略回测完成！")
+-
+-
+-if __name__ == "__main__":
+-    main() 
+\ No newline at end of file
+diff --git a/test/two_ema_stragety.py b/test/two_ema_stragety.py
+index a72e7e8..a9890c7 100644
+--- a/test/two_ema_stragety.py
++++ b/test/two_ema_stragety.py
+@@ -1,2 +1,98 @@
+-from qlib.contrib.strategy import 
+-from qlib.backtest import backtest
+\ No newline at end of file
++import pandas as pd
++
++from abc import ABC
++from typing import Dict, List, Text, Tuple, Union
++from qlib.data.dataset import Dataset
++from qlib.model.base import BaseModel
++from qlib.backtest.signal import Signal, create_signal_from
++from qlib.strategy.base import BaseStrategy
++from qlib.backtest.decision import Order, OrderDir, OrderHelper, TradeDecisionWO
++# from qlib.strategy import 
++# from qlib.backtest import backtest
++
++class InnerStrategy(BaseStrategy):
++    """
++    Inner strategy for order execution:
++    - Buy: if price < 200, buy all cash; else buy 200,000 worth.
++    - Sell: if price > 200, sell all; else sell half.
++    """
++    STOCK_CODE = "000858.SZ"
++
++    def generate_trade_decision(self, execute_result: list = None, action: str = None, amount: float = None):
++        # action: 'buy' or 'sell', amount: suggested amount (shares) from outer
++        position = self.trade_position
++        trade_step = self.trade_calendar.get_trade_step()
++        trade_start_time, trade_end_time = self.trade_calendar.get_step_time(trade_step)
++        order_helper = self.trade_exchange.get_order_helper()
++        orders = []
++        price = self.trade_exchange.get_deal_price(self.STOCK_CODE, trade_start_time, trade_end_time)
++        if action == 'buy':
++            cash = position.get_cash()
++            if price <= 0:
++                return TradeDecisionWO([], self)
++            if price < 200:
++                buy_amount = cash // price
++            else:
++                buy_amount = min(cash // price, 200000 // price)
++            buy_amount = int(buy_amount)
++            if buy_amount > 0:
++                order = order_helper.create(
++                    code=self.STOCK_CODE,
++                    amount=buy_amount,
++                    direction=OrderDir.BUY,
++                    start_time=trade_start_time,
++                    end_time=trade_end_time,
++                )
++                orders.append(order)
++        elif action == 'sell':
++            held_amount = position.get_stock_amount(self.STOCK_CODE)
++            if held_amount <= 0 or price <= 0:
++                return TradeDecisionWO([], self)
++            if price > 200:
++                sell_amount = held_amount
++            else:
++                sell_amount = held_amount // 2
++            sell_amount = int(sell_amount)
++            if sell_amount > 0:
++                order = order_helper.create(
++                    code=self.STOCK_CODE,
++                    amount=sell_amount,
++                    direction=OrderDir.SELL,
++                    start_time=trade_start_time,
++                    end_time=trade_end_time,
++                )
++                orders.append(order)
++        return TradeDecisionWO(orders, self)
++
++class OuterStrategy(BaseStrategy):
++    """
++    Outer strategy:
++    - If not holding Wuliangye, issues a buy order via inner strategy.
++    - If holding, checks if held for 25 days, if so, issues a sell order via inner strategy.
++    - Otherwise, holds.
++    """
++    STOCK_CODE = "000858.SZ"
++    HOLD_DAYS = 25
++    BAR = "day"
++
++    def __init__(self, *args, **kwargs):
++        super().__init__(*args, **kwargs)
++        self.inner_strategy = InnerStrategy()
++
++    def generate_trade_decision(self, execute_result: list = None):
++        position = self.trade_position
++        stock_list = position.get_stock_list()
++        trade_step = self.trade_calendar.get_trade_step()
++        trade_start_time, trade_end_time = self.trade_calendar.get_step_time(trade_step)
++        # Pass infra to inner strategy
++        self.inner_strategy.reset(level_infra=self.level_infra, common_infra=self.common_infra)
++        if self.STOCK_CODE in stock_list:
++            hold_days = position.get_stock_count(self.STOCK_CODE, self.BAR)
++            if hold_days >= self.HOLD_DAYS:
++                # Sell via inner strategy
++                return self.inner_strategy.generate_trade_decision(action='sell')
++        else:
++            # Buy via inner strategy
++            return self.inner_strategy.generate_trade_decision(action='buy')
++        # Otherwise, hold
++        return TradeDecisionWO([], self)
+\ No newline at end of file
diff --git a/mlruns/812028854715931404/248ec674001f45e3b852fd116a695edb/artifacts/code_status.txt b/mlruns/812028854715931404/248ec674001f45e3b852fd116a695edb/artifacts/code_status.txt
new file mode 100644
index 0000000..35a35fa
--- /dev/null
+++ b/mlruns/812028854715931404/248ec674001f45e3b852fd116a695edb/artifacts/code_status.txt
@@ -0,0 +1,22 @@
+On branch main
+Your branch is up to date with 'origin/main'.
+
+Changes not staged for commit:
+  (use "git add/rm <file>..." to update what will be committed)
+  (use "git restore <file>..." to discard changes in working directory)
+	deleted:    test/README_MA_Strategy.md
+	modified:   test/damo1.py
+	deleted:    test/ma_cross_strategy.py
+	deleted:    test/ma_cross_strategy_improved.py
+	deleted:    test/ma_strategy_demo.py
+	deleted:    test/simple_ma_strategy.py
+	modified:   test/two_ema_stragety.py
+
+Untracked files:
+  (use "git add <file>..." to include in what will be committed)
+	mlruns/
+	test/__pycache__/
+	test/buy_and_hold.py
+	test/workflow_by_code.py
+
+no changes added to commit (use "git add" and/or "git commit -a")
diff --git a/mlruns/812028854715931404/248ec674001f45e3b852fd116a695edb/meta.yaml b/mlruns/812028854715931404/248ec674001f45e3b852fd116a695edb/meta.yaml
new file mode 100644
index 0000000..c0c7699
--- /dev/null
+++ b/mlruns/812028854715931404/248ec674001f45e3b852fd116a695edb/meta.yaml
@@ -0,0 +1,14 @@
+artifact_uri: file:D:\project\python\tradenote\mlruns/812028854715931404/248ec674001f45e3b852fd116a695edb/artifacts
+end_time: 1750317955807
+entry_point_name: ''
+experiment_id: '812028854715931404'
+lifecycle_stage: active
+run_id: 248ec674001f45e3b852fd116a695edb
+run_name: mlflow_recorder
+source_name: ''
+source_type: 4
+source_version: ''
+start_time: 1750317955530
+status: 3
+tags: []
+user_id: abulimity
diff --git a/mlruns/812028854715931404/248ec674001f45e3b852fd116a695edb/params/cmd-sys.argv b/mlruns/812028854715931404/248ec674001f45e3b852fd116a695edb/params/cmd-sys.argv
new file mode 100644
index 0000000..db800eb
--- /dev/null
+++ b/mlruns/812028854715931404/248ec674001f45e3b852fd116a695edb/params/cmd-sys.argv
@@ -0,0 +1 @@
+D:\project\python\tradenote\test\workflow_by_code.py
\ No newline at end of file
diff --git a/mlruns/812028854715931404/248ec674001f45e3b852fd116a695edb/tags/mlflow.runName b/mlruns/812028854715931404/248ec674001f45e3b852fd116a695edb/tags/mlflow.runName
new file mode 100644
index 0000000..25487e4
--- /dev/null
+++ b/mlruns/812028854715931404/248ec674001f45e3b852fd116a695edb/tags/mlflow.runName
@@ -0,0 +1 @@
+mlflow_recorder
\ No newline at end of file
diff --git a/mlruns/812028854715931404/248ec674001f45e3b852fd116a695edb/tags/mlflow.source.git.commit b/mlruns/812028854715931404/248ec674001f45e3b852fd116a695edb/tags/mlflow.source.git.commit
new file mode 100644
index 0000000..288ce21
--- /dev/null
+++ b/mlruns/812028854715931404/248ec674001f45e3b852fd116a695edb/tags/mlflow.source.git.commit
@@ -0,0 +1 @@
+0daea9b5bbb40120a1bc07c702d171abc1f219c7
\ No newline at end of file
diff --git a/mlruns/812028854715931404/248ec674001f45e3b852fd116a695edb/tags/mlflow.source.name b/mlruns/812028854715931404/248ec674001f45e3b852fd116a695edb/tags/mlflow.source.name
new file mode 100644
index 0000000..db800eb
--- /dev/null
+++ b/mlruns/812028854715931404/248ec674001f45e3b852fd116a695edb/tags/mlflow.source.name
@@ -0,0 +1 @@
+D:\project\python\tradenote\test\workflow_by_code.py
\ No newline at end of file
diff --git a/mlruns/812028854715931404/248ec674001f45e3b852fd116a695edb/tags/mlflow.source.type b/mlruns/812028854715931404/248ec674001f45e3b852fd116a695edb/tags/mlflow.source.type
new file mode 100644
index 0000000..0c2c1fe
--- /dev/null
+++ b/mlruns/812028854715931404/248ec674001f45e3b852fd116a695edb/tags/mlflow.source.type
@@ -0,0 +1 @@
+LOCAL
\ No newline at end of file
diff --git a/mlruns/812028854715931404/248ec674001f45e3b852fd116a695edb/tags/mlflow.user b/mlruns/812028854715931404/248ec674001f45e3b852fd116a695edb/tags/mlflow.user
new file mode 100644
index 0000000..b9cec6f
--- /dev/null
+++ b/mlruns/812028854715931404/248ec674001f45e3b852fd116a695edb/tags/mlflow.user
@@ -0,0 +1 @@
+abulimity
\ No newline at end of file
diff --git a/mlruns/812028854715931404/6154317dbc1f4340860562a026af9481/artifacts/code_cached.txt b/mlruns/812028854715931404/6154317dbc1f4340860562a026af9481/artifacts/code_cached.txt
new file mode 100644
index 0000000..e69de29
diff --git a/mlruns/812028854715931404/6154317dbc1f4340860562a026af9481/artifacts/code_diff.txt b/mlruns/812028854715931404/6154317dbc1f4340860562a026af9481/artifacts/code_diff.txt
new file mode 100644
index 0000000..ceea66d
--- /dev/null
+++ b/mlruns/812028854715931404/6154317dbc1f4340860562a026af9481/artifacts/code_diff.txt
@@ -0,0 +1,1361 @@
+diff --git a/test/README_MA_Strategy.md b/test/README_MA_Strategy.md
+deleted file mode 100644
+index 5facaf7..0000000
+--- a/test/README_MA_Strategy.md
++++ /dev/null
+@@ -1,197 +0,0 @@
+-# 均线交叉策略 (Moving Average Crossover Strategy)
+-
+-## 策略概述
+-
+-这是一个基于qlib框架实现的均线交叉策略，核心逻辑是：
+-- **金叉买入**：短期均线上穿长期均线时买入
+-- **死叉卖出**：短期均线下穿长期均线时卖出
+-
+-## 文件说明
+-
+-### 1. `ma_cross_strategy.py`
+-完整的策略实现，包含：
+-- `MACrossStrategy` 类：继承自qlib的TopkDropoutStrategy
+-- 完整的回测框架
+-- 结果分析和保存
+-
+-### 2. `ma_cross_strategy_improved.py`
+-改进版本，包含：
+-- 更完善的数据获取逻辑
+-- 错误处理机制
+-- 简化版回测功能
+-
+-### 3. `simple_ma_strategy.py` ⭐ **推荐使用**
+-简单实用的版本，包含：
+-- 清晰的数据获取和处理
+-- 均线信号计算
+-- 收益计算和分析
+-- 可视化图表生成
+-- 结果保存功能
+-
+-## 使用方法
+-
+-### 环境准备
+-
+-1. 确保已安装qlib：
+-```bash
+-pip install pyqlib
+-```
+-
+-2. 下载qlib数据（如果还没有）：
+-```bash
+-# 下载中国股票数据
+-python -m qlib.data.dump_bin --csv_path ~/.qlib/qlib_data/cn_data --include_fields close,open,high,low,volume
+-```
+-
+-### 运行策略
+-
+-#### 方法1：运行简单版本（推荐）
+-```bash
+-cd test
+-python simple_ma_strategy.py
+-```
+-
+-#### 方法2：运行完整版本
+-```bash
+-cd test
+-python ma_cross_strategy.py
+-```
+-
+-#### 方法3：运行改进版本
+-```bash
+-cd test
+-python ma_cross_strategy_improved.py
+-```
+-
+-## 策略参数
+-
+-可以在代码中修改以下参数：
+-
+-```python
+-# 均线周期
+-short_window = 5    # 短期均线周期
+-long_window = 20    # 长期均线周期
+-
+-# 回测时间
+-start_date = "2020-01-01"
+-end_date = "2023-12-31"
+-
+-# 初始资金
+-initial_capital = 100000
+-
+-# 股票池
+-instruments = "csi300"  # 沪深300成分股
+-```
+-
+-## 输出结果
+-
+-运行策略后会生成以下文件：
+-
+-1. **CSV文件**：
+-   - `ma_cross_signals.csv`：买卖信号数据
+-   - `ma_cross_cumulative_returns.csv`：累计收益数据
+-   - `ma_cross_capital_curve.csv`：资金曲线数据
+-
+-2. **图表文件**：
+-   - `ma_cross_strategy_results.png`：策略结果可视化图表
+-
+-3. **控制台输出**：
+-   - 策略分析结果
+-   - 收益统计
+-   - 风险指标
+-
+-## 策略分析指标
+-
+-### 收益指标
+-- 总收益率
+-- 年化收益率
+-- 最终资金
+-
+-### 风险指标
+-- 年化波动率
+-- 夏普比率
+-- 胜率
+-- 最大回撤
+-
+-### 交易统计
+-- 买入信号数量
+-- 卖出信号数量
+-- 总交易次数
+-
+-## 策略逻辑详解
+-
+-### 1. 均线计算
+-```python
+-# 计算短期和长期均线
+-short_ma = price_data.rolling(window=short_window).mean()
+-long_ma = price_data.rolling(window=long_window).mean()
+-```
+-
+-### 2. 交叉信号判断
+-```python
+-# 计算均线差值
+-diff = short_ma - long_ma
+-
+-# 金叉：短期均线从下方穿越长期均线
+-if diff.iloc[i-1] < 0 and diff.iloc[i] > 0:
+-    signal = 1  # 买入信号
+-
+-# 死叉：短期均线从上方穿越长期均线
+-elif diff.iloc[i-1] > 0 and diff.iloc[i] < 0:
+-    signal = -1  # 卖出信号
+-```
+-
+-### 3. 收益计算
+-```python
+-# 策略收益（简化处理）
+-strategy_returns = signals * 0.01
+-
+-# 累计收益
+-cumulative_returns = strategy_returns.sum(axis=1).cumsum()
+-```
+-
+-## 注意事项
+-
+-1. **数据依赖**：确保qlib数据已正确下载和配置
+-2. **参数调优**：可以根据不同市场环境调整均线周期
+-3. **风险控制**：实际交易中需要加入止损和仓位管理
+-4. **交易成本**：当前版本未考虑交易费用，实际应用需要考虑
+-
+-## 扩展功能
+-
+-可以基于此策略进行以下扩展：
+-
+-1. **多均线策略**：使用多条均线进行更复杂的信号判断
+-2. **量价配合**：结合成交量指标优化信号
+-3. **止损机制**：添加动态止损策略
+-4. **仓位管理**：根据信号强度调整仓位大小
+-5. **多股票组合**：构建股票组合分散风险
+-
+-## 常见问题
+-
+-### Q: 如何修改股票池？
+-A: 在代码中修改 `instruments` 参数，例如：
+-```python
+-instruments = "csi500"  # 中证500
+-instruments = ["000001.SZ", "000002.SZ"]  # 指定股票列表
+-```
+-
+-### Q: 如何调整均线周期？
+-A: 修改 `short_window` 和 `long_window` 参数：
+-```python
+-short_window = 10  # 10日均线
+-long_window = 30   # 30日均线
+-```
+-
+-### Q: 如何查看详细的交易记录？
+-A: 查看生成的 `ma_cross_signals.csv` 文件，其中包含每日的买卖信号。
+-
+-## 联系方式
+-
+-如有问题或建议，请通过以下方式联系：
+-- 提交Issue到项目仓库
+-- 发送邮件到项目维护者
+-
+----
+-
+-**免责声明**：本策略仅供学习和研究使用，不构成投资建议。实际投资请谨慎决策，并承担相应风险。 
+\ No newline at end of file
+diff --git a/test/damo1.py b/test/damo1.py
+index 03102e1..6477dc0 100644
+--- a/test/damo1.py
++++ b/test/damo1.py
+@@ -1,4 +1,4 @@
+-# python scripts/get_data.py qlib_data --target_dir ../qlib_data/cn_data --region cn
++# python scripts/get_data.py qlib_data --target_dir D:/sync/sync/qlib/qlib_data/cn_data --region cn
+ 
+ import qlib
+ # region in [REG_CN, REG_US]
+diff --git a/test/ma_cross_strategy.py b/test/ma_cross_strategy.py
+deleted file mode 100644
+index 719d849..0000000
+--- a/test/ma_cross_strategy.py
++++ /dev/null
+@@ -1,274 +0,0 @@
+-"""
+-均线交叉策略：金叉买入，死叉卖出
+-使用qlib框架实现
+-"""
+-
+-import qlib
+-from qlib.constant import REG_CN
+-from qlib.utils import init_instance_by_config
+-from qlib.workflow import R
+-from qlib.workflow.record_temp import SignalRecord, PortAnaRecord
+-from qlib.contrib.evaluate import backtest_daily
+-from qlib.contrib.strategy import TopkDropoutStrategy
+-import pandas as pd
+-import numpy as np
+-from typing import Dict, List, Tuple
+-
+-
+-class MACrossStrategy(TopkDropoutStrategy):
+-    """
+-    均线交叉策略
+-    金叉（短期均线上穿长期均线）买入
+-    死叉（短期均线下穿长期均线）卖出
+-    """
+-    
+-    def __init__(self, 
+-                 short_window: int = 5,
+-                 long_window: int = 20,
+-                 topk: int = 50,
+-                 n_drop: int = 5,
+-                 **kwargs):
+-        """
+-        初始化策略参数
+-        
+-        Args:
+-            short_window: 短期均线周期
+-            long_window: 长期均线周期
+-            topk: 选择前k只股票
+-            n_drop: 剔除前n只股票
+-        """
+-        super().__init__(topk=topk, n_drop=n_drop, **kwargs)
+-        self.short_window = short_window
+-        self.long_window = long_window
+-        
+-    def generate_trade_decision(self, score: pd.Series, trade_step: int) -> pd.Series:
+-        """
+-        生成交易决策
+-        
+-        Args:
+-            score: 股票评分
+-            trade_step: 交易步骤
+-            
+-        Returns:
+-            交易决策，1表示买入，-1表示卖出，0表示持有
+-        """
+-        # 获取当前持仓
+-        current_pos = self.get_current_position()
+-        
+-        # 计算均线信号
+-        signal = self._calculate_ma_signal(score.index.tolist(), trade_step)
+-        
+-        # 生成交易决策
+-        decision = pd.Series(0, index=score.index)
+-        
+-        # 金叉买入信号
+-        buy_signal = signal == 1
+-        decision[buy_signal] = 1
+-        
+-        # 死叉卖出信号
+-        sell_signal = signal == -1
+-        decision[sell_signal] = -1
+-        
+-        return decision
+-    
+-    def _calculate_ma_signal(self, instruments: List[str], trade_step: int) -> pd.Series:
+-        """
+-        计算均线交叉信号
+-        
+-        Args:
+-            instruments: 股票代码列表
+-            trade_step: 交易步骤
+-            
+-        Returns:
+-            信号序列：1表示金叉买入，-1表示死叉卖出，0表示无信号
+-        """
+-        # 获取历史数据
+-        data = self._get_historical_data(instruments, trade_step)
+-        
+-        signals = pd.Series(0, index=instruments)
+-        
+-        for instrument in instruments:
+-            if instrument in data.index:
+-                # 计算短期和长期均线
+-                short_ma = data.loc[instrument].rolling(window=self.short_window).mean()
+-                long_ma = data.loc[instrument].rolling(window=self.long_window).mean()
+-                
+-                # 计算交叉信号
+-                if len(short_ma) >= 2 and len(long_ma) >= 2:
+-                    # 当前和前一个时间点的均线差值
+-                    current_diff = short_ma.iloc[-1] - long_ma.iloc[-1]
+-                    prev_diff = short_ma.iloc[-2] - long_ma.iloc[-2]
+-                    
+-                    # 金叉：短期均线从下方穿越长期均线
+-                    if prev_diff < 0 and current_diff > 0:
+-                        signals[instrument] = 1
+-                    # 死叉：短期均线从上方穿越长期均线
+-                    elif prev_diff > 0 and current_diff < 0:
+-                        signals[instrument] = -1
+-        
+-        return signals
+-    
+-    def _get_historical_data(self, instruments: List[str], trade_step: int) -> pd.DataFrame:
+-        """
+-        获取历史价格数据
+-        
+-        Args:
+-            instruments: 股票代码列表
+-            trade_step: 交易步骤
+-            
+-        Returns:
+-            历史价格数据
+-        """
+-        # 这里简化处理，实际应该从qlib数据源获取
+-        # 在实际应用中，您需要使用qlib的数据接口
+-        try:
+-            # 获取最近的数据用于计算均线
+-            # 这里使用模拟数据，实际应该从qlib获取
+-            dates = pd.date_range(end=pd.Timestamp.now(), periods=50, freq='D')
+-            data = pd.DataFrame(
+-                np.random.randn(len(dates), len(instruments)) * 0.02 + 1.0,
+-                index=dates,
+-                columns=instruments
+-            )
+-            return data
+-        except Exception as e:
+-            print(f"获取历史数据失败: {e}")
+-            return pd.DataFrame()
+-
+-
+-def create_ma_cross_strategy_config():
+-    """
+-    创建均线交叉策略配置
+-    """
+-    strategy_config = {
+-        "class": "MACrossStrategy",
+-        "module_path": "test.ma_cross_strategy",
+-        "kwargs": {
+-            "short_window": 5,
+-            "long_window": 20,
+-            "topk": 50,
+-            "n_drop": 5,
+-        }
+-    }
+-    
+-    return strategy_config
+-
+-
+-def run_backtest():
+-    """
+-    运行回测
+-    """
+-    # 初始化qlib
+-    qlib.init(provider_uri='~/.qlib/qlib_data/cn_data', region=REG_CN)
+-    
+-    # 策略配置
+-    strategy_config = create_ma_cross_strategy_config()
+-    
+-    # 回测配置
+-    backtest_config = {
+-        "start_time": "2020-01-01",
+-        "end_time": "2023-12-31",
+-        "benchmark": "SH000300",  # 沪深300作为基准
+-        "account": 100000000,     # 初始资金1亿
+-        "exchange_kwargs": {
+-            "freq": "day",
+-            "limit_threshold": 0.095,
+-            "deal_price": "close",
+-            "open_cost": 0.0005,
+-            "close_cost": 0.0015,
+-            "min_cost": 5,
+-        }
+-    }
+-    
+-    # 创建策略实例
+-    strategy = init_instance_by_config(strategy_config)
+-    
+-    # 运行回测
+-    with R.start(experiment_name="ma_cross_strategy"):
+-        # 记录信号
+-        sr = SignalRecord(model=strategy, dataset=None, recorder=R.get_recorder())
+-        sr.generate()
+-        
+-        # 记录投资组合分析
+-        par = PortAnaRecord(recorder=R.get_recorder(), config=backtest_config, strategy=strategy)
+-        par.generate()
+-        
+-        # 获取回测结果
+-        report_normal, positions_normal = backtest_daily(
+-            account=backtest_config["account"],
+-            benchmark=backtest_config["benchmark"],
+-            start_time=backtest_config["start_time"],
+-            end_time=backtest_config["end_time"],
+-            strategy=strategy,
+-            exchange_kwargs=backtest_config["exchange_kwargs"]
+-        )
+-        
+-        return report_normal, positions_normal
+-
+-
+-def analyze_results(report: pd.DataFrame, positions: pd.DataFrame):
+-    """
+-    分析回测结果
+-    
+-    Args:
+-        report: 回测报告
+-        positions: 持仓信息
+-    """
+-    print("=" * 50)
+-    print("均线交叉策略回测结果")
+-    print("=" * 50)
+-    
+-    # 基本统计信息
+-    print(f"总收益率: {report['return'].sum():.2%}")
+-    print(f"年化收益率: {report['return'].mean() * 252:.2%}")
+-    print(f"最大回撤: {report['drawdown'].min():.2%}")
+-    print(f"夏普比率: {report['sharpe'].iloc[-1]:.2f}")
+-    print(f"胜率: {(report['return'] > 0).mean():.2%}")
+-    
+-    # 风险指标
+-    volatility = report['return'].std() * np.sqrt(252)
+-    print(f"年化波动率: {volatility:.2%}")
+-    
+-    # 最大回撤期间
+-    max_drawdown_idx = report['drawdown'].idxmin()
+-    print(f"最大回撤发生时间: {max_drawdown_idx}")
+-    
+-    # 收益分布
+-    print("\n收益分布统计:")
+-    print(f"平均日收益: {report['return'].mean():.2%}")
+-    print(f"收益标准差: {report['return'].std():.2%}")
+-    print(f"最小日收益: {report['return'].min():.2%}")
+-    print(f"最大日收益: {report['return'].max():.2%}")
+-    
+-    # 交易统计
+-    if 'trade_count' in report.columns:
+-        print(f"\n总交易次数: {report['trade_count'].sum()}")
+-        print(f"平均每日交易次数: {report['trade_count'].mean():.1f}")
+-
+-
+-def main():
+-    """
+-    主函数
+-    """
+-    print("开始运行均线交叉策略回测...")
+-    
+-    try:
+-        # 运行回测
+-        report, positions = run_backtest()
+-        
+-        # 分析结果
+-        analyze_results(report, positions)
+-        
+-        # 保存结果
+-        report.to_csv("ma_cross_strategy_report.csv")
+-        positions.to_csv("ma_cross_strategy_positions.csv")
+-        
+-        print("\n回测完成！结果已保存到CSV文件。")
+-        
+-    except Exception as e:
+-        print(f"回测过程中出现错误: {e}")
+-        print("请确保已正确安装qlib并下载了相应的数据。")
+-
+-
+-if __name__ == "__main__":
+-    main() 
+\ No newline at end of file
+diff --git a/test/ma_cross_strategy_improved.py b/test/ma_cross_strategy_improved.py
+deleted file mode 100644
+index d166c68..0000000
+--- a/test/ma_cross_strategy_improved.py
++++ /dev/null
+@@ -1,443 +0,0 @@
+-"""
+-改进的均线交叉策略：金叉买入，死叉卖出
+-使用qlib框架实现，包含完整的数据获取和信号计算
+-"""
+-
+-import qlib
+-from qlib.constant import REG_CN
+-from qlib.utils import init_instance_by_config
+-from qlib.workflow import R
+-from qlib.workflow.record_temp import SignalRecord, PortAnaRecord
+-from qlib.contrib.evaluate import backtest_daily
+-from qlib.contrib.strategy import TopkDropoutStrategy
+-from qlib.data import D
+-from qlib.data.dataset import DatasetH
+-from qlib.data.dataset.handler import DataHandlerLP
+-import pandas as pd
+-import numpy as np
+-from typing import Dict, List, Tuple
+-import warnings
+-warnings.filterwarnings('ignore')
+-
+-
+-class MACrossStrategyImproved(TopkDropoutStrategy):
+-    """
+-    改进的均线交叉策略
+-    金叉（短期均线上穿长期均线）买入
+-    死叉（短期均线下穿长期均线）卖出
+-    """
+-    
+-    def __init__(self, 
+-                 short_window: int = 5,
+-                 long_window: int = 20,
+-                 topk: int = 50,
+-                 n_drop: int = 5,
+-                 universe: str = "csi300",
+-                 **kwargs):
+-        """
+-        初始化策略参数
+-        
+-        Args:
+-            short_window: 短期均线周期
+-            long_window: 长期均线周期
+-            topk: 选择前k只股票
+-            n_drop: 剔除前n只股票
+-            universe: 股票池
+-        """
+-        super().__init__(topk=topk, n_drop=n_drop, **kwargs)
+-        self.short_window = short_window
+-        self.long_window = long_window
+-        self.universe = universe
+-        self.instruments = None
+-        self.price_cache = {}
+-        
+-    def generate_trade_decision(self, score: pd.Series, trade_step: int) -> pd.Series:
+-        """
+-        生成交易决策
+-        
+-        Args:
+-            score: 股票评分
+-            trade_step: 交易步骤
+-            
+-        Returns:
+-            交易决策，1表示买入，-1表示卖出，0表示持有
+-        """
+-        # 获取当前持仓
+-        current_pos = self.get_current_position()
+-        
+-        # 计算均线信号
+-        signal = self._calculate_ma_signal(score.index.tolist(), trade_step)
+-        
+-        # 生成交易决策
+-        decision = pd.Series(0, index=score.index)
+-        
+-        # 金叉买入信号
+-        buy_signal = signal == 1
+-        decision[buy_signal] = 1
+-        
+-        # 死叉卖出信号
+-        sell_signal = signal == -1
+-        decision[sell_signal] = -1
+-        
+-        return decision
+-    
+-    def _calculate_ma_signal(self, instruments: List[str], trade_step: int) -> pd.Series:
+-        """
+-        计算均线交叉信号
+-        
+-        Args:
+-            instruments: 股票代码列表
+-            trade_step: 交易步骤
+-            
+-        Returns:
+-            信号序列：1表示金叉买入，-1表示死叉卖出，0表示无信号
+-        """
+-        signals = pd.Series(0, index=instruments)
+-        
+-        # 获取当前日期
+-        current_date = self._get_current_date(trade_step)
+-        
+-        for instrument in instruments:
+-            try:
+-                # 获取历史价格数据
+-                price_data = self._get_price_data(instrument, current_date)
+-                
+-                if price_data is not None and len(price_data) >= self.long_window:
+-                    # 计算短期和长期均线
+-                    short_ma = price_data['close'].rolling(window=self.short_window).mean()
+-                    long_ma = price_data['close'].rolling(window=self.long_window).mean()
+-                    
+-                    # 计算交叉信号
+-                    if len(short_ma) >= 2 and len(long_ma) >= 2:
+-                        # 当前和前一个时间点的均线差值
+-                        current_diff = short_ma.iloc[-1] - long_ma.iloc[-1]
+-                        prev_diff = short_ma.iloc[-2] - long_ma.iloc[-2]
+-                        
+-                        # 金叉：短期均线从下方穿越长期均线
+-                        if prev_diff < 0 and current_diff > 0:
+-                            signals[instrument] = 1
+-                        # 死叉：短期均线从上方穿越长期均线
+-                        elif prev_diff > 0 and current_diff < 0:
+-                            signals[instrument] = -1
+-                            
+-            except Exception as e:
+-                print(f"计算{instrument}均线信号时出错: {e}")
+-                continue
+-        
+-        return signals
+-    
+-    def _get_price_data(self, instrument: str, current_date: str) -> pd.DataFrame:
+-        """
+-        获取股票价格数据
+-        
+-        Args:
+-            instrument: 股票代码
+-            current_date: 当前日期
+-            
+-        Returns:
+-            价格数据DataFrame
+-        """
+-        try:
+-            # 计算开始日期（获取足够的历史数据来计算均线）
+-            start_date = pd.Timestamp(current_date) - pd.Timedelta(days=self.long_window * 2)
+-            
+-            # 从qlib获取数据
+-            data = D.features(
+-                instruments=[instrument],
+-                start_time=start_date.strftime('%Y-%m-%d'),
+-                end_time=current_date,
+-                freq='day',
+-                fields=['$close', '$open', '$high', '$low', '$volume']
+-            )
+-            
+-            if data is not None and not data.empty:
+-                # 重命名列
+-                data.columns = ['close', 'open', 'high', 'low', 'volume']
+-                return data
+-            else:
+-                return None
+-                
+-        except Exception as e:
+-            print(f"获取{instrument}价格数据失败: {e}")
+-            return None
+-    
+-    def _get_current_date(self, trade_step: int) -> str:
+-        """
+-        根据交易步骤获取当前日期
+-        
+-        Args:
+-            trade_step: 交易步骤
+-            
+-        Returns:
+-            当前日期字符串
+-        """
+-        # 这里简化处理，实际应该从qlib的日历获取
+-        # 假设从2020-01-01开始，每个trade_step代表一天
+-        start_date = pd.Timestamp('2020-01-01')
+-        current_date = start_date + pd.Timedelta(days=trade_step)
+-        return current_date.strftime('%Y-%m-%d')
+-
+-
+-def create_dataset_config():
+-    """
+-    创建数据集配置
+-    """
+-    dataset_config = {
+-        "class": "DatasetH",
+-        "module_path": "qlib.data.dataset",
+-        "kwargs": {
+-            "handler": {
+-                "class": "DataHandlerLP",
+-                "module_path": "qlib.data.dataset.handler",
+-                "kwargs": {
+-                    "start_time": "2020-01-01",
+-                    "end_time": "2023-12-31",
+-                    "fit_start_time": "2020-01-01",
+-                    "fit_end_time": "2023-12-31",
+-                    "instruments": "csi300",
+-                    "infer_processors": [
+-                        {
+-                            "class": "RobustZScoreNorm",
+-                            "module_path": "qlib.data.dataset.processor",
+-                            "kwargs": {
+-                                "fields_group": "feature",
+-                                "clip_outlier": True,
+-                            },
+-                        },
+-                        {
+-                            "class": "Fillna",
+-                            "module_path": "qlib.data.dataset.processor",
+-                            "kwargs": {
+-                                "fields_group": "feature",
+-                            },
+-                        },
+-                    ],
+-                    "learn_processors": [
+-                        {
+-                            "class": "DropnaLabel",
+-                            "module_path": "qlib.data.dataset.processor",
+-                        },
+-                        {
+-                            "class": "CSRankNorm",
+-                            "module_path": "qlib.data.dataset.processor",
+-                            "kwargs": {
+-                                "fields_group": "label",
+-                            },
+-                        },
+-                    ],
+-                    "instruments": "csi300",
+-                },
+-            },
+-            "segments": {
+-                "train": ("2020-01-01", "2022-12-31"),
+-                "valid": ("2023-01-01", "2023-06-30"),
+-                "test": ("2023-07-01", "2023-12-31"),
+-            },
+-        },
+-    }
+-    
+-    return dataset_config
+-
+-
+-def create_ma_cross_strategy_config():
+-    """
+-    创建均线交叉策略配置
+-    """
+-    strategy_config = {
+-        "class": "MACrossStrategyImproved",
+-        "module_path": "test.ma_cross_strategy_improved",
+-        "kwargs": {
+-            "short_window": 5,
+-            "long_window": 20,
+-            "topk": 50,
+-            "n_drop": 5,
+-            "universe": "csi300",
+-        }
+-    }
+-    
+-    return strategy_config
+-
+-
+-def run_backtest():
+-    """
+-    运行回测
+-    """
+-    # 初始化qlib
+-    qlib.init(provider_uri='~/.qlib/qlib_data/cn_data', region=REG_CN)
+-    
+-    # 策略配置
+-    strategy_config = create_ma_cross_strategy_config()
+-    
+-    # 回测配置
+-    backtest_config = {
+-        "start_time": "2020-01-01",
+-        "end_time": "2023-12-31",
+-        "benchmark": "SH000300",  # 沪深300作为基准
+-        "account": 100000000,     # 初始资金1亿
+-        "exchange_kwargs": {
+-            "freq": "day",
+-            "limit_threshold": 0.095,
+-            "deal_price": "close",
+-            "open_cost": 0.0005,
+-            "close_cost": 0.0015,
+-            "min_cost": 5,
+-        }
+-    }
+-    
+-    # 创建策略实例
+-    strategy = init_instance_by_config(strategy_config)
+-    
+-    # 运行回测
+-    with R.start(experiment_name="ma_cross_strategy_improved"):
+-        # 记录信号
+-        sr = SignalRecord(model=strategy, dataset=None, recorder=R.get_recorder())
+-        sr.generate()
+-        
+-        # 记录投资组合分析
+-        par = PortAnaRecord(recorder=R.get_recorder(), config=backtest_config, strategy=strategy)
+-        par.generate()
+-        
+-        # 获取回测结果
+-        report_normal, positions_normal = backtest_daily(
+-            account=backtest_config["account"],
+-            benchmark=backtest_config["benchmark"],
+-            start_time=backtest_config["start_time"],
+-            end_time=backtest_config["end_time"],
+-            strategy=strategy,
+-            exchange_kwargs=backtest_config["exchange_kwargs"]
+-        )
+-        
+-        return report_normal, positions_normal
+-
+-
+-def analyze_results(report: pd.DataFrame, positions: pd.DataFrame):
+-    """
+-    分析回测结果
+-    
+-    Args:
+-        report: 回测报告
+-        positions: 持仓信息
+-    """
+-    print("=" * 50)
+-    print("均线交叉策略回测结果")
+-    print("=" * 50)
+-    
+-    # 基本统计信息
+-    print(f"总收益率: {report['return'].sum():.2%}")
+-    print(f"年化收益率: {report['return'].mean() * 252:.2%}")
+-    print(f"最大回撤: {report['drawdown'].min():.2%}")
+-    
+-    if 'sharpe' in report.columns:
+-        print(f"夏普比率: {report['sharpe'].iloc[-1]:.2f}")
+-    
+-    print(f"胜率: {(report['return'] > 0).mean():.2%}")
+-    
+-    # 风险指标
+-    volatility = report['return'].std() * np.sqrt(252)
+-    print(f"年化波动率: {volatility:.2%}")
+-    
+-    # 最大回撤期间
+-    max_drawdown_idx = report['drawdown'].idxmin()
+-    print(f"最大回撤发生时间: {max_drawdown_idx}")
+-    
+-    # 收益分布
+-    print("\n收益分布统计:")
+-    print(f"平均日收益: {report['return'].mean():.2%}")
+-    print(f"收益标准差: {report['return'].std():.2%}")
+-    print(f"最小日收益: {report['return'].min():.2%}")
+-    print(f"最大日收益: {report['return'].max():.2%}")
+-    
+-    # 交易统计
+-    if 'trade_count' in report.columns:
+-        print(f"\n总交易次数: {report['trade_count'].sum()}")
+-        print(f"平均每日交易次数: {report['trade_count'].mean():.1f}")
+-
+-
+-def create_simple_backtest():
+-    """
+-    创建简化版回测，用于演示
+-    """
+-    print("创建简化版均线交叉策略回测...")
+-    
+-    # 初始化qlib
+-    qlib.init(provider_uri='~/.qlib/qlib_data/cn_data', region=REG_CN)
+-    
+-    # 获取股票列表
+-    instruments = D.list_instruments(instruments="csi300", start_time="2020-01-01", end_time="2023-12-31")
+-    
+-    print(f"获取到 {len(instruments)} 只股票")
+-    
+-    # 选择前10只股票进行演示
+-    demo_instruments = instruments[:10]
+-    
+-    # 获取价格数据
+-    data = D.features(
+-        instruments=demo_instruments,
+-        start_time="2020-01-01",
+-        end_time="2023-12-31",
+-        freq='day',
+-        fields=['$close']
+-    )
+-    
+-    print(f"获取到价格数据，形状: {data.shape}")
+-    
+-    # 计算均线
+-    short_ma = data.rolling(window=5).mean()
+-    long_ma = data.rolling(window=20).mean()
+-    
+-    # 计算交叉信号
+-    signals = pd.DataFrame(0, index=data.index, columns=data.columns)
+-    
+-    for col in data.columns:
+-        # 计算均线差值
+-        diff = short_ma[col] - long_ma[col]
+-        
+-        # 计算交叉信号
+-        for i in range(1, len(diff)):
+-            if diff.iloc[i-1] < 0 and diff.iloc[i] > 0:
+-                signals.iloc[i, signals.columns.get_loc(col)] = 1  # 金叉买入
+-            elif diff.iloc[i-1] > 0 and diff.iloc[i] < 0:
+-                signals.iloc[i, signals.columns.get_loc(col)] = -1  # 死叉卖出
+-    
+-    # 统计信号
+-    buy_signals = (signals == 1).sum().sum()
+-    sell_signals = (signals == -1).sum().sum()
+-    
+-    print(f"\n信号统计:")
+-    print(f"买入信号数量: {buy_signals}")
+-    print(f"卖出信号数量: {sell_signals}")
+-    
+-    # 计算简单收益（假设每次信号都产生1%的收益）
+-    returns = signals * 0.01
+-    cumulative_returns = returns.sum(axis=1).cumsum()
+-    
+-    print(f"\n累计收益: {cumulative_returns.iloc[-1]:.2%}")
+-    
+-    return signals, cumulative_returns
+-
+-
+-def main():
+-    """
+-    主函数
+-    """
+-    print("开始运行均线交叉策略回测...")
+-    
+-    try:
+-        # 运行简化版回测
+-        signals, cumulative_returns = create_simple_backtest()
+-        
+-        # 保存简化版结果
+-        signals.to_csv("ma_cross_signals.csv")
+-        cumulative_returns.to_csv("ma_cross_cumulative_returns.csv")
+-        
+-        print("\n简化版回测完成！")
+-        print("信号数据已保存到 ma_cross_signals.csv")
+-        print("累计收益已保存到 ma_cross_cumulative_returns.csv")
+-        
+-    except Exception as e:
+-        print(f"回测过程中出现错误: {e}")
+-        print("请确保已正确安装qlib并下载了相应的数据。")
+-
+-
+-if __name__ == "__main__":
+-    main() 
+\ No newline at end of file
+diff --git a/test/ma_strategy_demo.py b/test/ma_strategy_demo.py
+deleted file mode 100644
+index 1fa4fb4..0000000
+Binary files a/test/ma_strategy_demo.py and /dev/null differ
+diff --git a/test/simple_ma_strategy.py b/test/simple_ma_strategy.py
+deleted file mode 100644
+index 8d03f6b..0000000
+--- a/test/simple_ma_strategy.py
++++ /dev/null
+@@ -1,298 +0,0 @@
+-"""
+-简单实用的均线交叉策略
+-金叉买入，死叉卖出
+-"""
+-
+-import qlib
+-from qlib.constant import REG_CN
+-from qlib.data import D
+-import pandas as pd
+-import numpy as np
+-import matplotlib.pyplot as plt
+-from datetime import datetime, timedelta
+-
+-
+-def init_qlib():
+-    """初始化qlib"""
+-    try:
+-        qlib.init(provider_uri='~/.qlib/qlib_data/cn_data', region=REG_CN)
+-        print("qlib初始化成功")
+-        return True
+-    except Exception as e:
+-        print(f"qlib初始化失败: {e}")
+-        print("请确保已安装qlib并下载了数据")
+-        return False
+-
+-
+-def get_stock_data(instruments, start_date, end_date):
+-    """
+-    获取股票数据
+-    
+-    Args:
+-        instruments: 股票代码列表
+-        start_date: 开始日期
+-        end_date: 结束日期
+-    
+-    Returns:
+-        股票价格数据
+-    """
+-    try:
+-        data = D.features(
+-            instruments=instruments,
+-            start_time=start_date,
+-            end_time=end_date,
+-            freq='day',
+-            fields=['$close', '$open', '$high', '$low', '$volume']
+-        )
+-        
+-        if data is not None and not data.empty:
+-            # 重命名列
+-            data.columns = ['close', 'open', 'high', 'low', 'volume']
+-            return data
+-        else:
+-            print("未获取到数据")
+-            return None
+-            
+-    except Exception as e:
+-        print(f"获取数据失败: {e}")
+-        return None
+-
+-
+-def calculate_ma_signals(data, short_window=5, long_window=20):
+-    """
+-    计算均线交叉信号
+-    
+-    Args:
+-        data: 价格数据
+-        short_window: 短期均线周期
+-        long_window: 长期均线周期
+-    
+-    Returns:
+-        信号DataFrame，1表示买入，-1表示卖出，0表示无信号
+-    """
+-    signals = pd.DataFrame(0, index=data.index, columns=data.columns)
+-    
+-    for col in data.columns:
+-        if col == 'close':
+-            continue
+-            
+-        # 计算均线
+-        short_ma = data[col].rolling(window=short_window).mean()
+-        long_ma = data[col].rolling(window=long_window).mean()
+-        
+-        # 计算均线差值
+-        diff = short_ma - long_ma
+-        
+-        # 计算交叉信号
+-        for i in range(1, len(diff)):
+-            if pd.notna(diff.iloc[i-1]) and pd.notna(diff.iloc[i]):
+-                # 金叉：短期均线从下方穿越长期均线
+-                if diff.iloc[i-1] < 0 and diff.iloc[i] > 0:
+-                    signals.iloc[i, signals.columns.get_loc(col)] = 1
+-                # 死叉：短期均线从上方穿越长期均线
+-                elif diff.iloc[i-1] > 0 and diff.iloc[i] < 0:
+-                    signals.iloc[i, signals.columns.get_loc(col)] = -1
+-    
+-    return signals
+-
+-
+-def calculate_returns(data, signals, initial_capital=100000):
+-    """
+-    计算策略收益
+-    
+-    Args:
+-        data: 价格数据
+-        signals: 信号数据
+-        initial_capital: 初始资金
+-    
+-    Returns:
+-        收益数据
+-    """
+-    # 计算日收益率
+-    returns = data.pct_change()
+-    
+-    # 策略收益（假设每次信号产生1%的收益）
+-    strategy_returns = signals * 0.01
+-    
+-    # 累计收益
+-    cumulative_returns = strategy_returns.sum(axis=1).cumsum()
+-    
+-    # 资金曲线
+-    capital_curve = initial_capital * (1 + cumulative_returns)
+-    
+-    return {
+-        'strategy_returns': strategy_returns,
+-        'cumulative_returns': cumulative_returns,
+-        'capital_curve': capital_curve
+-    }
+-
+-
+-def analyze_strategy(signals, returns_data):
+-    """
+-    分析策略表现
+-    
+-    Args:
+-        signals: 信号数据
+-        returns_data: 收益数据
+-    """
+-    print("=" * 50)
+-    print("均线交叉策略分析结果")
+-    print("=" * 50)
+-    
+-    # 信号统计
+-    buy_signals = (signals == 1).sum().sum()
+-    sell_signals = (signals == -1).sum().sum()
+-    
+-    print(f"买入信号数量: {buy_signals}")
+-    print(f"卖出信号数量: {sell_signals}")
+-    print(f"总信号数量: {buy_signals + sell_signals}")
+-    
+-    # 收益统计
+-    cumulative_returns = returns_data['cumulative_returns']
+-    capital_curve = returns_data['capital_curve']
+-    
+-    total_return = cumulative_returns.iloc[-1]
+-    annual_return = total_return / (len(cumulative_returns) / 252)
+-    
+-    print(f"\n收益统计:")
+-    print(f"总收益率: {total_return:.2%}")
+-    print(f"年化收益率: {annual_return:.2%}")
+-    print(f"最终资金: {capital_curve.iloc[-1]:,.0f}")
+-    
+-    # 风险统计
+-    daily_returns = returns_data['strategy_returns'].sum(axis=1)
+-    volatility = daily_returns.std() * np.sqrt(252)
+-    sharpe_ratio = annual_return / volatility if volatility > 0 else 0
+-    
+-    print(f"\n风险统计:")
+-    print(f"年化波动率: {volatility:.2%}")
+-    print(f"夏普比率: {sharpe_ratio:.2f}")
+-    print(f"胜率: {(daily_returns > 0).mean():.2%}")
+-
+-
+-def plot_results(data, signals, returns_data, stock_code):
+-    """
+-    绘制结果图表
+-    
+-    Args:
+-        data: 价格数据
+-        signals: 信号数据
+-        returns_data: 收益数据
+-        stock_code: 股票代码
+-    """
+-    fig, axes = plt.subplots(3, 1, figsize=(12, 10))
+-    
+-    # 绘制价格和均线
+-    axes[0].plot(data.index, data[stock_code], label='收盘价', alpha=0.7)
+-    short_ma = data[stock_code].rolling(window=5).mean()
+-    long_ma = data[stock_code].rolling(window=20).mean()
+-    axes[0].plot(data.index, short_ma, label='5日均线', alpha=0.8)
+-    axes[0].plot(data.index, long_ma, label='20日均线', alpha=0.8)
+-    
+-    # 标记买卖信号
+-    buy_signals = signals[stock_code] == 1
+-    sell_signals = signals[stock_code] == -1
+-    
+-    axes[0].scatter(data.index[buy_signals], data.loc[buy_signals, stock_code], 
+-                   color='red', marker='^', s=100, label='买入信号', alpha=0.8)
+-    axes[0].scatter(data.index[sell_signals], data.loc[sell_signals, stock_code], 
+-                   color='green', marker='v', s=100, label='卖出信号', alpha=0.8)
+-    
+-    axes[0].set_title(f'{stock_code} 价格走势与均线交叉信号')
+-    axes[0].legend()
+-    axes[0].grid(True, alpha=0.3)
+-    
+-    # 绘制累计收益
+-    axes[1].plot(returns_data['cumulative_returns'].index, 
+-                returns_data['cumulative_returns'].values, 
+-                label='累计收益', color='blue')
+-    axes[1].set_title('策略累计收益')
+-    axes[1].legend()
+-    axes[1].grid(True, alpha=0.3)
+-    
+-    # 绘制资金曲线
+-    axes[2].plot(returns_data['capital_curve'].index, 
+-                returns_data['capital_curve'].values, 
+-                label='资金曲线', color='green')
+-    axes[2].set_title('资金曲线')
+-    axes[2].legend()
+-    axes[2].grid(True, alpha=0.3)
+-    
+-    plt.tight_layout()
+-    plt.savefig('ma_cross_strategy_results.png', dpi=300, bbox_inches='tight')
+-    plt.show()
+-
+-
+-def main():
+-    """
+-    主函数
+-    """
+-    print("开始运行均线交叉策略...")
+-    
+-    # 初始化qlib
+-    if not init_qlib():
+-        return
+-    
+-    # 策略参数
+-    start_date = "2020-01-01"
+-    end_date = "2023-12-31"
+-    short_window = 5
+-    long_window = 20
+-    initial_capital = 100000
+-    
+-    # 获取股票列表
+-    try:
+-        instruments = D.list_instruments(instruments="csi300", start_time=start_date, end_time=end_date)
+-        print(f"获取到 {len(instruments)} 只股票")
+-        
+-        # 选择前5只股票进行演示
+-        demo_instruments = instruments[:5]
+-        print(f"选择演示股票: {demo_instruments}")
+-        
+-    except Exception as e:
+-        print(f"获取股票列表失败: {e}")
+-        # 使用默认股票列表
+-        demo_instruments = ['000001.SZ', '000002.SZ', '000858.SZ', '002415.SZ', '600036.SH']
+-        print(f"使用默认股票列表: {demo_instruments}")
+-    
+-    # 获取价格数据
+-    data = get_stock_data(demo_instruments, start_date, end_date)
+-    
+-    if data is None:
+-        print("无法获取数据，程序退出")
+-        return
+-    
+-    print(f"获取到价格数据，形状: {data.shape}")
+-    
+-    # 计算均线信号
+-    signals = calculate_ma_signals(data, short_window, long_window)
+-    
+-    # 计算收益
+-    returns_data = calculate_returns(data, signals, initial_capital)
+-    
+-    # 分析策略
+-    analyze_strategy(signals, returns_data)
+-    
+-    # 保存结果
+-    signals.to_csv("ma_cross_signals.csv")
+-    returns_data['cumulative_returns'].to_csv("ma_cross_cumulative_returns.csv")
+-    returns_data['capital_curve'].to_csv("ma_cross_capital_curve.csv")
+-    
+-    print("\n结果已保存到CSV文件:")
+-    print("- ma_cross_signals.csv: 买卖信号")
+-    print("- ma_cross_cumulative_returns.csv: 累计收益")
+-    print("- ma_cross_capital_curve.csv: 资金曲线")
+-    
+-    # 绘制图表（选择第一只股票）
+-    if len(demo_instruments) > 0:
+-        try:
+-            plot_results(data, signals, returns_data, demo_instruments[0])
+-            print("图表已保存为 ma_cross_strategy_results.png")
+-        except Exception as e:
+-            print(f"绘制图表失败: {e}")
+-    
+-    print("\n策略回测完成！")
+-
+-
+-if __name__ == "__main__":
+-    main() 
+\ No newline at end of file
+diff --git a/test/two_ema_stragety.py b/test/two_ema_stragety.py
+index a72e7e8..a9890c7 100644
+--- a/test/two_ema_stragety.py
++++ b/test/two_ema_stragety.py
+@@ -1,2 +1,98 @@
+-from qlib.contrib.strategy import 
+-from qlib.backtest import backtest
+\ No newline at end of file
++import pandas as pd
++
++from abc import ABC
++from typing import Dict, List, Text, Tuple, Union
++from qlib.data.dataset import Dataset
++from qlib.model.base import BaseModel
++from qlib.backtest.signal import Signal, create_signal_from
++from qlib.strategy.base import BaseStrategy
++from qlib.backtest.decision import Order, OrderDir, OrderHelper, TradeDecisionWO
++# from qlib.strategy import 
++# from qlib.backtest import backtest
++
++class InnerStrategy(BaseStrategy):
++    """
++    Inner strategy for order execution:
++    - Buy: if price < 200, buy all cash; else buy 200,000 worth.
++    - Sell: if price > 200, sell all; else sell half.
++    """
++    STOCK_CODE = "000858.SZ"
++
++    def generate_trade_decision(self, execute_result: list = None, action: str = None, amount: float = None):
++        # action: 'buy' or 'sell', amount: suggested amount (shares) from outer
++        position = self.trade_position
++        trade_step = self.trade_calendar.get_trade_step()
++        trade_start_time, trade_end_time = self.trade_calendar.get_step_time(trade_step)
++        order_helper = self.trade_exchange.get_order_helper()
++        orders = []
++        price = self.trade_exchange.get_deal_price(self.STOCK_CODE, trade_start_time, trade_end_time)
++        if action == 'buy':
++            cash = position.get_cash()
++            if price <= 0:
++                return TradeDecisionWO([], self)
++            if price < 200:
++                buy_amount = cash // price
++            else:
++                buy_amount = min(cash // price, 200000 // price)
++            buy_amount = int(buy_amount)
++            if buy_amount > 0:
++                order = order_helper.create(
++                    code=self.STOCK_CODE,
++                    amount=buy_amount,
++                    direction=OrderDir.BUY,
++                    start_time=trade_start_time,
++                    end_time=trade_end_time,
++                )
++                orders.append(order)
++        elif action == 'sell':
++            held_amount = position.get_stock_amount(self.STOCK_CODE)
++            if held_amount <= 0 or price <= 0:
++                return TradeDecisionWO([], self)
++            if price > 200:
++                sell_amount = held_amount
++            else:
++                sell_amount = held_amount // 2
++            sell_amount = int(sell_amount)
++            if sell_amount > 0:
++                order = order_helper.create(
++                    code=self.STOCK_CODE,
++                    amount=sell_amount,
++                    direction=OrderDir.SELL,
++                    start_time=trade_start_time,
++                    end_time=trade_end_time,
++                )
++                orders.append(order)
++        return TradeDecisionWO(orders, self)
++
++class OuterStrategy(BaseStrategy):
++    """
++    Outer strategy:
++    - If not holding Wuliangye, issues a buy order via inner strategy.
++    - If holding, checks if held for 25 days, if so, issues a sell order via inner strategy.
++    - Otherwise, holds.
++    """
++    STOCK_CODE = "000858.SZ"
++    HOLD_DAYS = 25
++    BAR = "day"
++
++    def __init__(self, *args, **kwargs):
++        super().__init__(*args, **kwargs)
++        self.inner_strategy = InnerStrategy()
++
++    def generate_trade_decision(self, execute_result: list = None):
++        position = self.trade_position
++        stock_list = position.get_stock_list()
++        trade_step = self.trade_calendar.get_trade_step()
++        trade_start_time, trade_end_time = self.trade_calendar.get_step_time(trade_step)
++        # Pass infra to inner strategy
++        self.inner_strategy.reset(level_infra=self.level_infra, common_infra=self.common_infra)
++        if self.STOCK_CODE in stock_list:
++            hold_days = position.get_stock_count(self.STOCK_CODE, self.BAR)
++            if hold_days >= self.HOLD_DAYS:
++                # Sell via inner strategy
++                return self.inner_strategy.generate_trade_decision(action='sell')
++        else:
++            # Buy via inner strategy
++            return self.inner_strategy.generate_trade_decision(action='buy')
++        # Otherwise, hold
++        return TradeDecisionWO([], self)
+\ No newline at end of file
diff --git a/mlruns/812028854715931404/6154317dbc1f4340860562a026af9481/artifacts/code_status.txt b/mlruns/812028854715931404/6154317dbc1f4340860562a026af9481/artifacts/code_status.txt
new file mode 100644
index 0000000..35a35fa
--- /dev/null
+++ b/mlruns/812028854715931404/6154317dbc1f4340860562a026af9481/artifacts/code_status.txt
@@ -0,0 +1,22 @@
+On branch main
+Your branch is up to date with 'origin/main'.
+
+Changes not staged for commit:
+  (use "git add/rm <file>..." to update what will be committed)
+  (use "git restore <file>..." to discard changes in working directory)
+	deleted:    test/README_MA_Strategy.md
+	modified:   test/damo1.py
+	deleted:    test/ma_cross_strategy.py
+	deleted:    test/ma_cross_strategy_improved.py
+	deleted:    test/ma_strategy_demo.py
+	deleted:    test/simple_ma_strategy.py
+	modified:   test/two_ema_stragety.py
+
+Untracked files:
+  (use "git add <file>..." to include in what will be committed)
+	mlruns/
+	test/__pycache__/
+	test/buy_and_hold.py
+	test/workflow_by_code.py
+
+no changes added to commit (use "git add" and/or "git commit -a")
diff --git a/mlruns/812028854715931404/6154317dbc1f4340860562a026af9481/meta.yaml b/mlruns/812028854715931404/6154317dbc1f4340860562a026af9481/meta.yaml
new file mode 100644
index 0000000..34b0e5b
--- /dev/null
+++ b/mlruns/812028854715931404/6154317dbc1f4340860562a026af9481/meta.yaml
@@ -0,0 +1,14 @@
+artifact_uri: file:D:\project\python\tradenote\mlruns/812028854715931404/6154317dbc1f4340860562a026af9481/artifacts
+end_time: 1750317860802
+entry_point_name: ''
+experiment_id: '812028854715931404'
+lifecycle_stage: active
+run_id: 6154317dbc1f4340860562a026af9481
+run_name: mlflow_recorder
+source_name: ''
+source_type: 4
+source_version: ''
+start_time: 1750317860544
+status: 3
+tags: []
+user_id: abulimity
diff --git a/mlruns/812028854715931404/6154317dbc1f4340860562a026af9481/params/cmd-sys.argv b/mlruns/812028854715931404/6154317dbc1f4340860562a026af9481/params/cmd-sys.argv
new file mode 100644
index 0000000..db800eb
--- /dev/null
+++ b/mlruns/812028854715931404/6154317dbc1f4340860562a026af9481/params/cmd-sys.argv
@@ -0,0 +1 @@
+D:\project\python\tradenote\test\workflow_by_code.py
\ No newline at end of file
diff --git a/mlruns/812028854715931404/6154317dbc1f4340860562a026af9481/tags/mlflow.runName b/mlruns/812028854715931404/6154317dbc1f4340860562a026af9481/tags/mlflow.runName
new file mode 100644
index 0000000..25487e4
--- /dev/null
+++ b/mlruns/812028854715931404/6154317dbc1f4340860562a026af9481/tags/mlflow.runName
@@ -0,0 +1 @@
+mlflow_recorder
\ No newline at end of file
diff --git a/mlruns/812028854715931404/6154317dbc1f4340860562a026af9481/tags/mlflow.source.git.commit b/mlruns/812028854715931404/6154317dbc1f4340860562a026af9481/tags/mlflow.source.git.commit
new file mode 100644
index 0000000..288ce21
--- /dev/null
+++ b/mlruns/812028854715931404/6154317dbc1f4340860562a026af9481/tags/mlflow.source.git.commit
@@ -0,0 +1 @@
+0daea9b5bbb40120a1bc07c702d171abc1f219c7
\ No newline at end of file
diff --git a/mlruns/812028854715931404/6154317dbc1f4340860562a026af9481/tags/mlflow.source.name b/mlruns/812028854715931404/6154317dbc1f4340860562a026af9481/tags/mlflow.source.name
new file mode 100644
index 0000000..db800eb
--- /dev/null
+++ b/mlruns/812028854715931404/6154317dbc1f4340860562a026af9481/tags/mlflow.source.name
@@ -0,0 +1 @@
+D:\project\python\tradenote\test\workflow_by_code.py
\ No newline at end of file
diff --git a/mlruns/812028854715931404/6154317dbc1f4340860562a026af9481/tags/mlflow.source.type b/mlruns/812028854715931404/6154317dbc1f4340860562a026af9481/tags/mlflow.source.type
new file mode 100644
index 0000000..0c2c1fe
--- /dev/null
+++ b/mlruns/812028854715931404/6154317dbc1f4340860562a026af9481/tags/mlflow.source.type
@@ -0,0 +1 @@
+LOCAL
\ No newline at end of file
diff --git a/mlruns/812028854715931404/6154317dbc1f4340860562a026af9481/tags/mlflow.user b/mlruns/812028854715931404/6154317dbc1f4340860562a026af9481/tags/mlflow.user
new file mode 100644
index 0000000..b9cec6f
--- /dev/null
+++ b/mlruns/812028854715931404/6154317dbc1f4340860562a026af9481/tags/mlflow.user
@@ -0,0 +1 @@
+abulimity
\ No newline at end of file
diff --git a/mlruns/812028854715931404/7d7942a2c1de450a97d231f84eb4a244/artifacts/code_cached.txt b/mlruns/812028854715931404/7d7942a2c1de450a97d231f84eb4a244/artifacts/code_cached.txt
new file mode 100644
index 0000000..e69de29
diff --git a/mlruns/812028854715931404/7d7942a2c1de450a97d231f84eb4a244/artifacts/code_diff.txt b/mlruns/812028854715931404/7d7942a2c1de450a97d231f84eb4a244/artifacts/code_diff.txt
new file mode 100644
index 0000000..067487e
--- /dev/null
+++ b/mlruns/812028854715931404/7d7942a2c1de450a97d231f84eb4a244/artifacts/code_diff.txt
@@ -0,0 +1,1508 @@
+diff --git a/github/examples/benchmarks/LightGBM/workflow_config_lightgbm_Alpha1582.yaml b/github/examples/benchmarks/LightGBM/workflow_config_lightgbm_Alpha1582.yaml
+index 8b4e7bf..7a5eee7 100644
+--- a/github/examples/benchmarks/LightGBM/workflow_config_lightgbm_Alpha1582.yaml
++++ b/github/examples/benchmarks/LightGBM/workflow_config_lightgbm_Alpha1582.yaml
+@@ -1,5 +1,5 @@
+ qlib_init:
+-    provider_uri: "D:/project/tradenote/qlib_data/cn_data"
++    provider_uri: "D:/sync/qlib/qlib_data/cn_data"
+     region: cn
+ market: &market csi300
+ benchmark: &benchmark SH000300
+diff --git a/test/README_MA_Strategy.md b/test/README_MA_Strategy.md
+deleted file mode 100644
+index 5facaf7..0000000
+--- a/test/README_MA_Strategy.md
++++ /dev/null
+@@ -1,197 +0,0 @@
+-# 均线交叉策略 (Moving Average Crossover Strategy)
+-
+-## 策略概述
+-
+-这是一个基于qlib框架实现的均线交叉策略，核心逻辑是：
+-- **金叉买入**：短期均线上穿长期均线时买入
+-- **死叉卖出**：短期均线下穿长期均线时卖出
+-
+-## 文件说明
+-
+-### 1. `ma_cross_strategy.py`
+-完整的策略实现，包含：
+-- `MACrossStrategy` 类：继承自qlib的TopkDropoutStrategy
+-- 完整的回测框架
+-- 结果分析和保存
+-
+-### 2. `ma_cross_strategy_improved.py`
+-改进版本，包含：
+-- 更完善的数据获取逻辑
+-- 错误处理机制
+-- 简化版回测功能
+-
+-### 3. `simple_ma_strategy.py` ⭐ **推荐使用**
+-简单实用的版本，包含：
+-- 清晰的数据获取和处理
+-- 均线信号计算
+-- 收益计算和分析
+-- 可视化图表生成
+-- 结果保存功能
+-
+-## 使用方法
+-
+-### 环境准备
+-
+-1. 确保已安装qlib：
+-```bash
+-pip install pyqlib
+-```
+-
+-2. 下载qlib数据（如果还没有）：
+-```bash
+-# 下载中国股票数据
+-python -m qlib.data.dump_bin --csv_path ~/.qlib/qlib_data/cn_data --include_fields close,open,high,low,volume
+-```
+-
+-### 运行策略
+-
+-#### 方法1：运行简单版本（推荐）
+-```bash
+-cd test
+-python simple_ma_strategy.py
+-```
+-
+-#### 方法2：运行完整版本
+-```bash
+-cd test
+-python ma_cross_strategy.py
+-```
+-
+-#### 方法3：运行改进版本
+-```bash
+-cd test
+-python ma_cross_strategy_improved.py
+-```
+-
+-## 策略参数
+-
+-可以在代码中修改以下参数：
+-
+-```python
+-# 均线周期
+-short_window = 5    # 短期均线周期
+-long_window = 20    # 长期均线周期
+-
+-# 回测时间
+-start_date = "2020-01-01"
+-end_date = "2023-12-31"
+-
+-# 初始资金
+-initial_capital = 100000
+-
+-# 股票池
+-instruments = "csi300"  # 沪深300成分股
+-```
+-
+-## 输出结果
+-
+-运行策略后会生成以下文件：
+-
+-1. **CSV文件**：
+-   - `ma_cross_signals.csv`：买卖信号数据
+-   - `ma_cross_cumulative_returns.csv`：累计收益数据
+-   - `ma_cross_capital_curve.csv`：资金曲线数据
+-
+-2. **图表文件**：
+-   - `ma_cross_strategy_results.png`：策略结果可视化图表
+-
+-3. **控制台输出**：
+-   - 策略分析结果
+-   - 收益统计
+-   - 风险指标
+-
+-## 策略分析指标
+-
+-### 收益指标
+-- 总收益率
+-- 年化收益率
+-- 最终资金
+-
+-### 风险指标
+-- 年化波动率
+-- 夏普比率
+-- 胜率
+-- 最大回撤
+-
+-### 交易统计
+-- 买入信号数量
+-- 卖出信号数量
+-- 总交易次数
+-
+-## 策略逻辑详解
+-
+-### 1. 均线计算
+-```python
+-# 计算短期和长期均线
+-short_ma = price_data.rolling(window=short_window).mean()
+-long_ma = price_data.rolling(window=long_window).mean()
+-```
+-
+-### 2. 交叉信号判断
+-```python
+-# 计算均线差值
+-diff = short_ma - long_ma
+-
+-# 金叉：短期均线从下方穿越长期均线
+-if diff.iloc[i-1] < 0 and diff.iloc[i] > 0:
+-    signal = 1  # 买入信号
+-
+-# 死叉：短期均线从上方穿越长期均线
+-elif diff.iloc[i-1] > 0 and diff.iloc[i] < 0:
+-    signal = -1  # 卖出信号
+-```
+-
+-### 3. 收益计算
+-```python
+-# 策略收益（简化处理）
+-strategy_returns = signals * 0.01
+-
+-# 累计收益
+-cumulative_returns = strategy_returns.sum(axis=1).cumsum()
+-```
+-
+-## 注意事项
+-
+-1. **数据依赖**：确保qlib数据已正确下载和配置
+-2. **参数调优**：可以根据不同市场环境调整均线周期
+-3. **风险控制**：实际交易中需要加入止损和仓位管理
+-4. **交易成本**：当前版本未考虑交易费用，实际应用需要考虑
+-
+-## 扩展功能
+-
+-可以基于此策略进行以下扩展：
+-
+-1. **多均线策略**：使用多条均线进行更复杂的信号判断
+-2. **量价配合**：结合成交量指标优化信号
+-3. **止损机制**：添加动态止损策略
+-4. **仓位管理**：根据信号强度调整仓位大小
+-5. **多股票组合**：构建股票组合分散风险
+-
+-## 常见问题
+-
+-### Q: 如何修改股票池？
+-A: 在代码中修改 `instruments` 参数，例如：
+-```python
+-instruments = "csi500"  # 中证500
+-instruments = ["000001.SZ", "000002.SZ"]  # 指定股票列表
+-```
+-
+-### Q: 如何调整均线周期？
+-A: 修改 `short_window` 和 `long_window` 参数：
+-```python
+-short_window = 10  # 10日均线
+-long_window = 30   # 30日均线
+-```
+-
+-### Q: 如何查看详细的交易记录？
+-A: 查看生成的 `ma_cross_signals.csv` 文件，其中包含每日的买卖信号。
+-
+-## 联系方式
+-
+-如有问题或建议，请通过以下方式联系：
+-- 提交Issue到项目仓库
+-- 发送邮件到项目维护者
+-
+----
+-
+-**免责声明**：本策略仅供学习和研究使用，不构成投资建议。实际投资请谨慎决策，并承担相应风险。 
+\ No newline at end of file
+diff --git a/test/damo1.py b/test/damo1.py
+index 03102e1..afa2886 100644
+--- a/test/damo1.py
++++ b/test/damo1.py
+@@ -1,9 +1,35 @@
+-# python scripts/get_data.py qlib_data --target_dir ../qlib_data/cn_data --region cn
+-
+ import qlib
+-# region in [REG_CN, REG_US]
+-from qlib.constant import REG_CN
+-provider_uri = "D:/project/tradenote/qlib_data/cn_data"  # target_dir
+-qlib.init(provider_uri=provider_uri, region=REG_CN)
++from qlib.data import D
++
++# 初始化 Qlib
++qlib.init(provider_uri="D:/sync/qlib/qlib_data/cn_data", region="cn")
++
++# 检查目标股票和基准
++stock_code = "SZ000858"  # 你的BuyHold策略用的股票代码
++benchmark = "SH000300"
++
++print("--- 检查可用股票列表（前10只） ---")
++print(list(D.instruments(market="all"))[:10])
++
++print("--- 检查交易日（2017-01-01 ~ 2020-08-01，前10天） ---")
++print(D.calendar(start_time="2017-01-01", end_time="2020-08-01")[:10])
++
++print(f"--- 检查目标股票 {stock_code} 是否在股票池 ---")
++print(stock_code in D.instruments(market="all"))
++
++print(f"--- 检查基准 {benchmark} 是否在股票池 ---")
++print(benchmark in D.instruments(market="all"))
++
++print(f"--- 检查目标股票 {stock_code} 的行情数据（前5行） ---")
++try:
++    df = D.features([stock_code], ["$close", "$open", "$high", "$low", "$volume"], start_time="2017-01-01", end_time="2020-08-01")
++    print(df.head())
++except Exception as e:
++    print(f"获取行情数据失败: {e}")
+ 
+-# qrun benchmarks/LightGBM/workflow_config_lightgbm_Alpha1582.yaml
++print(f"--- 检查基准 {benchmark} 的行情数据（前5行） ---")
++try:
++    df_bench = D.features([benchmark], ["$close"], start_time="2017-01-01", end_time="2020-08-01")
++    print(df_bench.head())
++except Exception as e:
++    print(f"获取基准行情数据失败: {e}")
+diff --git a/test/demo2.ipynb b/test/demo2.ipynb
+index 66a0215..ad02df5 100644
+--- a/test/demo2.ipynb
++++ b/test/demo2.ipynb
+@@ -2,7 +2,7 @@
+  "cells": [
+   {
+    "cell_type": "code",
+-   "execution_count": 4,
++   "execution_count": 12,
+    "id": "6acb4a77",
+    "metadata": {},
+    "outputs": [
+@@ -10,39 +10,75 @@
+      "name": "stderr",
+      "output_type": "stream",
+      "text": [
+-      "[5344:MainThread](2025-06-18 14:41:03,895) INFO - qlib.Initialization - [config.py:420] - default_conf: client.\n",
+-      "[5344:MainThread](2025-06-18 14:41:03,900) INFO - qlib.Initialization - [__init__.py:74] - qlib successfully initialized based on client settings.\n",
+-      "[5344:MainThread](2025-06-18 14:41:03,903) INFO - qlib.Initialization - [__init__.py:76] - data_path={'__DEFAULT_FREQ': WindowsPath('D:/sync/qlib/qlib_data/cn_data')}\n"
++      "[13736:MainThread](2025-06-19 15:30:19,504) INFO - qlib.Initialization - [config.py:420] - default_conf: client.\n",
++      "[13736:MainThread](2025-06-19 15:30:19,506) INFO - qlib.Initialization - [__init__.py:74] - qlib successfully initialized based on client settings.\n",
++      "[13736:MainThread](2025-06-19 15:30:19,508) INFO - qlib.Initialization - [__init__.py:76] - data_path={'__DEFAULT_FREQ': WindowsPath('D:/sync/qlib/qlib_data/cn_data')}\n"
+      ]
+     }
+    ],
+    "source": [
+     "import qlib\n",
+-    "qlib.init(provider_uri=\"D:/sync/qlib/qlib_data/cn_data\", region=\"cn\")"
++    "qlib.init(provider_uri=r\"D:\\sync\\qlib\\qlib_data\\cn_data\", region=\"cn\")"
+    ]
+   },
+   {
+    "cell_type": "code",
+-   "execution_count": 12,
++   "execution_count": 14,
+    "id": "295df9af",
+    "metadata": {},
+    "outputs": [
+     {
+      "data": {
+       "text/plain": [
+-       "array([Timestamp('2020-09-21 00:00:00'), Timestamp('2020-09-22 00:00:00'),\n",
+-       "       Timestamp('2020-09-23 00:00:00'), Timestamp('2020-09-24 00:00:00'),\n",
+-       "       Timestamp('2020-09-25 00:00:00')], dtype=object)"
++       "array([Timestamp('2017-01-03 00:00:00'), Timestamp('2017-01-04 00:00:00'),\n",
++       "       Timestamp('2017-01-05 00:00:00'), Timestamp('2017-01-06 00:00:00'),\n",
++       "       Timestamp('2017-01-09 00:00:00')], dtype=object)"
+       ]
+      },
+-     "execution_count": 12,
++     "execution_count": 14,
+      "metadata": {},
+      "output_type": "execute_result"
+     }
+    ],
+    "source": [
+     "from qlib.data import D\n",
+-    "D.calendar(start_time='2020-09-21', end_time='2020-10-30', freq='day')"
++    "D.calendar(start_time=\"2017-01-01\", end_time=\"2020-08-01\",freq=\"day\")[:5]"
++   ]
++  },
++  {
++   "cell_type": "code",
++   "execution_count": 21,
++   "id": "da009afa",
++   "metadata": {},
++   "outputs": [
++    {
++     "ename": "error",
++     "evalue": "nothing to repeat at position 0",
++     "output_type": "error",
++     "traceback": [
++      "\u001b[31m---------------------------------------------------------------------------\u001b[39m",
++      "\u001b[31merror\u001b[39m                                     Traceback (most recent call last)",
++      "\u001b[36mCell\u001b[39m\u001b[36m \u001b[39m\u001b[32mIn[21]\u001b[39m\u001b[32m, line 4\u001b[39m\n\u001b[32m      2\u001b[39m nameDFilter = NameDFilter(name_rule_re=\u001b[33m'\u001b[39m\u001b[33m*000858\u001b[39m\u001b[33m'\u001b[39m)\n\u001b[32m      3\u001b[39m instruments = D.instruments(market=\u001b[33m'\u001b[39m\u001b[33mall\u001b[39m\u001b[33m'\u001b[39m,filter_pipe=[nameDFilter])\n\u001b[32m----> \u001b[39m\u001b[32m4\u001b[39m \u001b[43mD\u001b[49m\u001b[43m.\u001b[49m\u001b[43mlist_instruments\u001b[49m\u001b[43m(\u001b[49m\u001b[43minstruments\u001b[49m\u001b[43m=\u001b[49m\u001b[43minstruments\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mstart_time\u001b[49m\u001b[43m=\u001b[49m\u001b[33;43m'\u001b[39;49m\u001b[33;43m2015-01-01\u001b[39;49m\u001b[33;43m'\u001b[39;49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mend_time\u001b[49m\u001b[43m=\u001b[49m\u001b[33;43m'\u001b[39;49m\u001b[33;43m2016-02-15\u001b[39;49m\u001b[33;43m'\u001b[39;49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mas_list\u001b[49m\u001b[43m=\u001b[49m\u001b[38;5;28;43;01mTrue\u001b[39;49;00m\u001b[43m)\u001b[49m\n",
++      "\u001b[36mFile \u001b[39m\u001b[32md:\\project\\python\\tradenote\\.venv\\Lib\\site-packages\\qlib\\data\\data.py:1160\u001b[39m, in \u001b[36mBaseProvider.list_instruments\u001b[39m\u001b[34m(self, instruments, start_time, end_time, freq, as_list)\u001b[39m\n\u001b[32m   1159\u001b[39m \u001b[38;5;28;01mdef\u001b[39;00m\u001b[38;5;250m \u001b[39m\u001b[34mlist_instruments\u001b[39m(\u001b[38;5;28mself\u001b[39m, instruments, start_time=\u001b[38;5;28;01mNone\u001b[39;00m, end_time=\u001b[38;5;28;01mNone\u001b[39;00m, freq=\u001b[33m\"\u001b[39m\u001b[33mday\u001b[39m\u001b[33m\"\u001b[39m, as_list=\u001b[38;5;28;01mFalse\u001b[39;00m):\n\u001b[32m-> \u001b[39m\u001b[32m1160\u001b[39m     \u001b[38;5;28;01mreturn\u001b[39;00m \u001b[43mInst\u001b[49m\u001b[43m.\u001b[49m\u001b[43mlist_instruments\u001b[49m\u001b[43m(\u001b[49m\u001b[43minstruments\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mstart_time\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mend_time\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mfreq\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mas_list\u001b[49m\u001b[43m)\u001b[49m\n",
++      "\u001b[36mFile \u001b[39m\u001b[32md:\\project\\python\\tradenote\\.venv\\Lib\\site-packages\\qlib\\data\\data.py:719\u001b[39m, in \u001b[36mLocalInstrumentProvider.list_instruments\u001b[39m\u001b[34m(self, instruments, start_time, end_time, freq, as_list)\u001b[39m\n\u001b[32m    716\u001b[39m     \u001b[38;5;28;01mfrom\u001b[39;00m\u001b[38;5;250m \u001b[39m\u001b[34;01m.\u001b[39;00m\u001b[38;5;250m \u001b[39m\u001b[38;5;28;01mimport\u001b[39;00m \u001b[38;5;28mfilter\u001b[39m \u001b[38;5;28;01mas\u001b[39;00m F  \u001b[38;5;66;03m# pylint: disable=C0415\u001b[39;00m\n\u001b[32m    718\u001b[39m     filter_t = \u001b[38;5;28mgetattr\u001b[39m(F, filter_config[\u001b[33m\"\u001b[39m\u001b[33mfilter_type\u001b[39m\u001b[33m\"\u001b[39m]).from_config(filter_config)\n\u001b[32m--> \u001b[39m\u001b[32m719\u001b[39m     _instruments_filtered = \u001b[43mfilter_t\u001b[49m\u001b[43m(\u001b[49m\u001b[43m_instruments_filtered\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mstart_time\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mend_time\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mfreq\u001b[49m\u001b[43m)\u001b[49m\n\u001b[32m    720\u001b[39m \u001b[38;5;66;03m# as list\u001b[39;00m\n\u001b[32m    721\u001b[39m \u001b[38;5;28;01mif\u001b[39;00m as_list:\n",
++      "\u001b[36mFile \u001b[39m\u001b[32md:\\project\\python\\tradenote\\.venv\\Lib\\site-packages\\qlib\\data\\filter.py:192\u001b[39m, in \u001b[36mSeriesDFilter.__call__\u001b[39m\u001b[34m(self, instruments, start_time, end_time, freq)\u001b[39m\n\u001b[32m    190\u001b[39m \u001b[38;5;250m\u001b[39m\u001b[33;03m\"\"\"Call this filter to get filtered instruments list\"\"\"\u001b[39;00m\n\u001b[32m    191\u001b[39m \u001b[38;5;28mself\u001b[39m.filter_freq = freq\n\u001b[32m--> \u001b[39m\u001b[32m192\u001b[39m \u001b[38;5;28;01mreturn\u001b[39;00m \u001b[38;5;28;43mself\u001b[39;49m\u001b[43m.\u001b[49m\u001b[43mfilter_main\u001b[49m\u001b[43m(\u001b[49m\u001b[43minstruments\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mstart_time\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mend_time\u001b[49m\u001b[43m)\u001b[49m\n",
++      "\u001b[36mFile \u001b[39m\u001b[32md:\\project\\python\\tradenote\\.venv\\Lib\\site-packages\\qlib\\data\\filter.py:243\u001b[39m, in \u001b[36mSeriesDFilter.filter_main\u001b[39m\u001b[34m(self, instruments, start_time, end_time)\u001b[39m\n\u001b[32m    237\u001b[39m _all_calendar = Cal.calendar(start_time=start_time, end_time=end_time, freq=\u001b[38;5;28mself\u001b[39m.filter_freq)\n\u001b[32m    238\u001b[39m _filter_calendar = Cal.calendar(\n\u001b[32m    239\u001b[39m     start_time=\u001b[38;5;28mself\u001b[39m.filter_start_time \u001b[38;5;129;01mand\u001b[39;00m \u001b[38;5;28mmax\u001b[39m(\u001b[38;5;28mself\u001b[39m.filter_start_time, _all_calendar[\u001b[32m0\u001b[39m]) \u001b[38;5;129;01mor\u001b[39;00m _all_calendar[\u001b[32m0\u001b[39m],\n\u001b[32m    240\u001b[39m     end_time=\u001b[38;5;28mself\u001b[39m.filter_end_time \u001b[38;5;129;01mand\u001b[39;00m \u001b[38;5;28mmin\u001b[39m(\u001b[38;5;28mself\u001b[39m.filter_end_time, _all_calendar[-\u001b[32m1\u001b[39m]) \u001b[38;5;129;01mor\u001b[39;00m _all_calendar[-\u001b[32m1\u001b[39m],\n\u001b[32m    241\u001b[39m     freq=\u001b[38;5;28mself\u001b[39m.filter_freq,\n\u001b[32m    242\u001b[39m )\n\u001b[32m--> \u001b[39m\u001b[32m243\u001b[39m _all_filter_series = \u001b[38;5;28;43mself\u001b[39;49m\u001b[43m.\u001b[49m\u001b[43m_getFilterSeries\u001b[49m\u001b[43m(\u001b[49m\u001b[43minstruments\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43m_filter_calendar\u001b[49m\u001b[43m[\u001b[49m\u001b[32;43m0\u001b[39;49m\u001b[43m]\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43m_filter_calendar\u001b[49m\u001b[43m[\u001b[49m\u001b[43m-\u001b[49m\u001b[32;43m1\u001b[39;49m\u001b[43m]\u001b[49m\u001b[43m)\u001b[49m\n\u001b[32m    244\u001b[39m \u001b[38;5;28;01mfor\u001b[39;00m inst, timestamp \u001b[38;5;129;01min\u001b[39;00m instruments.items():\n\u001b[32m    245\u001b[39m     \u001b[38;5;66;03m# Construct a whole map of date\u001b[39;00m\n\u001b[32m    246\u001b[39m     _timestamp_series = \u001b[38;5;28mself\u001b[39m._toSeries(_all_calendar, timestamp)\n",
++      "\u001b[36mFile \u001b[39m\u001b[32md:\\project\\python\\tradenote\\.venv\\Lib\\site-packages\\qlib\\data\\filter.py:288\u001b[39m, in \u001b[36mNameDFilter._getFilterSeries\u001b[39m\u001b[34m(self, instruments, fstart, fend)\u001b[39m\n\u001b[32m    286\u001b[39m filter_calendar = Cal.calendar(start_time=fstart, end_time=fend, freq=\u001b[38;5;28mself\u001b[39m.filter_freq)\n\u001b[32m    287\u001b[39m \u001b[38;5;28;01mfor\u001b[39;00m inst, timestamp \u001b[38;5;129;01min\u001b[39;00m instruments.items():\n\u001b[32m--> \u001b[39m\u001b[32m288\u001b[39m     \u001b[38;5;28;01mif\u001b[39;00m \u001b[43mre\u001b[49m\u001b[43m.\u001b[49m\u001b[43mmatch\u001b[49m\u001b[43m(\u001b[49m\u001b[38;5;28;43mself\u001b[39;49m\u001b[43m.\u001b[49m\u001b[43mname_rule_re\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43minst\u001b[49m\u001b[43m)\u001b[49m:\n\u001b[32m    289\u001b[39m         _filter_series = pd.Series({timestamp: \u001b[38;5;28;01mTrue\u001b[39;00m \u001b[38;5;28;01mfor\u001b[39;00m timestamp \u001b[38;5;129;01min\u001b[39;00m filter_calendar})\n\u001b[32m    290\u001b[39m     \u001b[38;5;28;01melse\u001b[39;00m:\n",
++      "\u001b[36mFile \u001b[39m\u001b[32m~\\AppData\\Roaming\\uv\\python\\cpython-3.12.11-windows-x86_64-none\\Lib\\re\\__init__.py:167\u001b[39m, in \u001b[36mmatch\u001b[39m\u001b[34m(pattern, string, flags)\u001b[39m\n\u001b[32m    164\u001b[39m \u001b[38;5;28;01mdef\u001b[39;00m\u001b[38;5;250m \u001b[39m\u001b[34mmatch\u001b[39m(pattern, string, flags=\u001b[32m0\u001b[39m):\n\u001b[32m    165\u001b[39m \u001b[38;5;250m    \u001b[39m\u001b[33;03m\"\"\"Try to apply the pattern at the start of the string, returning\u001b[39;00m\n\u001b[32m    166\u001b[39m \u001b[33;03m    a Match object, or None if no match was found.\"\"\"\u001b[39;00m\n\u001b[32m--> \u001b[39m\u001b[32m167\u001b[39m     \u001b[38;5;28;01mreturn\u001b[39;00m \u001b[43m_compile\u001b[49m\u001b[43m(\u001b[49m\u001b[43mpattern\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mflags\u001b[49m\u001b[43m)\u001b[49m.match(string)\n",
++      "\u001b[36mFile \u001b[39m\u001b[32m~\\AppData\\Roaming\\uv\\python\\cpython-3.12.11-windows-x86_64-none\\Lib\\re\\__init__.py:307\u001b[39m, in \u001b[36m_compile\u001b[39m\u001b[34m(pattern, flags)\u001b[39m\n\u001b[32m    301\u001b[39m     \u001b[38;5;28;01mimport\u001b[39;00m\u001b[38;5;250m \u001b[39m\u001b[34;01mwarnings\u001b[39;00m\n\u001b[32m    302\u001b[39m     warnings.warn(\u001b[33m\"\u001b[39m\u001b[33mThe re.TEMPLATE/re.T flag is deprecated \u001b[39m\u001b[33m\"\u001b[39m\n\u001b[32m    303\u001b[39m             \u001b[33m\"\u001b[39m\u001b[33mas it is an undocumented flag \u001b[39m\u001b[33m\"\u001b[39m\n\u001b[32m    304\u001b[39m             \u001b[33m\"\u001b[39m\u001b[33mwithout an obvious purpose. \u001b[39m\u001b[33m\"\u001b[39m\n\u001b[32m    305\u001b[39m             \u001b[33m\"\u001b[39m\u001b[33mDon\u001b[39m\u001b[33m'\u001b[39m\u001b[33mt use it.\u001b[39m\u001b[33m\"\u001b[39m,\n\u001b[32m    306\u001b[39m             \u001b[38;5;167;01mDeprecationWarning\u001b[39;00m)\n\u001b[32m--> \u001b[39m\u001b[32m307\u001b[39m p = \u001b[43m_compiler\u001b[49m\u001b[43m.\u001b[49m\u001b[43mcompile\u001b[49m\u001b[43m(\u001b[49m\u001b[43mpattern\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mflags\u001b[49m\u001b[43m)\u001b[49m\n\u001b[32m    308\u001b[39m \u001b[38;5;28;01mif\u001b[39;00m flags & DEBUG:\n\u001b[32m    309\u001b[39m     \u001b[38;5;28;01mreturn\u001b[39;00m p\n",
++      "\u001b[36mFile \u001b[39m\u001b[32m~\\AppData\\Roaming\\uv\\python\\cpython-3.12.11-windows-x86_64-none\\Lib\\re\\_compiler.py:750\u001b[39m, in \u001b[36mcompile\u001b[39m\u001b[34m(p, flags)\u001b[39m\n\u001b[32m    748\u001b[39m \u001b[38;5;28;01mif\u001b[39;00m isstring(p):\n\u001b[32m    749\u001b[39m     pattern = p\n\u001b[32m--> \u001b[39m\u001b[32m750\u001b[39m     p = \u001b[43m_parser\u001b[49m\u001b[43m.\u001b[49m\u001b[43mparse\u001b[49m\u001b[43m(\u001b[49m\u001b[43mp\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mflags\u001b[49m\u001b[43m)\u001b[49m\n\u001b[32m    751\u001b[39m \u001b[38;5;28;01melse\u001b[39;00m:\n\u001b[32m    752\u001b[39m     pattern = \u001b[38;5;28;01mNone\u001b[39;00m\n",
++      "\u001b[36mFile \u001b[39m\u001b[32m~\\AppData\\Roaming\\uv\\python\\cpython-3.12.11-windows-x86_64-none\\Lib\\re\\_parser.py:979\u001b[39m, in \u001b[36mparse\u001b[39m\u001b[34m(str, flags, state)\u001b[39m\n\u001b[32m    976\u001b[39m state.flags = flags\n\u001b[32m    977\u001b[39m state.str = \u001b[38;5;28mstr\u001b[39m\n\u001b[32m--> \u001b[39m\u001b[32m979\u001b[39m p = \u001b[43m_parse_sub\u001b[49m\u001b[43m(\u001b[49m\u001b[43msource\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mstate\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mflags\u001b[49m\u001b[43m \u001b[49m\u001b[43m&\u001b[49m\u001b[43m \u001b[49m\u001b[43mSRE_FLAG_VERBOSE\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[32;43m0\u001b[39;49m\u001b[43m)\u001b[49m\n\u001b[32m    980\u001b[39m p.state.flags = fix_flags(\u001b[38;5;28mstr\u001b[39m, p.state.flags)\n\u001b[32m    982\u001b[39m \u001b[38;5;28;01mif\u001b[39;00m source.next \u001b[38;5;129;01mis\u001b[39;00m \u001b[38;5;129;01mnot\u001b[39;00m \u001b[38;5;28;01mNone\u001b[39;00m:\n",
++      "\u001b[36mFile \u001b[39m\u001b[32m~\\AppData\\Roaming\\uv\\python\\cpython-3.12.11-windows-x86_64-none\\Lib\\re\\_parser.py:460\u001b[39m, in \u001b[36m_parse_sub\u001b[39m\u001b[34m(source, state, verbose, nested)\u001b[39m\n\u001b[32m    458\u001b[39m start = source.tell()\n\u001b[32m    459\u001b[39m \u001b[38;5;28;01mwhile\u001b[39;00m \u001b[38;5;28;01mTrue\u001b[39;00m:\n\u001b[32m--> \u001b[39m\u001b[32m460\u001b[39m     itemsappend(\u001b[43m_parse\u001b[49m\u001b[43m(\u001b[49m\u001b[43msource\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mstate\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mverbose\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mnested\u001b[49m\u001b[43m \u001b[49m\u001b[43m+\u001b[49m\u001b[43m \u001b[49m\u001b[32;43m1\u001b[39;49m\u001b[43m,\u001b[49m\n\u001b[32m    461\u001b[39m \u001b[43m                       \u001b[49m\u001b[38;5;129;43;01mnot\u001b[39;49;00m\u001b[43m \u001b[49m\u001b[43mnested\u001b[49m\u001b[43m \u001b[49m\u001b[38;5;129;43;01mand\u001b[39;49;00m\u001b[43m \u001b[49m\u001b[38;5;129;43;01mnot\u001b[39;49;00m\u001b[43m \u001b[49m\u001b[43mitems\u001b[49m\u001b[43m)\u001b[49m)\n\u001b[32m    462\u001b[39m     \u001b[38;5;28;01mif\u001b[39;00m \u001b[38;5;129;01mnot\u001b[39;00m sourcematch(\u001b[33m\"\u001b[39m\u001b[33m|\u001b[39m\u001b[33m\"\u001b[39m):\n\u001b[32m    463\u001b[39m         \u001b[38;5;28;01mbreak\u001b[39;00m\n",
++      "\u001b[36mFile \u001b[39m\u001b[32m~\\AppData\\Roaming\\uv\\python\\cpython-3.12.11-windows-x86_64-none\\Lib\\re\\_parser.py:687\u001b[39m, in \u001b[36m_parse\u001b[39m\u001b[34m(source, state, verbose, nested, first)\u001b[39m\n\u001b[32m    685\u001b[39m     item = \u001b[38;5;28;01mNone\u001b[39;00m\n\u001b[32m    686\u001b[39m \u001b[38;5;28;01mif\u001b[39;00m \u001b[38;5;129;01mnot\u001b[39;00m item \u001b[38;5;129;01mor\u001b[39;00m item[\u001b[32m0\u001b[39m][\u001b[32m0\u001b[39m] \u001b[38;5;129;01mis\u001b[39;00m AT:\n\u001b[32m--> \u001b[39m\u001b[32m687\u001b[39m     \u001b[38;5;28;01mraise\u001b[39;00m source.error(\u001b[33m\"\u001b[39m\u001b[33mnothing to repeat\u001b[39m\u001b[33m\"\u001b[39m,\n\u001b[32m    688\u001b[39m                        source.tell() - here + \u001b[38;5;28mlen\u001b[39m(this))\n\u001b[32m    689\u001b[39m \u001b[38;5;28;01mif\u001b[39;00m item[\u001b[32m0\u001b[39m][\u001b[32m0\u001b[39m] \u001b[38;5;129;01min\u001b[39;00m _REPEATCODES:\n\u001b[32m    690\u001b[39m     \u001b[38;5;28;01mraise\u001b[39;00m source.error(\u001b[33m\"\u001b[39m\u001b[33mmultiple repeat\u001b[39m\u001b[33m\"\u001b[39m,\n\u001b[32m    691\u001b[39m                        source.tell() - here + \u001b[38;5;28mlen\u001b[39m(this))\n",
++      "\u001b[31merror\u001b[39m: nothing to repeat at position 0"
++     ]
++    }
++   ],
++   "source": [
++    "from qlib.data.filter import NameDFilter\n",
++    "nameDFilter = NameDFilter(name_rule_re='*000858')\n",
++    "instruments = D.instruments(market='all',filter_pipe=[nameDFilter])\n",
++    "D.list_instruments(instruments=instruments, start_time='2015-01-01', end_time='2016-02-15', as_list=True)\n"
+    ]
+   }
+  ],
+diff --git a/test/ma_cross_strategy.py b/test/ma_cross_strategy.py
+deleted file mode 100644
+index 719d849..0000000
+--- a/test/ma_cross_strategy.py
++++ /dev/null
+@@ -1,274 +0,0 @@
+-"""
+-均线交叉策略：金叉买入，死叉卖出
+-使用qlib框架实现
+-"""
+-
+-import qlib
+-from qlib.constant import REG_CN
+-from qlib.utils import init_instance_by_config
+-from qlib.workflow import R
+-from qlib.workflow.record_temp import SignalRecord, PortAnaRecord
+-from qlib.contrib.evaluate import backtest_daily
+-from qlib.contrib.strategy import TopkDropoutStrategy
+-import pandas as pd
+-import numpy as np
+-from typing import Dict, List, Tuple
+-
+-
+-class MACrossStrategy(TopkDropoutStrategy):
+-    """
+-    均线交叉策略
+-    金叉（短期均线上穿长期均线）买入
+-    死叉（短期均线下穿长期均线）卖出
+-    """
+-    
+-    def __init__(self, 
+-                 short_window: int = 5,
+-                 long_window: int = 20,
+-                 topk: int = 50,
+-                 n_drop: int = 5,
+-                 **kwargs):
+-        """
+-        初始化策略参数
+-        
+-        Args:
+-            short_window: 短期均线周期
+-            long_window: 长期均线周期
+-            topk: 选择前k只股票
+-            n_drop: 剔除前n只股票
+-        """
+-        super().__init__(topk=topk, n_drop=n_drop, **kwargs)
+-        self.short_window = short_window
+-        self.long_window = long_window
+-        
+-    def generate_trade_decision(self, score: pd.Series, trade_step: int) -> pd.Series:
+-        """
+-        生成交易决策
+-        
+-        Args:
+-            score: 股票评分
+-            trade_step: 交易步骤
+-            
+-        Returns:
+-            交易决策，1表示买入，-1表示卖出，0表示持有
+-        """
+-        # 获取当前持仓
+-        current_pos = self.get_current_position()
+-        
+-        # 计算均线信号
+-        signal = self._calculate_ma_signal(score.index.tolist(), trade_step)
+-        
+-        # 生成交易决策
+-        decision = pd.Series(0, index=score.index)
+-        
+-        # 金叉买入信号
+-        buy_signal = signal == 1
+-        decision[buy_signal] = 1
+-        
+-        # 死叉卖出信号
+-        sell_signal = signal == -1
+-        decision[sell_signal] = -1
+-        
+-        return decision
+-    
+-    def _calculate_ma_signal(self, instruments: List[str], trade_step: int) -> pd.Series:
+-        """
+-        计算均线交叉信号
+-        
+-        Args:
+-            instruments: 股票代码列表
+-            trade_step: 交易步骤
+-            
+-        Returns:
+-            信号序列：1表示金叉买入，-1表示死叉卖出，0表示无信号
+-        """
+-        # 获取历史数据
+-        data = self._get_historical_data(instruments, trade_step)
+-        
+-        signals = pd.Series(0, index=instruments)
+-        
+-        for instrument in instruments:
+-            if instrument in data.index:
+-                # 计算短期和长期均线
+-                short_ma = data.loc[instrument].rolling(window=self.short_window).mean()
+-                long_ma = data.loc[instrument].rolling(window=self.long_window).mean()
+-                
+-                # 计算交叉信号
+-                if len(short_ma) >= 2 and len(long_ma) >= 2:
+-                    # 当前和前一个时间点的均线差值
+-                    current_diff = short_ma.iloc[-1] - long_ma.iloc[-1]
+-                    prev_diff = short_ma.iloc[-2] - long_ma.iloc[-2]
+-                    
+-                    # 金叉：短期均线从下方穿越长期均线
+-                    if prev_diff < 0 and current_diff > 0:
+-                        signals[instrument] = 1
+-                    # 死叉：短期均线从上方穿越长期均线
+-                    elif prev_diff > 0 and current_diff < 0:
+-                        signals[instrument] = -1
+-        
+-        return signals
+-    
+-    def _get_historical_data(self, instruments: List[str], trade_step: int) -> pd.DataFrame:
+-        """
+-        获取历史价格数据
+-        
+-        Args:
+-            instruments: 股票代码列表
+-            trade_step: 交易步骤
+-            
+-        Returns:
+-            历史价格数据
+-        """
+-        # 这里简化处理，实际应该从qlib数据源获取
+-        # 在实际应用中，您需要使用qlib的数据接口
+-        try:
+-            # 获取最近的数据用于计算均线
+-            # 这里使用模拟数据，实际应该从qlib获取
+-            dates = pd.date_range(end=pd.Timestamp.now(), periods=50, freq='D')
+-            data = pd.DataFrame(
+-                np.random.randn(len(dates), len(instruments)) * 0.02 + 1.0,
+-                index=dates,
+-                columns=instruments
+-            )
+-            return data
+-        except Exception as e:
+-            print(f"获取历史数据失败: {e}")
+-            return pd.DataFrame()
+-
+-
+-def create_ma_cross_strategy_config():
+-    """
+-    创建均线交叉策略配置
+-    """
+-    strategy_config = {
+-        "class": "MACrossStrategy",
+-        "module_path": "test.ma_cross_strategy",
+-        "kwargs": {
+-            "short_window": 5,
+-            "long_window": 20,
+-            "topk": 50,
+-            "n_drop": 5,
+-        }
+-    }
+-    
+-    return strategy_config
+-
+-
+-def run_backtest():
+-    """
+-    运行回测
+-    """
+-    # 初始化qlib
+-    qlib.init(provider_uri='~/.qlib/qlib_data/cn_data', region=REG_CN)
+-    
+-    # 策略配置
+-    strategy_config = create_ma_cross_strategy_config()
+-    
+-    # 回测配置
+-    backtest_config = {
+-        "start_time": "2020-01-01",
+-        "end_time": "2023-12-31",
+-        "benchmark": "SH000300",  # 沪深300作为基准
+-        "account": 100000000,     # 初始资金1亿
+-        "exchange_kwargs": {
+-            "freq": "day",
+-            "limit_threshold": 0.095,
+-            "deal_price": "close",
+-            "open_cost": 0.0005,
+-            "close_cost": 0.0015,
+-            "min_cost": 5,
+-        }
+-    }
+-    
+-    # 创建策略实例
+-    strategy = init_instance_by_config(strategy_config)
+-    
+-    # 运行回测
+-    with R.start(experiment_name="ma_cross_strategy"):
+-        # 记录信号
+-        sr = SignalRecord(model=strategy, dataset=None, recorder=R.get_recorder())
+-        sr.generate()
+-        
+-        # 记录投资组合分析
+-        par = PortAnaRecord(recorder=R.get_recorder(), config=backtest_config, strategy=strategy)
+-        par.generate()
+-        
+-        # 获取回测结果
+-        report_normal, positions_normal = backtest_daily(
+-            account=backtest_config["account"],
+-            benchmark=backtest_config["benchmark"],
+-            start_time=backtest_config["start_time"],
+-            end_time=backtest_config["end_time"],
+-            strategy=strategy,
+-            exchange_kwargs=backtest_config["exchange_kwargs"]
+-        )
+-        
+-        return report_normal, positions_normal
+-
+-
+-def analyze_results(report: pd.DataFrame, positions: pd.DataFrame):
+-    """
+-    分析回测结果
+-    
+-    Args:
+-        report: 回测报告
+-        positions: 持仓信息
+-    """
+-    print("=" * 50)
+-    print("均线交叉策略回测结果")
+-    print("=" * 50)
+-    
+-    # 基本统计信息
+-    print(f"总收益率: {report['return'].sum():.2%}")
+-    print(f"年化收益率: {report['return'].mean() * 252:.2%}")
+-    print(f"最大回撤: {report['drawdown'].min():.2%}")
+-    print(f"夏普比率: {report['sharpe'].iloc[-1]:.2f}")
+-    print(f"胜率: {(report['return'] > 0).mean():.2%}")
+-    
+-    # 风险指标
+-    volatility = report['return'].std() * np.sqrt(252)
+-    print(f"年化波动率: {volatility:.2%}")
+-    
+-    # 最大回撤期间
+-    max_drawdown_idx = report['drawdown'].idxmin()
+-    print(f"最大回撤发生时间: {max_drawdown_idx}")
+-    
+-    # 收益分布
+-    print("\n收益分布统计:")
+-    print(f"平均日收益: {report['return'].mean():.2%}")
+-    print(f"收益标准差: {report['return'].std():.2%}")
+-    print(f"最小日收益: {report['return'].min():.2%}")
+-    print(f"最大日收益: {report['return'].max():.2%}")
+-    
+-    # 交易统计
+-    if 'trade_count' in report.columns:
+-        print(f"\n总交易次数: {report['trade_count'].sum()}")
+-        print(f"平均每日交易次数: {report['trade_count'].mean():.1f}")
+-
+-
+-def main():
+-    """
+-    主函数
+-    """
+-    print("开始运行均线交叉策略回测...")
+-    
+-    try:
+-        # 运行回测
+-        report, positions = run_backtest()
+-        
+-        # 分析结果
+-        analyze_results(report, positions)
+-        
+-        # 保存结果
+-        report.to_csv("ma_cross_strategy_report.csv")
+-        positions.to_csv("ma_cross_strategy_positions.csv")
+-        
+-        print("\n回测完成！结果已保存到CSV文件。")
+-        
+-    except Exception as e:
+-        print(f"回测过程中出现错误: {e}")
+-        print("请确保已正确安装qlib并下载了相应的数据。")
+-
+-
+-if __name__ == "__main__":
+-    main() 
+\ No newline at end of file
+diff --git a/test/ma_cross_strategy_improved.py b/test/ma_cross_strategy_improved.py
+deleted file mode 100644
+index d166c68..0000000
+--- a/test/ma_cross_strategy_improved.py
++++ /dev/null
+@@ -1,443 +0,0 @@
+-"""
+-改进的均线交叉策略：金叉买入，死叉卖出
+-使用qlib框架实现，包含完整的数据获取和信号计算
+-"""
+-
+-import qlib
+-from qlib.constant import REG_CN
+-from qlib.utils import init_instance_by_config
+-from qlib.workflow import R
+-from qlib.workflow.record_temp import SignalRecord, PortAnaRecord
+-from qlib.contrib.evaluate import backtest_daily
+-from qlib.contrib.strategy import TopkDropoutStrategy
+-from qlib.data import D
+-from qlib.data.dataset import DatasetH
+-from qlib.data.dataset.handler import DataHandlerLP
+-import pandas as pd
+-import numpy as np
+-from typing import Dict, List, Tuple
+-import warnings
+-warnings.filterwarnings('ignore')
+-
+-
+-class MACrossStrategyImproved(TopkDropoutStrategy):
+-    """
+-    改进的均线交叉策略
+-    金叉（短期均线上穿长期均线）买入
+-    死叉（短期均线下穿长期均线）卖出
+-    """
+-    
+-    def __init__(self, 
+-                 short_window: int = 5,
+-                 long_window: int = 20,
+-                 topk: int = 50,
+-                 n_drop: int = 5,
+-                 universe: str = "csi300",
+-                 **kwargs):
+-        """
+-        初始化策略参数
+-        
+-        Args:
+-            short_window: 短期均线周期
+-            long_window: 长期均线周期
+-            topk: 选择前k只股票
+-            n_drop: 剔除前n只股票
+-            universe: 股票池
+-        """
+-        super().__init__(topk=topk, n_drop=n_drop, **kwargs)
+-        self.short_window = short_window
+-        self.long_window = long_window
+-        self.universe = universe
+-        self.instruments = None
+-        self.price_cache = {}
+-        
+-    def generate_trade_decision(self, score: pd.Series, trade_step: int) -> pd.Series:
+-        """
+-        生成交易决策
+-        
+-        Args:
+-            score: 股票评分
+-            trade_step: 交易步骤
+-            
+-        Returns:
+-            交易决策，1表示买入，-1表示卖出，0表示持有
+-        """
+-        # 获取当前持仓
+-        current_pos = self.get_current_position()
+-        
+-        # 计算均线信号
+-        signal = self._calculate_ma_signal(score.index.tolist(), trade_step)
+-        
+-        # 生成交易决策
+-        decision = pd.Series(0, index=score.index)
+-        
+-        # 金叉买入信号
+-        buy_signal = signal == 1
+-        decision[buy_signal] = 1
+-        
+-        # 死叉卖出信号
+-        sell_signal = signal == -1
+-        decision[sell_signal] = -1
+-        
+-        return decision
+-    
+-    def _calculate_ma_signal(self, instruments: List[str], trade_step: int) -> pd.Series:
+-        """
+-        计算均线交叉信号
+-        
+-        Args:
+-            instruments: 股票代码列表
+-            trade_step: 交易步骤
+-            
+-        Returns:
+-            信号序列：1表示金叉买入，-1表示死叉卖出，0表示无信号
+-        """
+-        signals = pd.Series(0, index=instruments)
+-        
+-        # 获取当前日期
+-        current_date = self._get_current_date(trade_step)
+-        
+-        for instrument in instruments:
+-            try:
+-                # 获取历史价格数据
+-                price_data = self._get_price_data(instrument, current_date)
+-                
+-                if price_data is not None and len(price_data) >= self.long_window:
+-                    # 计算短期和长期均线
+-                    short_ma = price_data['close'].rolling(window=self.short_window).mean()
+-                    long_ma = price_data['close'].rolling(window=self.long_window).mean()
+-                    
+-                    # 计算交叉信号
+-                    if len(short_ma) >= 2 and len(long_ma) >= 2:
+-                        # 当前和前一个时间点的均线差值
+-                        current_diff = short_ma.iloc[-1] - long_ma.iloc[-1]
+-                        prev_diff = short_ma.iloc[-2] - long_ma.iloc[-2]
+-                        
+-                        # 金叉：短期均线从下方穿越长期均线
+-                        if prev_diff < 0 and current_diff > 0:
+-                            signals[instrument] = 1
+-                        # 死叉：短期均线从上方穿越长期均线
+-                        elif prev_diff > 0 and current_diff < 0:
+-                            signals[instrument] = -1
+-                            
+-            except Exception as e:
+-                print(f"计算{instrument}均线信号时出错: {e}")
+-                continue
+-        
+-        return signals
+-    
+-    def _get_price_data(self, instrument: str, current_date: str) -> pd.DataFrame:
+-        """
+-        获取股票价格数据
+-        
+-        Args:
+-            instrument: 股票代码
+-            current_date: 当前日期
+-            
+-        Returns:
+-            价格数据DataFrame
+-        """
+-        try:
+-            # 计算开始日期（获取足够的历史数据来计算均线）
+-            start_date = pd.Timestamp(current_date) - pd.Timedelta(days=self.long_window * 2)
+-            
+-            # 从qlib获取数据
+-            data = D.features(
+-                instruments=[instrument],
+-                start_time=start_date.strftime('%Y-%m-%d'),
+-                end_time=current_date,
+-                freq='day',
+-                fields=['$close', '$open', '$high', '$low', '$volume']
+-            )
+-            
+-            if data is not None and not data.empty:
+-                # 重命名列
+-                data.columns = ['close', 'open', 'high', 'low', 'volume']
+-                return data
+-            else:
+-                return None
+-                
+-        except Exception as e:
+-            print(f"获取{instrument}价格数据失败: {e}")
+-            return None
+-    
+-    def _get_current_date(self, trade_step: int) -> str:
+-        """
+-        根据交易步骤获取当前日期
+-        
+-        Args:
+-            trade_step: 交易步骤
+-            
+-        Returns:
+-            当前日期字符串
+-        """
+-        # 这里简化处理，实际应该从qlib的日历获取
+-        # 假设从2020-01-01开始，每个trade_step代表一天
+-        start_date = pd.Timestamp('2020-01-01')
+-        current_date = start_date + pd.Timedelta(days=trade_step)
+-        return current_date.strftime('%Y-%m-%d')
+-
+-
+-def create_dataset_config():
+-    """
+-    创建数据集配置
+-    """
+-    dataset_config = {
+-        "class": "DatasetH",
+-        "module_path": "qlib.data.dataset",
+-        "kwargs": {
+-            "handler": {
+-                "class": "DataHandlerLP",
+-                "module_path": "qlib.data.dataset.handler",
+-                "kwargs": {
+-                    "start_time": "2020-01-01",
+-                    "end_time": "2023-12-31",
+-                    "fit_start_time": "2020-01-01",
+-                    "fit_end_time": "2023-12-31",
+-                    "instruments": "csi300",
+-                    "infer_processors": [
+-                        {
+-                            "class": "RobustZScoreNorm",
+-                            "module_path": "qlib.data.dataset.processor",
+-                            "kwargs": {
+-                                "fields_group": "feature",
+-                                "clip_outlier": True,
+-                            },
+-                        },
+-                        {
+-                            "class": "Fillna",
+-                            "module_path": "qlib.data.dataset.processor",
+-                            "kwargs": {
+-                                "fields_group": "feature",
+-                            },
+-                        },
+-                    ],
+-                    "learn_processors": [
+-                        {
+-                            "class": "DropnaLabel",
+-                            "module_path": "qlib.data.dataset.processor",
+-                        },
+-                        {
+-                            "class": "CSRankNorm",
+-                            "module_path": "qlib.data.dataset.processor",
+-                            "kwargs": {
+-                                "fields_group": "label",
+-                            },
+-                        },
+-                    ],
+-                    "instruments": "csi300",
+-                },
+-            },
+-            "segments": {
+-                "train": ("2020-01-01", "2022-12-31"),
+-                "valid": ("2023-01-01", "2023-06-30"),
+-                "test": ("2023-07-01", "2023-12-31"),
+-            },
+-        },
+-    }
+-    
+-    return dataset_config
+-
+-
+-def create_ma_cross_strategy_config():
+-    """
+-    创建均线交叉策略配置
+-    """
+-    strategy_config = {
+-        "class": "MACrossStrategyImproved",
+-        "module_path": "test.ma_cross_strategy_improved",
+-        "kwargs": {
+-            "short_window": 5,
+-            "long_window": 20,
+-            "topk": 50,
+-            "n_drop": 5,
+-            "universe": "csi300",
+-        }
+-    }
+-    
+-    return strategy_config
+-
+-
+-def run_backtest():
+-    """
+-    运行回测
+-    """
+-    # 初始化qlib
+-    qlib.init(provider_uri='~/.qlib/qlib_data/cn_data', region=REG_CN)
+-    
+-    # 策略配置
+-    strategy_config = create_ma_cross_strategy_config()
+-    
+-    # 回测配置
+-    backtest_config = {
+-        "start_time": "2020-01-01",
+-        "end_time": "2023-12-31",
+-        "benchmark": "SH000300",  # 沪深300作为基准
+-        "account": 100000000,     # 初始资金1亿
+-        "exchange_kwargs": {
+-            "freq": "day",
+-            "limit_threshold": 0.095,
+-            "deal_price": "close",
+-            "open_cost": 0.0005,
+-            "close_cost": 0.0015,
+-            "min_cost": 5,
+-        }
+-    }
+-    
+-    # 创建策略实例
+-    strategy = init_instance_by_config(strategy_config)
+-    
+-    # 运行回测
+-    with R.start(experiment_name="ma_cross_strategy_improved"):
+-        # 记录信号
+-        sr = SignalRecord(model=strategy, dataset=None, recorder=R.get_recorder())
+-        sr.generate()
+-        
+-        # 记录投资组合分析
+-        par = PortAnaRecord(recorder=R.get_recorder(), config=backtest_config, strategy=strategy)
+-        par.generate()
+-        
+-        # 获取回测结果
+-        report_normal, positions_normal = backtest_daily(
+-            account=backtest_config["account"],
+-            benchmark=backtest_config["benchmark"],
+-            start_time=backtest_config["start_time"],
+-            end_time=backtest_config["end_time"],
+-            strategy=strategy,
+-            exchange_kwargs=backtest_config["exchange_kwargs"]
+-        )
+-        
+-        return report_normal, positions_normal
+-
+-
+-def analyze_results(report: pd.DataFrame, positions: pd.DataFrame):
+-    """
+-    分析回测结果
+-    
+-    Args:
+-        report: 回测报告
+-        positions: 持仓信息
+-    """
+-    print("=" * 50)
+-    print("均线交叉策略回测结果")
+-    print("=" * 50)
+-    
+-    # 基本统计信息
+-    print(f"总收益率: {report['return'].sum():.2%}")
+-    print(f"年化收益率: {report['return'].mean() * 252:.2%}")
+-    print(f"最大回撤: {report['drawdown'].min():.2%}")
+-    
+-    if 'sharpe' in report.columns:
+-        print(f"夏普比率: {report['sharpe'].iloc[-1]:.2f}")
+-    
+-    print(f"胜率: {(report['return'] > 0).mean():.2%}")
+-    
+-    # 风险指标
+-    volatility = report['return'].std() * np.sqrt(252)
+-    print(f"年化波动率: {volatility:.2%}")
+-    
+-    # 最大回撤期间
+-    max_drawdown_idx = report['drawdown'].idxmin()
+-    print(f"最大回撤发生时间: {max_drawdown_idx}")
+-    
+-    # 收益分布
+-    print("\n收益分布统计:")
+-    print(f"平均日收益: {report['return'].mean():.2%}")
+-    print(f"收益标准差: {report['return'].std():.2%}")
+-    print(f"最小日收益: {report['return'].min():.2%}")
+-    print(f"最大日收益: {report['return'].max():.2%}")
+-    
+-    # 交易统计
+-    if 'trade_count' in report.columns:
+-        print(f"\n总交易次数: {report['trade_count'].sum()}")
+-        print(f"平均每日交易次数: {report['trade_count'].mean():.1f}")
+-
+-
+-def create_simple_backtest():
+-    """
+-    创建简化版回测，用于演示
+-    """
+-    print("创建简化版均线交叉策略回测...")
+-    
+-    # 初始化qlib
+-    qlib.init(provider_uri='~/.qlib/qlib_data/cn_data', region=REG_CN)
+-    
+-    # 获取股票列表
+-    instruments = D.list_instruments(instruments="csi300", start_time="2020-01-01", end_time="2023-12-31")
+-    
+-    print(f"获取到 {len(instruments)} 只股票")
+-    
+-    # 选择前10只股票进行演示
+-    demo_instruments = instruments[:10]
+-    
+-    # 获取价格数据
+-    data = D.features(
+-        instruments=demo_instruments,
+-        start_time="2020-01-01",
+-        end_time="2023-12-31",
+-        freq='day',
+-        fields=['$close']
+-    )
+-    
+-    print(f"获取到价格数据，形状: {data.shape}")
+-    
+-    # 计算均线
+-    short_ma = data.rolling(window=5).mean()
+-    long_ma = data.rolling(window=20).mean()
+-    
+-    # 计算交叉信号
+-    signals = pd.DataFrame(0, index=data.index, columns=data.columns)
+-    
+-    for col in data.columns:
+-        # 计算均线差值
+-        diff = short_ma[col] - long_ma[col]
+-        
+-        # 计算交叉信号
+-        for i in range(1, len(diff)):
+-            if diff.iloc[i-1] < 0 and diff.iloc[i] > 0:
+-                signals.iloc[i, signals.columns.get_loc(col)] = 1  # 金叉买入
+-            elif diff.iloc[i-1] > 0 and diff.iloc[i] < 0:
+-                signals.iloc[i, signals.columns.get_loc(col)] = -1  # 死叉卖出
+-    
+-    # 统计信号
+-    buy_signals = (signals == 1).sum().sum()
+-    sell_signals = (signals == -1).sum().sum()
+-    
+-    print(f"\n信号统计:")
+-    print(f"买入信号数量: {buy_signals}")
+-    print(f"卖出信号数量: {sell_signals}")
+-    
+-    # 计算简单收益（假设每次信号都产生1%的收益）
+-    returns = signals * 0.01
+-    cumulative_returns = returns.sum(axis=1).cumsum()
+-    
+-    print(f"\n累计收益: {cumulative_returns.iloc[-1]:.2%}")
+-    
+-    return signals, cumulative_returns
+-
+-
+-def main():
+-    """
+-    主函数
+-    """
+-    print("开始运行均线交叉策略回测...")
+-    
+-    try:
+-        # 运行简化版回测
+-        signals, cumulative_returns = create_simple_backtest()
+-        
+-        # 保存简化版结果
+-        signals.to_csv("ma_cross_signals.csv")
+-        cumulative_returns.to_csv("ma_cross_cumulative_returns.csv")
+-        
+-        print("\n简化版回测完成！")
+-        print("信号数据已保存到 ma_cross_signals.csv")
+-        print("累计收益已保存到 ma_cross_cumulative_returns.csv")
+-        
+-    except Exception as e:
+-        print(f"回测过程中出现错误: {e}")
+-        print("请确保已正确安装qlib并下载了相应的数据。")
+-
+-
+-if __name__ == "__main__":
+-    main() 
+\ No newline at end of file
+diff --git a/test/ma_strategy_demo.py b/test/ma_strategy_demo.py
+deleted file mode 100644
+index 1fa4fb4..0000000
+Binary files a/test/ma_strategy_demo.py and /dev/null differ
+diff --git a/test/simple_ma_strategy.py b/test/simple_ma_strategy.py
+deleted file mode 100644
+index 8d03f6b..0000000
+--- a/test/simple_ma_strategy.py
++++ /dev/null
+@@ -1,298 +0,0 @@
+-"""
+-简单实用的均线交叉策略
+-金叉买入，死叉卖出
+-"""
+-
+-import qlib
+-from qlib.constant import REG_CN
+-from qlib.data import D
+-import pandas as pd
+-import numpy as np
+-import matplotlib.pyplot as plt
+-from datetime import datetime, timedelta
+-
+-
+-def init_qlib():
+-    """初始化qlib"""
+-    try:
+-        qlib.init(provider_uri='~/.qlib/qlib_data/cn_data', region=REG_CN)
+-        print("qlib初始化成功")
+-        return True
+-    except Exception as e:
+-        print(f"qlib初始化失败: {e}")
+-        print("请确保已安装qlib并下载了数据")
+-        return False
+-
+-
+-def get_stock_data(instruments, start_date, end_date):
+-    """
+-    获取股票数据
+-    
+-    Args:
+-        instruments: 股票代码列表
+-        start_date: 开始日期
+-        end_date: 结束日期
+-    
+-    Returns:
+-        股票价格数据
+-    """
+-    try:
+-        data = D.features(
+-            instruments=instruments,
+-            start_time=start_date,
+-            end_time=end_date,
+-            freq='day',
+-            fields=['$close', '$open', '$high', '$low', '$volume']
+-        )
+-        
+-        if data is not None and not data.empty:
+-            # 重命名列
+-            data.columns = ['close', 'open', 'high', 'low', 'volume']
+-            return data
+-        else:
+-            print("未获取到数据")
+-            return None
+-            
+-    except Exception as e:
+-        print(f"获取数据失败: {e}")
+-        return None
+-
+-
+-def calculate_ma_signals(data, short_window=5, long_window=20):
+-    """
+-    计算均线交叉信号
+-    
+-    Args:
+-        data: 价格数据
+-        short_window: 短期均线周期
+-        long_window: 长期均线周期
+-    
+-    Returns:
+-        信号DataFrame，1表示买入，-1表示卖出，0表示无信号
+-    """
+-    signals = pd.DataFrame(0, index=data.index, columns=data.columns)
+-    
+-    for col in data.columns:
+-        if col == 'close':
+-            continue
+-            
+-        # 计算均线
+-        short_ma = data[col].rolling(window=short_window).mean()
+-        long_ma = data[col].rolling(window=long_window).mean()
+-        
+-        # 计算均线差值
+-        diff = short_ma - long_ma
+-        
+-        # 计算交叉信号
+-        for i in range(1, len(diff)):
+-            if pd.notna(diff.iloc[i-1]) and pd.notna(diff.iloc[i]):
+-                # 金叉：短期均线从下方穿越长期均线
+-                if diff.iloc[i-1] < 0 and diff.iloc[i] > 0:
+-                    signals.iloc[i, signals.columns.get_loc(col)] = 1
+-                # 死叉：短期均线从上方穿越长期均线
+-                elif diff.iloc[i-1] > 0 and diff.iloc[i] < 0:
+-                    signals.iloc[i, signals.columns.get_loc(col)] = -1
+-    
+-    return signals
+-
+-
+-def calculate_returns(data, signals, initial_capital=100000):
+-    """
+-    计算策略收益
+-    
+-    Args:
+-        data: 价格数据
+-        signals: 信号数据
+-        initial_capital: 初始资金
+-    
+-    Returns:
+-        收益数据
+-    """
+-    # 计算日收益率
+-    returns = data.pct_change()
+-    
+-    # 策略收益（假设每次信号产生1%的收益）
+-    strategy_returns = signals * 0.01
+-    
+-    # 累计收益
+-    cumulative_returns = strategy_returns.sum(axis=1).cumsum()
+-    
+-    # 资金曲线
+-    capital_curve = initial_capital * (1 + cumulative_returns)
+-    
+-    return {
+-        'strategy_returns': strategy_returns,
+-        'cumulative_returns': cumulative_returns,
+-        'capital_curve': capital_curve
+-    }
+-
+-
+-def analyze_strategy(signals, returns_data):
+-    """
+-    分析策略表现
+-    
+-    Args:
+-        signals: 信号数据
+-        returns_data: 收益数据
+-    """
+-    print("=" * 50)
+-    print("均线交叉策略分析结果")
+-    print("=" * 50)
+-    
+-    # 信号统计
+-    buy_signals = (signals == 1).sum().sum()
+-    sell_signals = (signals == -1).sum().sum()
+-    
+-    print(f"买入信号数量: {buy_signals}")
+-    print(f"卖出信号数量: {sell_signals}")
+-    print(f"总信号数量: {buy_signals + sell_signals}")
+-    
+-    # 收益统计
+-    cumulative_returns = returns_data['cumulative_returns']
+-    capital_curve = returns_data['capital_curve']
+-    
+-    total_return = cumulative_returns.iloc[-1]
+-    annual_return = total_return / (len(cumulative_returns) / 252)
+-    
+-    print(f"\n收益统计:")
+-    print(f"总收益率: {total_return:.2%}")
+-    print(f"年化收益率: {annual_return:.2%}")
+-    print(f"最终资金: {capital_curve.iloc[-1]:,.0f}")
+-    
+-    # 风险统计
+-    daily_returns = returns_data['strategy_returns'].sum(axis=1)
+-    volatility = daily_returns.std() * np.sqrt(252)
+-    sharpe_ratio = annual_return / volatility if volatility > 0 else 0
+-    
+-    print(f"\n风险统计:")
+-    print(f"年化波动率: {volatility:.2%}")
+-    print(f"夏普比率: {sharpe_ratio:.2f}")
+-    print(f"胜率: {(daily_returns > 0).mean():.2%}")
+-
+-
+-def plot_results(data, signals, returns_data, stock_code):
+-    """
+-    绘制结果图表
+-    
+-    Args:
+-        data: 价格数据
+-        signals: 信号数据
+-        returns_data: 收益数据
+-        stock_code: 股票代码
+-    """
+-    fig, axes = plt.subplots(3, 1, figsize=(12, 10))
+-    
+-    # 绘制价格和均线
+-    axes[0].plot(data.index, data[stock_code], label='收盘价', alpha=0.7)
+-    short_ma = data[stock_code].rolling(window=5).mean()
+-    long_ma = data[stock_code].rolling(window=20).mean()
+-    axes[0].plot(data.index, short_ma, label='5日均线', alpha=0.8)
+-    axes[0].plot(data.index, long_ma, label='20日均线', alpha=0.8)
+-    
+-    # 标记买卖信号
+-    buy_signals = signals[stock_code] == 1
+-    sell_signals = signals[stock_code] == -1
+-    
+-    axes[0].scatter(data.index[buy_signals], data.loc[buy_signals, stock_code], 
+-                   color='red', marker='^', s=100, label='买入信号', alpha=0.8)
+-    axes[0].scatter(data.index[sell_signals], data.loc[sell_signals, stock_code], 
+-                   color='green', marker='v', s=100, label='卖出信号', alpha=0.8)
+-    
+-    axes[0].set_title(f'{stock_code} 价格走势与均线交叉信号')
+-    axes[0].legend()
+-    axes[0].grid(True, alpha=0.3)
+-    
+-    # 绘制累计收益
+-    axes[1].plot(returns_data['cumulative_returns'].index, 
+-                returns_data['cumulative_returns'].values, 
+-                label='累计收益', color='blue')
+-    axes[1].set_title('策略累计收益')
+-    axes[1].legend()
+-    axes[1].grid(True, alpha=0.3)
+-    
+-    # 绘制资金曲线
+-    axes[2].plot(returns_data['capital_curve'].index, 
+-                returns_data['capital_curve'].values, 
+-                label='资金曲线', color='green')
+-    axes[2].set_title('资金曲线')
+-    axes[2].legend()
+-    axes[2].grid(True, alpha=0.3)
+-    
+-    plt.tight_layout()
+-    plt.savefig('ma_cross_strategy_results.png', dpi=300, bbox_inches='tight')
+-    plt.show()
+-
+-
+-def main():
+-    """
+-    主函数
+-    """
+-    print("开始运行均线交叉策略...")
+-    
+-    # 初始化qlib
+-    if not init_qlib():
+-        return
+-    
+-    # 策略参数
+-    start_date = "2020-01-01"
+-    end_date = "2023-12-31"
+-    short_window = 5
+-    long_window = 20
+-    initial_capital = 100000
+-    
+-    # 获取股票列表
+-    try:
+-        instruments = D.list_instruments(instruments="csi300", start_time=start_date, end_time=end_date)
+-        print(f"获取到 {len(instruments)} 只股票")
+-        
+-        # 选择前5只股票进行演示
+-        demo_instruments = instruments[:5]
+-        print(f"选择演示股票: {demo_instruments}")
+-        
+-    except Exception as e:
+-        print(f"获取股票列表失败: {e}")
+-        # 使用默认股票列表
+-        demo_instruments = ['000001.SZ', '000002.SZ', '000858.SZ', '002415.SZ', '600036.SH']
+-        print(f"使用默认股票列表: {demo_instruments}")
+-    
+-    # 获取价格数据
+-    data = get_stock_data(demo_instruments, start_date, end_date)
+-    
+-    if data is None:
+-        print("无法获取数据，程序退出")
+-        return
+-    
+-    print(f"获取到价格数据，形状: {data.shape}")
+-    
+-    # 计算均线信号
+-    signals = calculate_ma_signals(data, short_window, long_window)
+-    
+-    # 计算收益
+-    returns_data = calculate_returns(data, signals, initial_capital)
+-    
+-    # 分析策略
+-    analyze_strategy(signals, returns_data)
+-    
+-    # 保存结果
+-    signals.to_csv("ma_cross_signals.csv")
+-    returns_data['cumulative_returns'].to_csv("ma_cross_cumulative_returns.csv")
+-    returns_data['capital_curve'].to_csv("ma_cross_capital_curve.csv")
+-    
+-    print("\n结果已保存到CSV文件:")
+-    print("- ma_cross_signals.csv: 买卖信号")
+-    print("- ma_cross_cumulative_returns.csv: 累计收益")
+-    print("- ma_cross_capital_curve.csv: 资金曲线")
+-    
+-    # 绘制图表（选择第一只股票）
+-    if len(demo_instruments) > 0:
+-        try:
+-            plot_results(data, signals, returns_data, demo_instruments[0])
+-            print("图表已保存为 ma_cross_strategy_results.png")
+-        except Exception as e:
+-            print(f"绘制图表失败: {e}")
+-    
+-    print("\n策略回测完成！")
+-
+-
+-if __name__ == "__main__":
+-    main() 
+\ No newline at end of file
+diff --git a/test/two_ema_stragety.py b/test/two_ema_stragety.py
+index a72e7e8..a9890c7 100644
+--- a/test/two_ema_stragety.py
++++ b/test/two_ema_stragety.py
+@@ -1,2 +1,98 @@
+-from qlib.contrib.strategy import 
+-from qlib.backtest import backtest
+\ No newline at end of file
++import pandas as pd
++
++from abc import ABC
++from typing import Dict, List, Text, Tuple, Union
++from qlib.data.dataset import Dataset
++from qlib.model.base import BaseModel
++from qlib.backtest.signal import Signal, create_signal_from
++from qlib.strategy.base import BaseStrategy
++from qlib.backtest.decision import Order, OrderDir, OrderHelper, TradeDecisionWO
++# from qlib.strategy import 
++# from qlib.backtest import backtest
++
++class InnerStrategy(BaseStrategy):
++    """
++    Inner strategy for order execution:
++    - Buy: if price < 200, buy all cash; else buy 200,000 worth.
++    - Sell: if price > 200, sell all; else sell half.
++    """
++    STOCK_CODE = "000858.SZ"
++
++    def generate_trade_decision(self, execute_result: list = None, action: str = None, amount: float = None):
++        # action: 'buy' or 'sell', amount: suggested amount (shares) from outer
++        position = self.trade_position
++        trade_step = self.trade_calendar.get_trade_step()
++        trade_start_time, trade_end_time = self.trade_calendar.get_step_time(trade_step)
++        order_helper = self.trade_exchange.get_order_helper()
++        orders = []
++        price = self.trade_exchange.get_deal_price(self.STOCK_CODE, trade_start_time, trade_end_time)
++        if action == 'buy':
++            cash = position.get_cash()
++            if price <= 0:
++                return TradeDecisionWO([], self)
++            if price < 200:
++                buy_amount = cash // price
++            else:
++                buy_amount = min(cash // price, 200000 // price)
++            buy_amount = int(buy_amount)
++            if buy_amount > 0:
++                order = order_helper.create(
++                    code=self.STOCK_CODE,
++                    amount=buy_amount,
++                    direction=OrderDir.BUY,
++                    start_time=trade_start_time,
++                    end_time=trade_end_time,
++                )
++                orders.append(order)
++        elif action == 'sell':
++            held_amount = position.get_stock_amount(self.STOCK_CODE)
++            if held_amount <= 0 or price <= 0:
++                return TradeDecisionWO([], self)
++            if price > 200:
++                sell_amount = held_amount
++            else:
++                sell_amount = held_amount // 2
++            sell_amount = int(sell_amount)
++            if sell_amount > 0:
++                order = order_helper.create(
++                    code=self.STOCK_CODE,
++                    amount=sell_amount,
++                    direction=OrderDir.SELL,
++                    start_time=trade_start_time,
++                    end_time=trade_end_time,
++                )
++                orders.append(order)
++        return TradeDecisionWO(orders, self)
++
++class OuterStrategy(BaseStrategy):
++    """
++    Outer strategy:
++    - If not holding Wuliangye, issues a buy order via inner strategy.
++    - If holding, checks if held for 25 days, if so, issues a sell order via inner strategy.
++    - Otherwise, holds.
++    """
++    STOCK_CODE = "000858.SZ"
++    HOLD_DAYS = 25
++    BAR = "day"
++
++    def __init__(self, *args, **kwargs):
++        super().__init__(*args, **kwargs)
++        self.inner_strategy = InnerStrategy()
++
++    def generate_trade_decision(self, execute_result: list = None):
++        position = self.trade_position
++        stock_list = position.get_stock_list()
++        trade_step = self.trade_calendar.get_trade_step()
++        trade_start_time, trade_end_time = self.trade_calendar.get_step_time(trade_step)
++        # Pass infra to inner strategy
++        self.inner_strategy.reset(level_infra=self.level_infra, common_infra=self.common_infra)
++        if self.STOCK_CODE in stock_list:
++            hold_days = position.get_stock_count(self.STOCK_CODE, self.BAR)
++            if hold_days >= self.HOLD_DAYS:
++                # Sell via inner strategy
++                return self.inner_strategy.generate_trade_decision(action='sell')
++        else:
++            # Buy via inner strategy
++            return self.inner_strategy.generate_trade_decision(action='buy')
++        # Otherwise, hold
++        return TradeDecisionWO([], self)
+\ No newline at end of file
diff --git a/mlruns/812028854715931404/7d7942a2c1de450a97d231f84eb4a244/artifacts/code_status.txt b/mlruns/812028854715931404/7d7942a2c1de450a97d231f84eb4a244/artifacts/code_status.txt
new file mode 100644
index 0000000..d9b6458
--- /dev/null
+++ b/mlruns/812028854715931404/7d7942a2c1de450a97d231f84eb4a244/artifacts/code_status.txt
@@ -0,0 +1,25 @@
+On branch main
+Your branch is up to date with 'origin/main'.
+
+Changes not staged for commit:
+  (use "git add/rm <file>..." to update what will be committed)
+  (use "git restore <file>..." to discard changes in working directory)
+	modified:   github/examples/benchmarks/LightGBM/workflow_config_lightgbm_Alpha1582.yaml
+	deleted:    test/README_MA_Strategy.md
+	modified:   test/damo1.py
+	modified:   test/demo2.ipynb
+	deleted:    test/ma_cross_strategy.py
+	deleted:    test/ma_cross_strategy_improved.py
+	deleted:    test/ma_strategy_demo.py
+	deleted:    test/simple_ma_strategy.py
+	modified:   test/two_ema_stragety.py
+
+Untracked files:
+  (use "git add <file>..." to include in what will be committed)
+	github/examples/mlruns/881301994755452456/157579a2201241aaafcff94e93d7da0e/
+	mlruns/
+	test/__pycache__/
+	test/buy_and_hold.py
+	test/workflow_by_code.py
+
+no changes added to commit (use "git add" and/or "git commit -a")
diff --git a/mlruns/812028854715931404/7d7942a2c1de450a97d231f84eb4a244/meta.yaml b/mlruns/812028854715931404/7d7942a2c1de450a97d231f84eb4a244/meta.yaml
new file mode 100644
index 0000000..9246d89
--- /dev/null
+++ b/mlruns/812028854715931404/7d7942a2c1de450a97d231f84eb4a244/meta.yaml
@@ -0,0 +1,14 @@
+artifact_uri: file:D:\project\python\tradenote\mlruns/812028854715931404/7d7942a2c1de450a97d231f84eb4a244/artifacts
+end_time: 1750319890015
+entry_point_name: ''
+experiment_id: '812028854715931404'
+lifecycle_stage: active
+run_id: 7d7942a2c1de450a97d231f84eb4a244
+run_name: mlflow_recorder
+source_name: ''
+source_type: 4
+source_version: ''
+start_time: 1750319889791
+status: 3
+tags: []
+user_id: abulimity
diff --git a/mlruns/812028854715931404/7d7942a2c1de450a97d231f84eb4a244/params/cmd-sys.argv b/mlruns/812028854715931404/7d7942a2c1de450a97d231f84eb4a244/params/cmd-sys.argv
new file mode 100644
index 0000000..db800eb
--- /dev/null
+++ b/mlruns/812028854715931404/7d7942a2c1de450a97d231f84eb4a244/params/cmd-sys.argv
@@ -0,0 +1 @@
+D:\project\python\tradenote\test\workflow_by_code.py
\ No newline at end of file
diff --git a/mlruns/812028854715931404/7d7942a2c1de450a97d231f84eb4a244/tags/mlflow.runName b/mlruns/812028854715931404/7d7942a2c1de450a97d231f84eb4a244/tags/mlflow.runName
new file mode 100644
index 0000000..25487e4
--- /dev/null
+++ b/mlruns/812028854715931404/7d7942a2c1de450a97d231f84eb4a244/tags/mlflow.runName
@@ -0,0 +1 @@
+mlflow_recorder
\ No newline at end of file
diff --git a/mlruns/812028854715931404/7d7942a2c1de450a97d231f84eb4a244/tags/mlflow.source.git.commit b/mlruns/812028854715931404/7d7942a2c1de450a97d231f84eb4a244/tags/mlflow.source.git.commit
new file mode 100644
index 0000000..288ce21
--- /dev/null
+++ b/mlruns/812028854715931404/7d7942a2c1de450a97d231f84eb4a244/tags/mlflow.source.git.commit
@@ -0,0 +1 @@
+0daea9b5bbb40120a1bc07c702d171abc1f219c7
\ No newline at end of file
diff --git a/mlruns/812028854715931404/7d7942a2c1de450a97d231f84eb4a244/tags/mlflow.source.name b/mlruns/812028854715931404/7d7942a2c1de450a97d231f84eb4a244/tags/mlflow.source.name
new file mode 100644
index 0000000..db800eb
--- /dev/null
+++ b/mlruns/812028854715931404/7d7942a2c1de450a97d231f84eb4a244/tags/mlflow.source.name
@@ -0,0 +1 @@
+D:\project\python\tradenote\test\workflow_by_code.py
\ No newline at end of file
diff --git a/mlruns/812028854715931404/7d7942a2c1de450a97d231f84eb4a244/tags/mlflow.source.type b/mlruns/812028854715931404/7d7942a2c1de450a97d231f84eb4a244/tags/mlflow.source.type
new file mode 100644
index 0000000..0c2c1fe
--- /dev/null
+++ b/mlruns/812028854715931404/7d7942a2c1de450a97d231f84eb4a244/tags/mlflow.source.type
@@ -0,0 +1 @@
+LOCAL
\ No newline at end of file
diff --git a/mlruns/812028854715931404/7d7942a2c1de450a97d231f84eb4a244/tags/mlflow.user b/mlruns/812028854715931404/7d7942a2c1de450a97d231f84eb4a244/tags/mlflow.user
new file mode 100644
index 0000000..b9cec6f
--- /dev/null
+++ b/mlruns/812028854715931404/7d7942a2c1de450a97d231f84eb4a244/tags/mlflow.user
@@ -0,0 +1 @@
+abulimity
\ No newline at end of file
diff --git a/mlruns/812028854715931404/85d03e113573486f916ffbc9daee41fe/artifacts/code_cached.txt b/mlruns/812028854715931404/85d03e113573486f916ffbc9daee41fe/artifacts/code_cached.txt
new file mode 100644
index 0000000..e69de29
diff --git a/mlruns/812028854715931404/85d03e113573486f916ffbc9daee41fe/artifacts/code_diff.txt b/mlruns/812028854715931404/85d03e113573486f916ffbc9daee41fe/artifacts/code_diff.txt
new file mode 100644
index 0000000..05b5475
--- /dev/null
+++ b/mlruns/812028854715931404/85d03e113573486f916ffbc9daee41fe/artifacts/code_diff.txt
@@ -0,0 +1,1462 @@
+diff --git a/test/README_MA_Strategy.md b/test/README_MA_Strategy.md
+deleted file mode 100644
+index 5facaf7..0000000
+--- a/test/README_MA_Strategy.md
++++ /dev/null
+@@ -1,197 +0,0 @@
+-# 均线交叉策略 (Moving Average Crossover Strategy)
+-
+-## 策略概述
+-
+-这是一个基于qlib框架实现的均线交叉策略，核心逻辑是：
+-- **金叉买入**：短期均线上穿长期均线时买入
+-- **死叉卖出**：短期均线下穿长期均线时卖出
+-
+-## 文件说明
+-
+-### 1. `ma_cross_strategy.py`
+-完整的策略实现，包含：
+-- `MACrossStrategy` 类：继承自qlib的TopkDropoutStrategy
+-- 完整的回测框架
+-- 结果分析和保存
+-
+-### 2. `ma_cross_strategy_improved.py`
+-改进版本，包含：
+-- 更完善的数据获取逻辑
+-- 错误处理机制
+-- 简化版回测功能
+-
+-### 3. `simple_ma_strategy.py` ⭐ **推荐使用**
+-简单实用的版本，包含：
+-- 清晰的数据获取和处理
+-- 均线信号计算
+-- 收益计算和分析
+-- 可视化图表生成
+-- 结果保存功能
+-
+-## 使用方法
+-
+-### 环境准备
+-
+-1. 确保已安装qlib：
+-```bash
+-pip install pyqlib
+-```
+-
+-2. 下载qlib数据（如果还没有）：
+-```bash
+-# 下载中国股票数据
+-python -m qlib.data.dump_bin --csv_path ~/.qlib/qlib_data/cn_data --include_fields close,open,high,low,volume
+-```
+-
+-### 运行策略
+-
+-#### 方法1：运行简单版本（推荐）
+-```bash
+-cd test
+-python simple_ma_strategy.py
+-```
+-
+-#### 方法2：运行完整版本
+-```bash
+-cd test
+-python ma_cross_strategy.py
+-```
+-
+-#### 方法3：运行改进版本
+-```bash
+-cd test
+-python ma_cross_strategy_improved.py
+-```
+-
+-## 策略参数
+-
+-可以在代码中修改以下参数：
+-
+-```python
+-# 均线周期
+-short_window = 5    # 短期均线周期
+-long_window = 20    # 长期均线周期
+-
+-# 回测时间
+-start_date = "2020-01-01"
+-end_date = "2023-12-31"
+-
+-# 初始资金
+-initial_capital = 100000
+-
+-# 股票池
+-instruments = "csi300"  # 沪深300成分股
+-```
+-
+-## 输出结果
+-
+-运行策略后会生成以下文件：
+-
+-1. **CSV文件**：
+-   - `ma_cross_signals.csv`：买卖信号数据
+-   - `ma_cross_cumulative_returns.csv`：累计收益数据
+-   - `ma_cross_capital_curve.csv`：资金曲线数据
+-
+-2. **图表文件**：
+-   - `ma_cross_strategy_results.png`：策略结果可视化图表
+-
+-3. **控制台输出**：
+-   - 策略分析结果
+-   - 收益统计
+-   - 风险指标
+-
+-## 策略分析指标
+-
+-### 收益指标
+-- 总收益率
+-- 年化收益率
+-- 最终资金
+-
+-### 风险指标
+-- 年化波动率
+-- 夏普比率
+-- 胜率
+-- 最大回撤
+-
+-### 交易统计
+-- 买入信号数量
+-- 卖出信号数量
+-- 总交易次数
+-
+-## 策略逻辑详解
+-
+-### 1. 均线计算
+-```python
+-# 计算短期和长期均线
+-short_ma = price_data.rolling(window=short_window).mean()
+-long_ma = price_data.rolling(window=long_window).mean()
+-```
+-
+-### 2. 交叉信号判断
+-```python
+-# 计算均线差值
+-diff = short_ma - long_ma
+-
+-# 金叉：短期均线从下方穿越长期均线
+-if diff.iloc[i-1] < 0 and diff.iloc[i] > 0:
+-    signal = 1  # 买入信号
+-
+-# 死叉：短期均线从上方穿越长期均线
+-elif diff.iloc[i-1] > 0 and diff.iloc[i] < 0:
+-    signal = -1  # 卖出信号
+-```
+-
+-### 3. 收益计算
+-```python
+-# 策略收益（简化处理）
+-strategy_returns = signals * 0.01
+-
+-# 累计收益
+-cumulative_returns = strategy_returns.sum(axis=1).cumsum()
+-```
+-
+-## 注意事项
+-
+-1. **数据依赖**：确保qlib数据已正确下载和配置
+-2. **参数调优**：可以根据不同市场环境调整均线周期
+-3. **风险控制**：实际交易中需要加入止损和仓位管理
+-4. **交易成本**：当前版本未考虑交易费用，实际应用需要考虑
+-
+-## 扩展功能
+-
+-可以基于此策略进行以下扩展：
+-
+-1. **多均线策略**：使用多条均线进行更复杂的信号判断
+-2. **量价配合**：结合成交量指标优化信号
+-3. **止损机制**：添加动态止损策略
+-4. **仓位管理**：根据信号强度调整仓位大小
+-5. **多股票组合**：构建股票组合分散风险
+-
+-## 常见问题
+-
+-### Q: 如何修改股票池？
+-A: 在代码中修改 `instruments` 参数，例如：
+-```python
+-instruments = "csi500"  # 中证500
+-instruments = ["000001.SZ", "000002.SZ"]  # 指定股票列表
+-```
+-
+-### Q: 如何调整均线周期？
+-A: 修改 `short_window` 和 `long_window` 参数：
+-```python
+-short_window = 10  # 10日均线
+-long_window = 30   # 30日均线
+-```
+-
+-### Q: 如何查看详细的交易记录？
+-A: 查看生成的 `ma_cross_signals.csv` 文件，其中包含每日的买卖信号。
+-
+-## 联系方式
+-
+-如有问题或建议，请通过以下方式联系：
+-- 提交Issue到项目仓库
+-- 发送邮件到项目维护者
+-
+----
+-
+-**免责声明**：本策略仅供学习和研究使用，不构成投资建议。实际投资请谨慎决策，并承担相应风险。 
+\ No newline at end of file
+diff --git a/test/damo1.py b/test/damo1.py
+index 03102e1..7142dd1 100644
+--- a/test/damo1.py
++++ b/test/damo1.py
+@@ -1,5 +1,5 @@
+-# python scripts/get_data.py qlib_data --target_dir ../qlib_data/cn_data --region cn
+-
++# python github/scripts/get_data.py qlib_data --target_dir D:/sync/qlib/qlib_data/cn_data --region cn
++D:/sync/qlib/qlib_data/cn_data
+ import qlib
+ # region in [REG_CN, REG_US]
+ from qlib.constant import REG_CN
+diff --git a/test/demo2.ipynb b/test/demo2.ipynb
+index 66a0215..ad02df5 100644
+--- a/test/demo2.ipynb
++++ b/test/demo2.ipynb
+@@ -2,7 +2,7 @@
+  "cells": [
+   {
+    "cell_type": "code",
+-   "execution_count": 4,
++   "execution_count": 12,
+    "id": "6acb4a77",
+    "metadata": {},
+    "outputs": [
+@@ -10,39 +10,75 @@
+      "name": "stderr",
+      "output_type": "stream",
+      "text": [
+-      "[5344:MainThread](2025-06-18 14:41:03,895) INFO - qlib.Initialization - [config.py:420] - default_conf: client.\n",
+-      "[5344:MainThread](2025-06-18 14:41:03,900) INFO - qlib.Initialization - [__init__.py:74] - qlib successfully initialized based on client settings.\n",
+-      "[5344:MainThread](2025-06-18 14:41:03,903) INFO - qlib.Initialization - [__init__.py:76] - data_path={'__DEFAULT_FREQ': WindowsPath('D:/sync/qlib/qlib_data/cn_data')}\n"
++      "[13736:MainThread](2025-06-19 15:30:19,504) INFO - qlib.Initialization - [config.py:420] - default_conf: client.\n",
++      "[13736:MainThread](2025-06-19 15:30:19,506) INFO - qlib.Initialization - [__init__.py:74] - qlib successfully initialized based on client settings.\n",
++      "[13736:MainThread](2025-06-19 15:30:19,508) INFO - qlib.Initialization - [__init__.py:76] - data_path={'__DEFAULT_FREQ': WindowsPath('D:/sync/qlib/qlib_data/cn_data')}\n"
+      ]
+     }
+    ],
+    "source": [
+     "import qlib\n",
+-    "qlib.init(provider_uri=\"D:/sync/qlib/qlib_data/cn_data\", region=\"cn\")"
++    "qlib.init(provider_uri=r\"D:\\sync\\qlib\\qlib_data\\cn_data\", region=\"cn\")"
+    ]
+   },
+   {
+    "cell_type": "code",
+-   "execution_count": 12,
++   "execution_count": 14,
+    "id": "295df9af",
+    "metadata": {},
+    "outputs": [
+     {
+      "data": {
+       "text/plain": [
+-       "array([Timestamp('2020-09-21 00:00:00'), Timestamp('2020-09-22 00:00:00'),\n",
+-       "       Timestamp('2020-09-23 00:00:00'), Timestamp('2020-09-24 00:00:00'),\n",
+-       "       Timestamp('2020-09-25 00:00:00')], dtype=object)"
++       "array([Timestamp('2017-01-03 00:00:00'), Timestamp('2017-01-04 00:00:00'),\n",
++       "       Timestamp('2017-01-05 00:00:00'), Timestamp('2017-01-06 00:00:00'),\n",
++       "       Timestamp('2017-01-09 00:00:00')], dtype=object)"
+       ]
+      },
+-     "execution_count": 12,
++     "execution_count": 14,
+      "metadata": {},
+      "output_type": "execute_result"
+     }
+    ],
+    "source": [
+     "from qlib.data import D\n",
+-    "D.calendar(start_time='2020-09-21', end_time='2020-10-30', freq='day')"
++    "D.calendar(start_time=\"2017-01-01\", end_time=\"2020-08-01\",freq=\"day\")[:5]"
++   ]
++  },
++  {
++   "cell_type": "code",
++   "execution_count": 21,
++   "id": "da009afa",
++   "metadata": {},
++   "outputs": [
++    {
++     "ename": "error",
++     "evalue": "nothing to repeat at position 0",
++     "output_type": "error",
++     "traceback": [
++      "\u001b[31m---------------------------------------------------------------------------\u001b[39m",
++      "\u001b[31merror\u001b[39m                                     Traceback (most recent call last)",
++      "\u001b[36mCell\u001b[39m\u001b[36m \u001b[39m\u001b[32mIn[21]\u001b[39m\u001b[32m, line 4\u001b[39m\n\u001b[32m      2\u001b[39m nameDFilter = NameDFilter(name_rule_re=\u001b[33m'\u001b[39m\u001b[33m*000858\u001b[39m\u001b[33m'\u001b[39m)\n\u001b[32m      3\u001b[39m instruments = D.instruments(market=\u001b[33m'\u001b[39m\u001b[33mall\u001b[39m\u001b[33m'\u001b[39m,filter_pipe=[nameDFilter])\n\u001b[32m----> \u001b[39m\u001b[32m4\u001b[39m \u001b[43mD\u001b[49m\u001b[43m.\u001b[49m\u001b[43mlist_instruments\u001b[49m\u001b[43m(\u001b[49m\u001b[43minstruments\u001b[49m\u001b[43m=\u001b[49m\u001b[43minstruments\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mstart_time\u001b[49m\u001b[43m=\u001b[49m\u001b[33;43m'\u001b[39;49m\u001b[33;43m2015-01-01\u001b[39;49m\u001b[33;43m'\u001b[39;49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mend_time\u001b[49m\u001b[43m=\u001b[49m\u001b[33;43m'\u001b[39;49m\u001b[33;43m2016-02-15\u001b[39;49m\u001b[33;43m'\u001b[39;49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mas_list\u001b[49m\u001b[43m=\u001b[49m\u001b[38;5;28;43;01mTrue\u001b[39;49;00m\u001b[43m)\u001b[49m\n",
++      "\u001b[36mFile \u001b[39m\u001b[32md:\\project\\python\\tradenote\\.venv\\Lib\\site-packages\\qlib\\data\\data.py:1160\u001b[39m, in \u001b[36mBaseProvider.list_instruments\u001b[39m\u001b[34m(self, instruments, start_time, end_time, freq, as_list)\u001b[39m\n\u001b[32m   1159\u001b[39m \u001b[38;5;28;01mdef\u001b[39;00m\u001b[38;5;250m \u001b[39m\u001b[34mlist_instruments\u001b[39m(\u001b[38;5;28mself\u001b[39m, instruments, start_time=\u001b[38;5;28;01mNone\u001b[39;00m, end_time=\u001b[38;5;28;01mNone\u001b[39;00m, freq=\u001b[33m\"\u001b[39m\u001b[33mday\u001b[39m\u001b[33m\"\u001b[39m, as_list=\u001b[38;5;28;01mFalse\u001b[39;00m):\n\u001b[32m-> \u001b[39m\u001b[32m1160\u001b[39m     \u001b[38;5;28;01mreturn\u001b[39;00m \u001b[43mInst\u001b[49m\u001b[43m.\u001b[49m\u001b[43mlist_instruments\u001b[49m\u001b[43m(\u001b[49m\u001b[43minstruments\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mstart_time\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mend_time\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mfreq\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mas_list\u001b[49m\u001b[43m)\u001b[49m\n",
++      "\u001b[36mFile \u001b[39m\u001b[32md:\\project\\python\\tradenote\\.venv\\Lib\\site-packages\\qlib\\data\\data.py:719\u001b[39m, in \u001b[36mLocalInstrumentProvider.list_instruments\u001b[39m\u001b[34m(self, instruments, start_time, end_time, freq, as_list)\u001b[39m\n\u001b[32m    716\u001b[39m     \u001b[38;5;28;01mfrom\u001b[39;00m\u001b[38;5;250m \u001b[39m\u001b[34;01m.\u001b[39;00m\u001b[38;5;250m \u001b[39m\u001b[38;5;28;01mimport\u001b[39;00m \u001b[38;5;28mfilter\u001b[39m \u001b[38;5;28;01mas\u001b[39;00m F  \u001b[38;5;66;03m# pylint: disable=C0415\u001b[39;00m\n\u001b[32m    718\u001b[39m     filter_t = \u001b[38;5;28mgetattr\u001b[39m(F, filter_config[\u001b[33m\"\u001b[39m\u001b[33mfilter_type\u001b[39m\u001b[33m\"\u001b[39m]).from_config(filter_config)\n\u001b[32m--> \u001b[39m\u001b[32m719\u001b[39m     _instruments_filtered = \u001b[43mfilter_t\u001b[49m\u001b[43m(\u001b[49m\u001b[43m_instruments_filtered\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mstart_time\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mend_time\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mfreq\u001b[49m\u001b[43m)\u001b[49m\n\u001b[32m    720\u001b[39m \u001b[38;5;66;03m# as list\u001b[39;00m\n\u001b[32m    721\u001b[39m \u001b[38;5;28;01mif\u001b[39;00m as_list:\n",
++      "\u001b[36mFile \u001b[39m\u001b[32md:\\project\\python\\tradenote\\.venv\\Lib\\site-packages\\qlib\\data\\filter.py:192\u001b[39m, in \u001b[36mSeriesDFilter.__call__\u001b[39m\u001b[34m(self, instruments, start_time, end_time, freq)\u001b[39m\n\u001b[32m    190\u001b[39m \u001b[38;5;250m\u001b[39m\u001b[33;03m\"\"\"Call this filter to get filtered instruments list\"\"\"\u001b[39;00m\n\u001b[32m    191\u001b[39m \u001b[38;5;28mself\u001b[39m.filter_freq = freq\n\u001b[32m--> \u001b[39m\u001b[32m192\u001b[39m \u001b[38;5;28;01mreturn\u001b[39;00m \u001b[38;5;28;43mself\u001b[39;49m\u001b[43m.\u001b[49m\u001b[43mfilter_main\u001b[49m\u001b[43m(\u001b[49m\u001b[43minstruments\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mstart_time\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mend_time\u001b[49m\u001b[43m)\u001b[49m\n",
++      "\u001b[36mFile \u001b[39m\u001b[32md:\\project\\python\\tradenote\\.venv\\Lib\\site-packages\\qlib\\data\\filter.py:243\u001b[39m, in \u001b[36mSeriesDFilter.filter_main\u001b[39m\u001b[34m(self, instruments, start_time, end_time)\u001b[39m\n\u001b[32m    237\u001b[39m _all_calendar = Cal.calendar(start_time=start_time, end_time=end_time, freq=\u001b[38;5;28mself\u001b[39m.filter_freq)\n\u001b[32m    238\u001b[39m _filter_calendar = Cal.calendar(\n\u001b[32m    239\u001b[39m     start_time=\u001b[38;5;28mself\u001b[39m.filter_start_time \u001b[38;5;129;01mand\u001b[39;00m \u001b[38;5;28mmax\u001b[39m(\u001b[38;5;28mself\u001b[39m.filter_start_time, _all_calendar[\u001b[32m0\u001b[39m]) \u001b[38;5;129;01mor\u001b[39;00m _all_calendar[\u001b[32m0\u001b[39m],\n\u001b[32m    240\u001b[39m     end_time=\u001b[38;5;28mself\u001b[39m.filter_end_time \u001b[38;5;129;01mand\u001b[39;00m \u001b[38;5;28mmin\u001b[39m(\u001b[38;5;28mself\u001b[39m.filter_end_time, _all_calendar[-\u001b[32m1\u001b[39m]) \u001b[38;5;129;01mor\u001b[39;00m _all_calendar[-\u001b[32m1\u001b[39m],\n\u001b[32m    241\u001b[39m     freq=\u001b[38;5;28mself\u001b[39m.filter_freq,\n\u001b[32m    242\u001b[39m )\n\u001b[32m--> \u001b[39m\u001b[32m243\u001b[39m _all_filter_series = \u001b[38;5;28;43mself\u001b[39;49m\u001b[43m.\u001b[49m\u001b[43m_getFilterSeries\u001b[49m\u001b[43m(\u001b[49m\u001b[43minstruments\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43m_filter_calendar\u001b[49m\u001b[43m[\u001b[49m\u001b[32;43m0\u001b[39;49m\u001b[43m]\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43m_filter_calendar\u001b[49m\u001b[43m[\u001b[49m\u001b[43m-\u001b[49m\u001b[32;43m1\u001b[39;49m\u001b[43m]\u001b[49m\u001b[43m)\u001b[49m\n\u001b[32m    244\u001b[39m \u001b[38;5;28;01mfor\u001b[39;00m inst, timestamp \u001b[38;5;129;01min\u001b[39;00m instruments.items():\n\u001b[32m    245\u001b[39m     \u001b[38;5;66;03m# Construct a whole map of date\u001b[39;00m\n\u001b[32m    246\u001b[39m     _timestamp_series = \u001b[38;5;28mself\u001b[39m._toSeries(_all_calendar, timestamp)\n",
++      "\u001b[36mFile \u001b[39m\u001b[32md:\\project\\python\\tradenote\\.venv\\Lib\\site-packages\\qlib\\data\\filter.py:288\u001b[39m, in \u001b[36mNameDFilter._getFilterSeries\u001b[39m\u001b[34m(self, instruments, fstart, fend)\u001b[39m\n\u001b[32m    286\u001b[39m filter_calendar = Cal.calendar(start_time=fstart, end_time=fend, freq=\u001b[38;5;28mself\u001b[39m.filter_freq)\n\u001b[32m    287\u001b[39m \u001b[38;5;28;01mfor\u001b[39;00m inst, timestamp \u001b[38;5;129;01min\u001b[39;00m instruments.items():\n\u001b[32m--> \u001b[39m\u001b[32m288\u001b[39m     \u001b[38;5;28;01mif\u001b[39;00m \u001b[43mre\u001b[49m\u001b[43m.\u001b[49m\u001b[43mmatch\u001b[49m\u001b[43m(\u001b[49m\u001b[38;5;28;43mself\u001b[39;49m\u001b[43m.\u001b[49m\u001b[43mname_rule_re\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43minst\u001b[49m\u001b[43m)\u001b[49m:\n\u001b[32m    289\u001b[39m         _filter_series = pd.Series({timestamp: \u001b[38;5;28;01mTrue\u001b[39;00m \u001b[38;5;28;01mfor\u001b[39;00m timestamp \u001b[38;5;129;01min\u001b[39;00m filter_calendar})\n\u001b[32m    290\u001b[39m     \u001b[38;5;28;01melse\u001b[39;00m:\n",
++      "\u001b[36mFile \u001b[39m\u001b[32m~\\AppData\\Roaming\\uv\\python\\cpython-3.12.11-windows-x86_64-none\\Lib\\re\\__init__.py:167\u001b[39m, in \u001b[36mmatch\u001b[39m\u001b[34m(pattern, string, flags)\u001b[39m\n\u001b[32m    164\u001b[39m \u001b[38;5;28;01mdef\u001b[39;00m\u001b[38;5;250m \u001b[39m\u001b[34mmatch\u001b[39m(pattern, string, flags=\u001b[32m0\u001b[39m):\n\u001b[32m    165\u001b[39m \u001b[38;5;250m    \u001b[39m\u001b[33;03m\"\"\"Try to apply the pattern at the start of the string, returning\u001b[39;00m\n\u001b[32m    166\u001b[39m \u001b[33;03m    a Match object, or None if no match was found.\"\"\"\u001b[39;00m\n\u001b[32m--> \u001b[39m\u001b[32m167\u001b[39m     \u001b[38;5;28;01mreturn\u001b[39;00m \u001b[43m_compile\u001b[49m\u001b[43m(\u001b[49m\u001b[43mpattern\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mflags\u001b[49m\u001b[43m)\u001b[49m.match(string)\n",
++      "\u001b[36mFile \u001b[39m\u001b[32m~\\AppData\\Roaming\\uv\\python\\cpython-3.12.11-windows-x86_64-none\\Lib\\re\\__init__.py:307\u001b[39m, in \u001b[36m_compile\u001b[39m\u001b[34m(pattern, flags)\u001b[39m\n\u001b[32m    301\u001b[39m     \u001b[38;5;28;01mimport\u001b[39;00m\u001b[38;5;250m \u001b[39m\u001b[34;01mwarnings\u001b[39;00m\n\u001b[32m    302\u001b[39m     warnings.warn(\u001b[33m\"\u001b[39m\u001b[33mThe re.TEMPLATE/re.T flag is deprecated \u001b[39m\u001b[33m\"\u001b[39m\n\u001b[32m    303\u001b[39m             \u001b[33m\"\u001b[39m\u001b[33mas it is an undocumented flag \u001b[39m\u001b[33m\"\u001b[39m\n\u001b[32m    304\u001b[39m             \u001b[33m\"\u001b[39m\u001b[33mwithout an obvious purpose. \u001b[39m\u001b[33m\"\u001b[39m\n\u001b[32m    305\u001b[39m             \u001b[33m\"\u001b[39m\u001b[33mDon\u001b[39m\u001b[33m'\u001b[39m\u001b[33mt use it.\u001b[39m\u001b[33m\"\u001b[39m,\n\u001b[32m    306\u001b[39m             \u001b[38;5;167;01mDeprecationWarning\u001b[39;00m)\n\u001b[32m--> \u001b[39m\u001b[32m307\u001b[39m p = \u001b[43m_compiler\u001b[49m\u001b[43m.\u001b[49m\u001b[43mcompile\u001b[49m\u001b[43m(\u001b[49m\u001b[43mpattern\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mflags\u001b[49m\u001b[43m)\u001b[49m\n\u001b[32m    308\u001b[39m \u001b[38;5;28;01mif\u001b[39;00m flags & DEBUG:\n\u001b[32m    309\u001b[39m     \u001b[38;5;28;01mreturn\u001b[39;00m p\n",
++      "\u001b[36mFile \u001b[39m\u001b[32m~\\AppData\\Roaming\\uv\\python\\cpython-3.12.11-windows-x86_64-none\\Lib\\re\\_compiler.py:750\u001b[39m, in \u001b[36mcompile\u001b[39m\u001b[34m(p, flags)\u001b[39m\n\u001b[32m    748\u001b[39m \u001b[38;5;28;01mif\u001b[39;00m isstring(p):\n\u001b[32m    749\u001b[39m     pattern = p\n\u001b[32m--> \u001b[39m\u001b[32m750\u001b[39m     p = \u001b[43m_parser\u001b[49m\u001b[43m.\u001b[49m\u001b[43mparse\u001b[49m\u001b[43m(\u001b[49m\u001b[43mp\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mflags\u001b[49m\u001b[43m)\u001b[49m\n\u001b[32m    751\u001b[39m \u001b[38;5;28;01melse\u001b[39;00m:\n\u001b[32m    752\u001b[39m     pattern = \u001b[38;5;28;01mNone\u001b[39;00m\n",
++      "\u001b[36mFile \u001b[39m\u001b[32m~\\AppData\\Roaming\\uv\\python\\cpython-3.12.11-windows-x86_64-none\\Lib\\re\\_parser.py:979\u001b[39m, in \u001b[36mparse\u001b[39m\u001b[34m(str, flags, state)\u001b[39m\n\u001b[32m    976\u001b[39m state.flags = flags\n\u001b[32m    977\u001b[39m state.str = \u001b[38;5;28mstr\u001b[39m\n\u001b[32m--> \u001b[39m\u001b[32m979\u001b[39m p = \u001b[43m_parse_sub\u001b[49m\u001b[43m(\u001b[49m\u001b[43msource\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mstate\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mflags\u001b[49m\u001b[43m \u001b[49m\u001b[43m&\u001b[49m\u001b[43m \u001b[49m\u001b[43mSRE_FLAG_VERBOSE\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[32;43m0\u001b[39;49m\u001b[43m)\u001b[49m\n\u001b[32m    980\u001b[39m p.state.flags = fix_flags(\u001b[38;5;28mstr\u001b[39m, p.state.flags)\n\u001b[32m    982\u001b[39m \u001b[38;5;28;01mif\u001b[39;00m source.next \u001b[38;5;129;01mis\u001b[39;00m \u001b[38;5;129;01mnot\u001b[39;00m \u001b[38;5;28;01mNone\u001b[39;00m:\n",
++      "\u001b[36mFile \u001b[39m\u001b[32m~\\AppData\\Roaming\\uv\\python\\cpython-3.12.11-windows-x86_64-none\\Lib\\re\\_parser.py:460\u001b[39m, in \u001b[36m_parse_sub\u001b[39m\u001b[34m(source, state, verbose, nested)\u001b[39m\n\u001b[32m    458\u001b[39m start = source.tell()\n\u001b[32m    459\u001b[39m \u001b[38;5;28;01mwhile\u001b[39;00m \u001b[38;5;28;01mTrue\u001b[39;00m:\n\u001b[32m--> \u001b[39m\u001b[32m460\u001b[39m     itemsappend(\u001b[43m_parse\u001b[49m\u001b[43m(\u001b[49m\u001b[43msource\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mstate\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mverbose\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mnested\u001b[49m\u001b[43m \u001b[49m\u001b[43m+\u001b[49m\u001b[43m \u001b[49m\u001b[32;43m1\u001b[39;49m\u001b[43m,\u001b[49m\n\u001b[32m    461\u001b[39m \u001b[43m                       \u001b[49m\u001b[38;5;129;43;01mnot\u001b[39;49;00m\u001b[43m \u001b[49m\u001b[43mnested\u001b[49m\u001b[43m \u001b[49m\u001b[38;5;129;43;01mand\u001b[39;49;00m\u001b[43m \u001b[49m\u001b[38;5;129;43;01mnot\u001b[39;49;00m\u001b[43m \u001b[49m\u001b[43mitems\u001b[49m\u001b[43m)\u001b[49m)\n\u001b[32m    462\u001b[39m     \u001b[38;5;28;01mif\u001b[39;00m \u001b[38;5;129;01mnot\u001b[39;00m sourcematch(\u001b[33m\"\u001b[39m\u001b[33m|\u001b[39m\u001b[33m\"\u001b[39m):\n\u001b[32m    463\u001b[39m         \u001b[38;5;28;01mbreak\u001b[39;00m\n",
++      "\u001b[36mFile \u001b[39m\u001b[32m~\\AppData\\Roaming\\uv\\python\\cpython-3.12.11-windows-x86_64-none\\Lib\\re\\_parser.py:687\u001b[39m, in \u001b[36m_parse\u001b[39m\u001b[34m(source, state, verbose, nested, first)\u001b[39m\n\u001b[32m    685\u001b[39m     item = \u001b[38;5;28;01mNone\u001b[39;00m\n\u001b[32m    686\u001b[39m \u001b[38;5;28;01mif\u001b[39;00m \u001b[38;5;129;01mnot\u001b[39;00m item \u001b[38;5;129;01mor\u001b[39;00m item[\u001b[32m0\u001b[39m][\u001b[32m0\u001b[39m] \u001b[38;5;129;01mis\u001b[39;00m AT:\n\u001b[32m--> \u001b[39m\u001b[32m687\u001b[39m     \u001b[38;5;28;01mraise\u001b[39;00m source.error(\u001b[33m\"\u001b[39m\u001b[33mnothing to repeat\u001b[39m\u001b[33m\"\u001b[39m,\n\u001b[32m    688\u001b[39m                        source.tell() - here + \u001b[38;5;28mlen\u001b[39m(this))\n\u001b[32m    689\u001b[39m \u001b[38;5;28;01mif\u001b[39;00m item[\u001b[32m0\u001b[39m][\u001b[32m0\u001b[39m] \u001b[38;5;129;01min\u001b[39;00m _REPEATCODES:\n\u001b[32m    690\u001b[39m     \u001b[38;5;28;01mraise\u001b[39;00m source.error(\u001b[33m\"\u001b[39m\u001b[33mmultiple repeat\u001b[39m\u001b[33m\"\u001b[39m,\n\u001b[32m    691\u001b[39m                        source.tell() - here + \u001b[38;5;28mlen\u001b[39m(this))\n",
++      "\u001b[31merror\u001b[39m: nothing to repeat at position 0"
++     ]
++    }
++   ],
++   "source": [
++    "from qlib.data.filter import NameDFilter\n",
++    "nameDFilter = NameDFilter(name_rule_re='*000858')\n",
++    "instruments = D.instruments(market='all',filter_pipe=[nameDFilter])\n",
++    "D.list_instruments(instruments=instruments, start_time='2015-01-01', end_time='2016-02-15', as_list=True)\n"
+    ]
+   }
+  ],
+diff --git a/test/ma_cross_strategy.py b/test/ma_cross_strategy.py
+deleted file mode 100644
+index 719d849..0000000
+--- a/test/ma_cross_strategy.py
++++ /dev/null
+@@ -1,274 +0,0 @@
+-"""
+-均线交叉策略：金叉买入，死叉卖出
+-使用qlib框架实现
+-"""
+-
+-import qlib
+-from qlib.constant import REG_CN
+-from qlib.utils import init_instance_by_config
+-from qlib.workflow import R
+-from qlib.workflow.record_temp import SignalRecord, PortAnaRecord
+-from qlib.contrib.evaluate import backtest_daily
+-from qlib.contrib.strategy import TopkDropoutStrategy
+-import pandas as pd
+-import numpy as np
+-from typing import Dict, List, Tuple
+-
+-
+-class MACrossStrategy(TopkDropoutStrategy):
+-    """
+-    均线交叉策略
+-    金叉（短期均线上穿长期均线）买入
+-    死叉（短期均线下穿长期均线）卖出
+-    """
+-    
+-    def __init__(self, 
+-                 short_window: int = 5,
+-                 long_window: int = 20,
+-                 topk: int = 50,
+-                 n_drop: int = 5,
+-                 **kwargs):
+-        """
+-        初始化策略参数
+-        
+-        Args:
+-            short_window: 短期均线周期
+-            long_window: 长期均线周期
+-            topk: 选择前k只股票
+-            n_drop: 剔除前n只股票
+-        """
+-        super().__init__(topk=topk, n_drop=n_drop, **kwargs)
+-        self.short_window = short_window
+-        self.long_window = long_window
+-        
+-    def generate_trade_decision(self, score: pd.Series, trade_step: int) -> pd.Series:
+-        """
+-        生成交易决策
+-        
+-        Args:
+-            score: 股票评分
+-            trade_step: 交易步骤
+-            
+-        Returns:
+-            交易决策，1表示买入，-1表示卖出，0表示持有
+-        """
+-        # 获取当前持仓
+-        current_pos = self.get_current_position()
+-        
+-        # 计算均线信号
+-        signal = self._calculate_ma_signal(score.index.tolist(), trade_step)
+-        
+-        # 生成交易决策
+-        decision = pd.Series(0, index=score.index)
+-        
+-        # 金叉买入信号
+-        buy_signal = signal == 1
+-        decision[buy_signal] = 1
+-        
+-        # 死叉卖出信号
+-        sell_signal = signal == -1
+-        decision[sell_signal] = -1
+-        
+-        return decision
+-    
+-    def _calculate_ma_signal(self, instruments: List[str], trade_step: int) -> pd.Series:
+-        """
+-        计算均线交叉信号
+-        
+-        Args:
+-            instruments: 股票代码列表
+-            trade_step: 交易步骤
+-            
+-        Returns:
+-            信号序列：1表示金叉买入，-1表示死叉卖出，0表示无信号
+-        """
+-        # 获取历史数据
+-        data = self._get_historical_data(instruments, trade_step)
+-        
+-        signals = pd.Series(0, index=instruments)
+-        
+-        for instrument in instruments:
+-            if instrument in data.index:
+-                # 计算短期和长期均线
+-                short_ma = data.loc[instrument].rolling(window=self.short_window).mean()
+-                long_ma = data.loc[instrument].rolling(window=self.long_window).mean()
+-                
+-                # 计算交叉信号
+-                if len(short_ma) >= 2 and len(long_ma) >= 2:
+-                    # 当前和前一个时间点的均线差值
+-                    current_diff = short_ma.iloc[-1] - long_ma.iloc[-1]
+-                    prev_diff = short_ma.iloc[-2] - long_ma.iloc[-2]
+-                    
+-                    # 金叉：短期均线从下方穿越长期均线
+-                    if prev_diff < 0 and current_diff > 0:
+-                        signals[instrument] = 1
+-                    # 死叉：短期均线从上方穿越长期均线
+-                    elif prev_diff > 0 and current_diff < 0:
+-                        signals[instrument] = -1
+-        
+-        return signals
+-    
+-    def _get_historical_data(self, instruments: List[str], trade_step: int) -> pd.DataFrame:
+-        """
+-        获取历史价格数据
+-        
+-        Args:
+-            instruments: 股票代码列表
+-            trade_step: 交易步骤
+-            
+-        Returns:
+-            历史价格数据
+-        """
+-        # 这里简化处理，实际应该从qlib数据源获取
+-        # 在实际应用中，您需要使用qlib的数据接口
+-        try:
+-            # 获取最近的数据用于计算均线
+-            # 这里使用模拟数据，实际应该从qlib获取
+-            dates = pd.date_range(end=pd.Timestamp.now(), periods=50, freq='D')
+-            data = pd.DataFrame(
+-                np.random.randn(len(dates), len(instruments)) * 0.02 + 1.0,
+-                index=dates,
+-                columns=instruments
+-            )
+-            return data
+-        except Exception as e:
+-            print(f"获取历史数据失败: {e}")
+-            return pd.DataFrame()
+-
+-
+-def create_ma_cross_strategy_config():
+-    """
+-    创建均线交叉策略配置
+-    """
+-    strategy_config = {
+-        "class": "MACrossStrategy",
+-        "module_path": "test.ma_cross_strategy",
+-        "kwargs": {
+-            "short_window": 5,
+-            "long_window": 20,
+-            "topk": 50,
+-            "n_drop": 5,
+-        }
+-    }
+-    
+-    return strategy_config
+-
+-
+-def run_backtest():
+-    """
+-    运行回测
+-    """
+-    # 初始化qlib
+-    qlib.init(provider_uri='~/.qlib/qlib_data/cn_data', region=REG_CN)
+-    
+-    # 策略配置
+-    strategy_config = create_ma_cross_strategy_config()
+-    
+-    # 回测配置
+-    backtest_config = {
+-        "start_time": "2020-01-01",
+-        "end_time": "2023-12-31",
+-        "benchmark": "SH000300",  # 沪深300作为基准
+-        "account": 100000000,     # 初始资金1亿
+-        "exchange_kwargs": {
+-            "freq": "day",
+-            "limit_threshold": 0.095,
+-            "deal_price": "close",
+-            "open_cost": 0.0005,
+-            "close_cost": 0.0015,
+-            "min_cost": 5,
+-        }
+-    }
+-    
+-    # 创建策略实例
+-    strategy = init_instance_by_config(strategy_config)
+-    
+-    # 运行回测
+-    with R.start(experiment_name="ma_cross_strategy"):
+-        # 记录信号
+-        sr = SignalRecord(model=strategy, dataset=None, recorder=R.get_recorder())
+-        sr.generate()
+-        
+-        # 记录投资组合分析
+-        par = PortAnaRecord(recorder=R.get_recorder(), config=backtest_config, strategy=strategy)
+-        par.generate()
+-        
+-        # 获取回测结果
+-        report_normal, positions_normal = backtest_daily(
+-            account=backtest_config["account"],
+-            benchmark=backtest_config["benchmark"],
+-            start_time=backtest_config["start_time"],
+-            end_time=backtest_config["end_time"],
+-            strategy=strategy,
+-            exchange_kwargs=backtest_config["exchange_kwargs"]
+-        )
+-        
+-        return report_normal, positions_normal
+-
+-
+-def analyze_results(report: pd.DataFrame, positions: pd.DataFrame):
+-    """
+-    分析回测结果
+-    
+-    Args:
+-        report: 回测报告
+-        positions: 持仓信息
+-    """
+-    print("=" * 50)
+-    print("均线交叉策略回测结果")
+-    print("=" * 50)
+-    
+-    # 基本统计信息
+-    print(f"总收益率: {report['return'].sum():.2%}")
+-    print(f"年化收益率: {report['return'].mean() * 252:.2%}")
+-    print(f"最大回撤: {report['drawdown'].min():.2%}")
+-    print(f"夏普比率: {report['sharpe'].iloc[-1]:.2f}")
+-    print(f"胜率: {(report['return'] > 0).mean():.2%}")
+-    
+-    # 风险指标
+-    volatility = report['return'].std() * np.sqrt(252)
+-    print(f"年化波动率: {volatility:.2%}")
+-    
+-    # 最大回撤期间
+-    max_drawdown_idx = report['drawdown'].idxmin()
+-    print(f"最大回撤发生时间: {max_drawdown_idx}")
+-    
+-    # 收益分布
+-    print("\n收益分布统计:")
+-    print(f"平均日收益: {report['return'].mean():.2%}")
+-    print(f"收益标准差: {report['return'].std():.2%}")
+-    print(f"最小日收益: {report['return'].min():.2%}")
+-    print(f"最大日收益: {report['return'].max():.2%}")
+-    
+-    # 交易统计
+-    if 'trade_count' in report.columns:
+-        print(f"\n总交易次数: {report['trade_count'].sum()}")
+-        print(f"平均每日交易次数: {report['trade_count'].mean():.1f}")
+-
+-
+-def main():
+-    """
+-    主函数
+-    """
+-    print("开始运行均线交叉策略回测...")
+-    
+-    try:
+-        # 运行回测
+-        report, positions = run_backtest()
+-        
+-        # 分析结果
+-        analyze_results(report, positions)
+-        
+-        # 保存结果
+-        report.to_csv("ma_cross_strategy_report.csv")
+-        positions.to_csv("ma_cross_strategy_positions.csv")
+-        
+-        print("\n回测完成！结果已保存到CSV文件。")
+-        
+-    except Exception as e:
+-        print(f"回测过程中出现错误: {e}")
+-        print("请确保已正确安装qlib并下载了相应的数据。")
+-
+-
+-if __name__ == "__main__":
+-    main() 
+\ No newline at end of file
+diff --git a/test/ma_cross_strategy_improved.py b/test/ma_cross_strategy_improved.py
+deleted file mode 100644
+index d166c68..0000000
+--- a/test/ma_cross_strategy_improved.py
++++ /dev/null
+@@ -1,443 +0,0 @@
+-"""
+-改进的均线交叉策略：金叉买入，死叉卖出
+-使用qlib框架实现，包含完整的数据获取和信号计算
+-"""
+-
+-import qlib
+-from qlib.constant import REG_CN
+-from qlib.utils import init_instance_by_config
+-from qlib.workflow import R
+-from qlib.workflow.record_temp import SignalRecord, PortAnaRecord
+-from qlib.contrib.evaluate import backtest_daily
+-from qlib.contrib.strategy import TopkDropoutStrategy
+-from qlib.data import D
+-from qlib.data.dataset import DatasetH
+-from qlib.data.dataset.handler import DataHandlerLP
+-import pandas as pd
+-import numpy as np
+-from typing import Dict, List, Tuple
+-import warnings
+-warnings.filterwarnings('ignore')
+-
+-
+-class MACrossStrategyImproved(TopkDropoutStrategy):
+-    """
+-    改进的均线交叉策略
+-    金叉（短期均线上穿长期均线）买入
+-    死叉（短期均线下穿长期均线）卖出
+-    """
+-    
+-    def __init__(self, 
+-                 short_window: int = 5,
+-                 long_window: int = 20,
+-                 topk: int = 50,
+-                 n_drop: int = 5,
+-                 universe: str = "csi300",
+-                 **kwargs):
+-        """
+-        初始化策略参数
+-        
+-        Args:
+-            short_window: 短期均线周期
+-            long_window: 长期均线周期
+-            topk: 选择前k只股票
+-            n_drop: 剔除前n只股票
+-            universe: 股票池
+-        """
+-        super().__init__(topk=topk, n_drop=n_drop, **kwargs)
+-        self.short_window = short_window
+-        self.long_window = long_window
+-        self.universe = universe
+-        self.instruments = None
+-        self.price_cache = {}
+-        
+-    def generate_trade_decision(self, score: pd.Series, trade_step: int) -> pd.Series:
+-        """
+-        生成交易决策
+-        
+-        Args:
+-            score: 股票评分
+-            trade_step: 交易步骤
+-            
+-        Returns:
+-            交易决策，1表示买入，-1表示卖出，0表示持有
+-        """
+-        # 获取当前持仓
+-        current_pos = self.get_current_position()
+-        
+-        # 计算均线信号
+-        signal = self._calculate_ma_signal(score.index.tolist(), trade_step)
+-        
+-        # 生成交易决策
+-        decision = pd.Series(0, index=score.index)
+-        
+-        # 金叉买入信号
+-        buy_signal = signal == 1
+-        decision[buy_signal] = 1
+-        
+-        # 死叉卖出信号
+-        sell_signal = signal == -1
+-        decision[sell_signal] = -1
+-        
+-        return decision
+-    
+-    def _calculate_ma_signal(self, instruments: List[str], trade_step: int) -> pd.Series:
+-        """
+-        计算均线交叉信号
+-        
+-        Args:
+-            instruments: 股票代码列表
+-            trade_step: 交易步骤
+-            
+-        Returns:
+-            信号序列：1表示金叉买入，-1表示死叉卖出，0表示无信号
+-        """
+-        signals = pd.Series(0, index=instruments)
+-        
+-        # 获取当前日期
+-        current_date = self._get_current_date(trade_step)
+-        
+-        for instrument in instruments:
+-            try:
+-                # 获取历史价格数据
+-                price_data = self._get_price_data(instrument, current_date)
+-                
+-                if price_data is not None and len(price_data) >= self.long_window:
+-                    # 计算短期和长期均线
+-                    short_ma = price_data['close'].rolling(window=self.short_window).mean()
+-                    long_ma = price_data['close'].rolling(window=self.long_window).mean()
+-                    
+-                    # 计算交叉信号
+-                    if len(short_ma) >= 2 and len(long_ma) >= 2:
+-                        # 当前和前一个时间点的均线差值
+-                        current_diff = short_ma.iloc[-1] - long_ma.iloc[-1]
+-                        prev_diff = short_ma.iloc[-2] - long_ma.iloc[-2]
+-                        
+-                        # 金叉：短期均线从下方穿越长期均线
+-                        if prev_diff < 0 and current_diff > 0:
+-                            signals[instrument] = 1
+-                        # 死叉：短期均线从上方穿越长期均线
+-                        elif prev_diff > 0 and current_diff < 0:
+-                            signals[instrument] = -1
+-                            
+-            except Exception as e:
+-                print(f"计算{instrument}均线信号时出错: {e}")
+-                continue
+-        
+-        return signals
+-    
+-    def _get_price_data(self, instrument: str, current_date: str) -> pd.DataFrame:
+-        """
+-        获取股票价格数据
+-        
+-        Args:
+-            instrument: 股票代码
+-            current_date: 当前日期
+-            
+-        Returns:
+-            价格数据DataFrame
+-        """
+-        try:
+-            # 计算开始日期（获取足够的历史数据来计算均线）
+-            start_date = pd.Timestamp(current_date) - pd.Timedelta(days=self.long_window * 2)
+-            
+-            # 从qlib获取数据
+-            data = D.features(
+-                instruments=[instrument],
+-                start_time=start_date.strftime('%Y-%m-%d'),
+-                end_time=current_date,
+-                freq='day',
+-                fields=['$close', '$open', '$high', '$low', '$volume']
+-            )
+-            
+-            if data is not None and not data.empty:
+-                # 重命名列
+-                data.columns = ['close', 'open', 'high', 'low', 'volume']
+-                return data
+-            else:
+-                return None
+-                
+-        except Exception as e:
+-            print(f"获取{instrument}价格数据失败: {e}")
+-            return None
+-    
+-    def _get_current_date(self, trade_step: int) -> str:
+-        """
+-        根据交易步骤获取当前日期
+-        
+-        Args:
+-            trade_step: 交易步骤
+-            
+-        Returns:
+-            当前日期字符串
+-        """
+-        # 这里简化处理，实际应该从qlib的日历获取
+-        # 假设从2020-01-01开始，每个trade_step代表一天
+-        start_date = pd.Timestamp('2020-01-01')
+-        current_date = start_date + pd.Timedelta(days=trade_step)
+-        return current_date.strftime('%Y-%m-%d')
+-
+-
+-def create_dataset_config():
+-    """
+-    创建数据集配置
+-    """
+-    dataset_config = {
+-        "class": "DatasetH",
+-        "module_path": "qlib.data.dataset",
+-        "kwargs": {
+-            "handler": {
+-                "class": "DataHandlerLP",
+-                "module_path": "qlib.data.dataset.handler",
+-                "kwargs": {
+-                    "start_time": "2020-01-01",
+-                    "end_time": "2023-12-31",
+-                    "fit_start_time": "2020-01-01",
+-                    "fit_end_time": "2023-12-31",
+-                    "instruments": "csi300",
+-                    "infer_processors": [
+-                        {
+-                            "class": "RobustZScoreNorm",
+-                            "module_path": "qlib.data.dataset.processor",
+-                            "kwargs": {
+-                                "fields_group": "feature",
+-                                "clip_outlier": True,
+-                            },
+-                        },
+-                        {
+-                            "class": "Fillna",
+-                            "module_path": "qlib.data.dataset.processor",
+-                            "kwargs": {
+-                                "fields_group": "feature",
+-                            },
+-                        },
+-                    ],
+-                    "learn_processors": [
+-                        {
+-                            "class": "DropnaLabel",
+-                            "module_path": "qlib.data.dataset.processor",
+-                        },
+-                        {
+-                            "class": "CSRankNorm",
+-                            "module_path": "qlib.data.dataset.processor",
+-                            "kwargs": {
+-                                "fields_group": "label",
+-                            },
+-                        },
+-                    ],
+-                    "instruments": "csi300",
+-                },
+-            },
+-            "segments": {
+-                "train": ("2020-01-01", "2022-12-31"),
+-                "valid": ("2023-01-01", "2023-06-30"),
+-                "test": ("2023-07-01", "2023-12-31"),
+-            },
+-        },
+-    }
+-    
+-    return dataset_config
+-
+-
+-def create_ma_cross_strategy_config():
+-    """
+-    创建均线交叉策略配置
+-    """
+-    strategy_config = {
+-        "class": "MACrossStrategyImproved",
+-        "module_path": "test.ma_cross_strategy_improved",
+-        "kwargs": {
+-            "short_window": 5,
+-            "long_window": 20,
+-            "topk": 50,
+-            "n_drop": 5,
+-            "universe": "csi300",
+-        }
+-    }
+-    
+-    return strategy_config
+-
+-
+-def run_backtest():
+-    """
+-    运行回测
+-    """
+-    # 初始化qlib
+-    qlib.init(provider_uri='~/.qlib/qlib_data/cn_data', region=REG_CN)
+-    
+-    # 策略配置
+-    strategy_config = create_ma_cross_strategy_config()
+-    
+-    # 回测配置
+-    backtest_config = {
+-        "start_time": "2020-01-01",
+-        "end_time": "2023-12-31",
+-        "benchmark": "SH000300",  # 沪深300作为基准
+-        "account": 100000000,     # 初始资金1亿
+-        "exchange_kwargs": {
+-            "freq": "day",
+-            "limit_threshold": 0.095,
+-            "deal_price": "close",
+-            "open_cost": 0.0005,
+-            "close_cost": 0.0015,
+-            "min_cost": 5,
+-        }
+-    }
+-    
+-    # 创建策略实例
+-    strategy = init_instance_by_config(strategy_config)
+-    
+-    # 运行回测
+-    with R.start(experiment_name="ma_cross_strategy_improved"):
+-        # 记录信号
+-        sr = SignalRecord(model=strategy, dataset=None, recorder=R.get_recorder())
+-        sr.generate()
+-        
+-        # 记录投资组合分析
+-        par = PortAnaRecord(recorder=R.get_recorder(), config=backtest_config, strategy=strategy)
+-        par.generate()
+-        
+-        # 获取回测结果
+-        report_normal, positions_normal = backtest_daily(
+-            account=backtest_config["account"],
+-            benchmark=backtest_config["benchmark"],
+-            start_time=backtest_config["start_time"],
+-            end_time=backtest_config["end_time"],
+-            strategy=strategy,
+-            exchange_kwargs=backtest_config["exchange_kwargs"]
+-        )
+-        
+-        return report_normal, positions_normal
+-
+-
+-def analyze_results(report: pd.DataFrame, positions: pd.DataFrame):
+-    """
+-    分析回测结果
+-    
+-    Args:
+-        report: 回测报告
+-        positions: 持仓信息
+-    """
+-    print("=" * 50)
+-    print("均线交叉策略回测结果")
+-    print("=" * 50)
+-    
+-    # 基本统计信息
+-    print(f"总收益率: {report['return'].sum():.2%}")
+-    print(f"年化收益率: {report['return'].mean() * 252:.2%}")
+-    print(f"最大回撤: {report['drawdown'].min():.2%}")
+-    
+-    if 'sharpe' in report.columns:
+-        print(f"夏普比率: {report['sharpe'].iloc[-1]:.2f}")
+-    
+-    print(f"胜率: {(report['return'] > 0).mean():.2%}")
+-    
+-    # 风险指标
+-    volatility = report['return'].std() * np.sqrt(252)
+-    print(f"年化波动率: {volatility:.2%}")
+-    
+-    # 最大回撤期间
+-    max_drawdown_idx = report['drawdown'].idxmin()
+-    print(f"最大回撤发生时间: {max_drawdown_idx}")
+-    
+-    # 收益分布
+-    print("\n收益分布统计:")
+-    print(f"平均日收益: {report['return'].mean():.2%}")
+-    print(f"收益标准差: {report['return'].std():.2%}")
+-    print(f"最小日收益: {report['return'].min():.2%}")
+-    print(f"最大日收益: {report['return'].max():.2%}")
+-    
+-    # 交易统计
+-    if 'trade_count' in report.columns:
+-        print(f"\n总交易次数: {report['trade_count'].sum()}")
+-        print(f"平均每日交易次数: {report['trade_count'].mean():.1f}")
+-
+-
+-def create_simple_backtest():
+-    """
+-    创建简化版回测，用于演示
+-    """
+-    print("创建简化版均线交叉策略回测...")
+-    
+-    # 初始化qlib
+-    qlib.init(provider_uri='~/.qlib/qlib_data/cn_data', region=REG_CN)
+-    
+-    # 获取股票列表
+-    instruments = D.list_instruments(instruments="csi300", start_time="2020-01-01", end_time="2023-12-31")
+-    
+-    print(f"获取到 {len(instruments)} 只股票")
+-    
+-    # 选择前10只股票进行演示
+-    demo_instruments = instruments[:10]
+-    
+-    # 获取价格数据
+-    data = D.features(
+-        instruments=demo_instruments,
+-        start_time="2020-01-01",
+-        end_time="2023-12-31",
+-        freq='day',
+-        fields=['$close']
+-    )
+-    
+-    print(f"获取到价格数据，形状: {data.shape}")
+-    
+-    # 计算均线
+-    short_ma = data.rolling(window=5).mean()
+-    long_ma = data.rolling(window=20).mean()
+-    
+-    # 计算交叉信号
+-    signals = pd.DataFrame(0, index=data.index, columns=data.columns)
+-    
+-    for col in data.columns:
+-        # 计算均线差值
+-        diff = short_ma[col] - long_ma[col]
+-        
+-        # 计算交叉信号
+-        for i in range(1, len(diff)):
+-            if diff.iloc[i-1] < 0 and diff.iloc[i] > 0:
+-                signals.iloc[i, signals.columns.get_loc(col)] = 1  # 金叉买入
+-            elif diff.iloc[i-1] > 0 and diff.iloc[i] < 0:
+-                signals.iloc[i, signals.columns.get_loc(col)] = -1  # 死叉卖出
+-    
+-    # 统计信号
+-    buy_signals = (signals == 1).sum().sum()
+-    sell_signals = (signals == -1).sum().sum()
+-    
+-    print(f"\n信号统计:")
+-    print(f"买入信号数量: {buy_signals}")
+-    print(f"卖出信号数量: {sell_signals}")
+-    
+-    # 计算简单收益（假设每次信号都产生1%的收益）
+-    returns = signals * 0.01
+-    cumulative_returns = returns.sum(axis=1).cumsum()
+-    
+-    print(f"\n累计收益: {cumulative_returns.iloc[-1]:.2%}")
+-    
+-    return signals, cumulative_returns
+-
+-
+-def main():
+-    """
+-    主函数
+-    """
+-    print("开始运行均线交叉策略回测...")
+-    
+-    try:
+-        # 运行简化版回测
+-        signals, cumulative_returns = create_simple_backtest()
+-        
+-        # 保存简化版结果
+-        signals.to_csv("ma_cross_signals.csv")
+-        cumulative_returns.to_csv("ma_cross_cumulative_returns.csv")
+-        
+-        print("\n简化版回测完成！")
+-        print("信号数据已保存到 ma_cross_signals.csv")
+-        print("累计收益已保存到 ma_cross_cumulative_returns.csv")
+-        
+-    except Exception as e:
+-        print(f"回测过程中出现错误: {e}")
+-        print("请确保已正确安装qlib并下载了相应的数据。")
+-
+-
+-if __name__ == "__main__":
+-    main() 
+\ No newline at end of file
+diff --git a/test/ma_strategy_demo.py b/test/ma_strategy_demo.py
+deleted file mode 100644
+index 1fa4fb4..0000000
+Binary files a/test/ma_strategy_demo.py and /dev/null differ
+diff --git a/test/simple_ma_strategy.py b/test/simple_ma_strategy.py
+deleted file mode 100644
+index 8d03f6b..0000000
+--- a/test/simple_ma_strategy.py
++++ /dev/null
+@@ -1,298 +0,0 @@
+-"""
+-简单实用的均线交叉策略
+-金叉买入，死叉卖出
+-"""
+-
+-import qlib
+-from qlib.constant import REG_CN
+-from qlib.data import D
+-import pandas as pd
+-import numpy as np
+-import matplotlib.pyplot as plt
+-from datetime import datetime, timedelta
+-
+-
+-def init_qlib():
+-    """初始化qlib"""
+-    try:
+-        qlib.init(provider_uri='~/.qlib/qlib_data/cn_data', region=REG_CN)
+-        print("qlib初始化成功")
+-        return True
+-    except Exception as e:
+-        print(f"qlib初始化失败: {e}")
+-        print("请确保已安装qlib并下载了数据")
+-        return False
+-
+-
+-def get_stock_data(instruments, start_date, end_date):
+-    """
+-    获取股票数据
+-    
+-    Args:
+-        instruments: 股票代码列表
+-        start_date: 开始日期
+-        end_date: 结束日期
+-    
+-    Returns:
+-        股票价格数据
+-    """
+-    try:
+-        data = D.features(
+-            instruments=instruments,
+-            start_time=start_date,
+-            end_time=end_date,
+-            freq='day',
+-            fields=['$close', '$open', '$high', '$low', '$volume']
+-        )
+-        
+-        if data is not None and not data.empty:
+-            # 重命名列
+-            data.columns = ['close', 'open', 'high', 'low', 'volume']
+-            return data
+-        else:
+-            print("未获取到数据")
+-            return None
+-            
+-    except Exception as e:
+-        print(f"获取数据失败: {e}")
+-        return None
+-
+-
+-def calculate_ma_signals(data, short_window=5, long_window=20):
+-    """
+-    计算均线交叉信号
+-    
+-    Args:
+-        data: 价格数据
+-        short_window: 短期均线周期
+-        long_window: 长期均线周期
+-    
+-    Returns:
+-        信号DataFrame，1表示买入，-1表示卖出，0表示无信号
+-    """
+-    signals = pd.DataFrame(0, index=data.index, columns=data.columns)
+-    
+-    for col in data.columns:
+-        if col == 'close':
+-            continue
+-            
+-        # 计算均线
+-        short_ma = data[col].rolling(window=short_window).mean()
+-        long_ma = data[col].rolling(window=long_window).mean()
+-        
+-        # 计算均线差值
+-        diff = short_ma - long_ma
+-        
+-        # 计算交叉信号
+-        for i in range(1, len(diff)):
+-            if pd.notna(diff.iloc[i-1]) and pd.notna(diff.iloc[i]):
+-                # 金叉：短期均线从下方穿越长期均线
+-                if diff.iloc[i-1] < 0 and diff.iloc[i] > 0:
+-                    signals.iloc[i, signals.columns.get_loc(col)] = 1
+-                # 死叉：短期均线从上方穿越长期均线
+-                elif diff.iloc[i-1] > 0 and diff.iloc[i] < 0:
+-                    signals.iloc[i, signals.columns.get_loc(col)] = -1
+-    
+-    return signals
+-
+-
+-def calculate_returns(data, signals, initial_capital=100000):
+-    """
+-    计算策略收益
+-    
+-    Args:
+-        data: 价格数据
+-        signals: 信号数据
+-        initial_capital: 初始资金
+-    
+-    Returns:
+-        收益数据
+-    """
+-    # 计算日收益率
+-    returns = data.pct_change()
+-    
+-    # 策略收益（假设每次信号产生1%的收益）
+-    strategy_returns = signals * 0.01
+-    
+-    # 累计收益
+-    cumulative_returns = strategy_returns.sum(axis=1).cumsum()
+-    
+-    # 资金曲线
+-    capital_curve = initial_capital * (1 + cumulative_returns)
+-    
+-    return {
+-        'strategy_returns': strategy_returns,
+-        'cumulative_returns': cumulative_returns,
+-        'capital_curve': capital_curve
+-    }
+-
+-
+-def analyze_strategy(signals, returns_data):
+-    """
+-    分析策略表现
+-    
+-    Args:
+-        signals: 信号数据
+-        returns_data: 收益数据
+-    """
+-    print("=" * 50)
+-    print("均线交叉策略分析结果")
+-    print("=" * 50)
+-    
+-    # 信号统计
+-    buy_signals = (signals == 1).sum().sum()
+-    sell_signals = (signals == -1).sum().sum()
+-    
+-    print(f"买入信号数量: {buy_signals}")
+-    print(f"卖出信号数量: {sell_signals}")
+-    print(f"总信号数量: {buy_signals + sell_signals}")
+-    
+-    # 收益统计
+-    cumulative_returns = returns_data['cumulative_returns']
+-    capital_curve = returns_data['capital_curve']
+-    
+-    total_return = cumulative_returns.iloc[-1]
+-    annual_return = total_return / (len(cumulative_returns) / 252)
+-    
+-    print(f"\n收益统计:")
+-    print(f"总收益率: {total_return:.2%}")
+-    print(f"年化收益率: {annual_return:.2%}")
+-    print(f"最终资金: {capital_curve.iloc[-1]:,.0f}")
+-    
+-    # 风险统计
+-    daily_returns = returns_data['strategy_returns'].sum(axis=1)
+-    volatility = daily_returns.std() * np.sqrt(252)
+-    sharpe_ratio = annual_return / volatility if volatility > 0 else 0
+-    
+-    print(f"\n风险统计:")
+-    print(f"年化波动率: {volatility:.2%}")
+-    print(f"夏普比率: {sharpe_ratio:.2f}")
+-    print(f"胜率: {(daily_returns > 0).mean():.2%}")
+-
+-
+-def plot_results(data, signals, returns_data, stock_code):
+-    """
+-    绘制结果图表
+-    
+-    Args:
+-        data: 价格数据
+-        signals: 信号数据
+-        returns_data: 收益数据
+-        stock_code: 股票代码
+-    """
+-    fig, axes = plt.subplots(3, 1, figsize=(12, 10))
+-    
+-    # 绘制价格和均线
+-    axes[0].plot(data.index, data[stock_code], label='收盘价', alpha=0.7)
+-    short_ma = data[stock_code].rolling(window=5).mean()
+-    long_ma = data[stock_code].rolling(window=20).mean()
+-    axes[0].plot(data.index, short_ma, label='5日均线', alpha=0.8)
+-    axes[0].plot(data.index, long_ma, label='20日均线', alpha=0.8)
+-    
+-    # 标记买卖信号
+-    buy_signals = signals[stock_code] == 1
+-    sell_signals = signals[stock_code] == -1
+-    
+-    axes[0].scatter(data.index[buy_signals], data.loc[buy_signals, stock_code], 
+-                   color='red', marker='^', s=100, label='买入信号', alpha=0.8)
+-    axes[0].scatter(data.index[sell_signals], data.loc[sell_signals, stock_code], 
+-                   color='green', marker='v', s=100, label='卖出信号', alpha=0.8)
+-    
+-    axes[0].set_title(f'{stock_code} 价格走势与均线交叉信号')
+-    axes[0].legend()
+-    axes[0].grid(True, alpha=0.3)
+-    
+-    # 绘制累计收益
+-    axes[1].plot(returns_data['cumulative_returns'].index, 
+-                returns_data['cumulative_returns'].values, 
+-                label='累计收益', color='blue')
+-    axes[1].set_title('策略累计收益')
+-    axes[1].legend()
+-    axes[1].grid(True, alpha=0.3)
+-    
+-    # 绘制资金曲线
+-    axes[2].plot(returns_data['capital_curve'].index, 
+-                returns_data['capital_curve'].values, 
+-                label='资金曲线', color='green')
+-    axes[2].set_title('资金曲线')
+-    axes[2].legend()
+-    axes[2].grid(True, alpha=0.3)
+-    
+-    plt.tight_layout()
+-    plt.savefig('ma_cross_strategy_results.png', dpi=300, bbox_inches='tight')
+-    plt.show()
+-
+-
+-def main():
+-    """
+-    主函数
+-    """
+-    print("开始运行均线交叉策略...")
+-    
+-    # 初始化qlib
+-    if not init_qlib():
+-        return
+-    
+-    # 策略参数
+-    start_date = "2020-01-01"
+-    end_date = "2023-12-31"
+-    short_window = 5
+-    long_window = 20
+-    initial_capital = 100000
+-    
+-    # 获取股票列表
+-    try:
+-        instruments = D.list_instruments(instruments="csi300", start_time=start_date, end_time=end_date)
+-        print(f"获取到 {len(instruments)} 只股票")
+-        
+-        # 选择前5只股票进行演示
+-        demo_instruments = instruments[:5]
+-        print(f"选择演示股票: {demo_instruments}")
+-        
+-    except Exception as e:
+-        print(f"获取股票列表失败: {e}")
+-        # 使用默认股票列表
+-        demo_instruments = ['000001.SZ', '000002.SZ', '000858.SZ', '002415.SZ', '600036.SH']
+-        print(f"使用默认股票列表: {demo_instruments}")
+-    
+-    # 获取价格数据
+-    data = get_stock_data(demo_instruments, start_date, end_date)
+-    
+-    if data is None:
+-        print("无法获取数据，程序退出")
+-        return
+-    
+-    print(f"获取到价格数据，形状: {data.shape}")
+-    
+-    # 计算均线信号
+-    signals = calculate_ma_signals(data, short_window, long_window)
+-    
+-    # 计算收益
+-    returns_data = calculate_returns(data, signals, initial_capital)
+-    
+-    # 分析策略
+-    analyze_strategy(signals, returns_data)
+-    
+-    # 保存结果
+-    signals.to_csv("ma_cross_signals.csv")
+-    returns_data['cumulative_returns'].to_csv("ma_cross_cumulative_returns.csv")
+-    returns_data['capital_curve'].to_csv("ma_cross_capital_curve.csv")
+-    
+-    print("\n结果已保存到CSV文件:")
+-    print("- ma_cross_signals.csv: 买卖信号")
+-    print("- ma_cross_cumulative_returns.csv: 累计收益")
+-    print("- ma_cross_capital_curve.csv: 资金曲线")
+-    
+-    # 绘制图表（选择第一只股票）
+-    if len(demo_instruments) > 0:
+-        try:
+-            plot_results(data, signals, returns_data, demo_instruments[0])
+-            print("图表已保存为 ma_cross_strategy_results.png")
+-        except Exception as e:
+-            print(f"绘制图表失败: {e}")
+-    
+-    print("\n策略回测完成！")
+-
+-
+-if __name__ == "__main__":
+-    main() 
+\ No newline at end of file
+diff --git a/test/two_ema_stragety.py b/test/two_ema_stragety.py
+index a72e7e8..a9890c7 100644
+--- a/test/two_ema_stragety.py
++++ b/test/two_ema_stragety.py
+@@ -1,2 +1,98 @@
+-from qlib.contrib.strategy import 
+-from qlib.backtest import backtest
+\ No newline at end of file
++import pandas as pd
++
++from abc import ABC
++from typing import Dict, List, Text, Tuple, Union
++from qlib.data.dataset import Dataset
++from qlib.model.base import BaseModel
++from qlib.backtest.signal import Signal, create_signal_from
++from qlib.strategy.base import BaseStrategy
++from qlib.backtest.decision import Order, OrderDir, OrderHelper, TradeDecisionWO
++# from qlib.strategy import 
++# from qlib.backtest import backtest
++
++class InnerStrategy(BaseStrategy):
++    """
++    Inner strategy for order execution:
++    - Buy: if price < 200, buy all cash; else buy 200,000 worth.
++    - Sell: if price > 200, sell all; else sell half.
++    """
++    STOCK_CODE = "000858.SZ"
++
++    def generate_trade_decision(self, execute_result: list = None, action: str = None, amount: float = None):
++        # action: 'buy' or 'sell', amount: suggested amount (shares) from outer
++        position = self.trade_position
++        trade_step = self.trade_calendar.get_trade_step()
++        trade_start_time, trade_end_time = self.trade_calendar.get_step_time(trade_step)
++        order_helper = self.trade_exchange.get_order_helper()
++        orders = []
++        price = self.trade_exchange.get_deal_price(self.STOCK_CODE, trade_start_time, trade_end_time)
++        if action == 'buy':
++            cash = position.get_cash()
++            if price <= 0:
++                return TradeDecisionWO([], self)
++            if price < 200:
++                buy_amount = cash // price
++            else:
++                buy_amount = min(cash // price, 200000 // price)
++            buy_amount = int(buy_amount)
++            if buy_amount > 0:
++                order = order_helper.create(
++                    code=self.STOCK_CODE,
++                    amount=buy_amount,
++                    direction=OrderDir.BUY,
++                    start_time=trade_start_time,
++                    end_time=trade_end_time,
++                )
++                orders.append(order)
++        elif action == 'sell':
++            held_amount = position.get_stock_amount(self.STOCK_CODE)
++            if held_amount <= 0 or price <= 0:
++                return TradeDecisionWO([], self)
++            if price > 200:
++                sell_amount = held_amount
++            else:
++                sell_amount = held_amount // 2
++            sell_amount = int(sell_amount)
++            if sell_amount > 0:
++                order = order_helper.create(
++                    code=self.STOCK_CODE,
++                    amount=sell_amount,
++                    direction=OrderDir.SELL,
++                    start_time=trade_start_time,
++                    end_time=trade_end_time,
++                )
++                orders.append(order)
++        return TradeDecisionWO(orders, self)
++
++class OuterStrategy(BaseStrategy):
++    """
++    Outer strategy:
++    - If not holding Wuliangye, issues a buy order via inner strategy.
++    - If holding, checks if held for 25 days, if so, issues a sell order via inner strategy.
++    - Otherwise, holds.
++    """
++    STOCK_CODE = "000858.SZ"
++    HOLD_DAYS = 25
++    BAR = "day"
++
++    def __init__(self, *args, **kwargs):
++        super().__init__(*args, **kwargs)
++        self.inner_strategy = InnerStrategy()
++
++    def generate_trade_decision(self, execute_result: list = None):
++        position = self.trade_position
++        stock_list = position.get_stock_list()
++        trade_step = self.trade_calendar.get_trade_step()
++        trade_start_time, trade_end_time = self.trade_calendar.get_step_time(trade_step)
++        # Pass infra to inner strategy
++        self.inner_strategy.reset(level_infra=self.level_infra, common_infra=self.common_infra)
++        if self.STOCK_CODE in stock_list:
++            hold_days = position.get_stock_count(self.STOCK_CODE, self.BAR)
++            if hold_days >= self.HOLD_DAYS:
++                # Sell via inner strategy
++                return self.inner_strategy.generate_trade_decision(action='sell')
++        else:
++            # Buy via inner strategy
++            return self.inner_strategy.generate_trade_decision(action='buy')
++        # Otherwise, hold
++        return TradeDecisionWO([], self)
+\ No newline at end of file
diff --git a/mlruns/812028854715931404/85d03e113573486f916ffbc9daee41fe/artifacts/code_status.txt b/mlruns/812028854715931404/85d03e113573486f916ffbc9daee41fe/artifacts/code_status.txt
new file mode 100644
index 0000000..091c5f6
--- /dev/null
+++ b/mlruns/812028854715931404/85d03e113573486f916ffbc9daee41fe/artifacts/code_status.txt
@@ -0,0 +1,23 @@
+On branch main
+Your branch is up to date with 'origin/main'.
+
+Changes not staged for commit:
+  (use "git add/rm <file>..." to update what will be committed)
+  (use "git restore <file>..." to discard changes in working directory)
+	deleted:    test/README_MA_Strategy.md
+	modified:   test/damo1.py
+	modified:   test/demo2.ipynb
+	deleted:    test/ma_cross_strategy.py
+	deleted:    test/ma_cross_strategy_improved.py
+	deleted:    test/ma_strategy_demo.py
+	deleted:    test/simple_ma_strategy.py
+	modified:   test/two_ema_stragety.py
+
+Untracked files:
+  (use "git add <file>..." to include in what will be committed)
+	mlruns/
+	test/__pycache__/
+	test/buy_and_hold.py
+	test/workflow_by_code.py
+
+no changes added to commit (use "git add" and/or "git commit -a")
diff --git a/mlruns/812028854715931404/85d03e113573486f916ffbc9daee41fe/meta.yaml b/mlruns/812028854715931404/85d03e113573486f916ffbc9daee41fe/meta.yaml
new file mode 100644
index 0000000..dae8029
--- /dev/null
+++ b/mlruns/812028854715931404/85d03e113573486f916ffbc9daee41fe/meta.yaml
@@ -0,0 +1,14 @@
+artifact_uri: file:D:\project\python\tradenote\mlruns/812028854715931404/85d03e113573486f916ffbc9daee41fe/artifacts
+end_time: 1750318812152
+entry_point_name: ''
+experiment_id: '812028854715931404'
+lifecycle_stage: active
+run_id: 85d03e113573486f916ffbc9daee41fe
+run_name: mlflow_recorder
+source_name: ''
+source_type: 4
+source_version: ''
+start_time: 1750318811942
+status: 3
+tags: []
+user_id: abulimity
diff --git a/mlruns/812028854715931404/85d03e113573486f916ffbc9daee41fe/params/cmd-sys.argv b/mlruns/812028854715931404/85d03e113573486f916ffbc9daee41fe/params/cmd-sys.argv
new file mode 100644
index 0000000..db800eb
--- /dev/null
+++ b/mlruns/812028854715931404/85d03e113573486f916ffbc9daee41fe/params/cmd-sys.argv
@@ -0,0 +1 @@
+D:\project\python\tradenote\test\workflow_by_code.py
\ No newline at end of file
diff --git a/mlruns/812028854715931404/85d03e113573486f916ffbc9daee41fe/tags/mlflow.runName b/mlruns/812028854715931404/85d03e113573486f916ffbc9daee41fe/tags/mlflow.runName
new file mode 100644
index 0000000..25487e4
--- /dev/null
+++ b/mlruns/812028854715931404/85d03e113573486f916ffbc9daee41fe/tags/mlflow.runName
@@ -0,0 +1 @@
+mlflow_recorder
\ No newline at end of file
diff --git a/mlruns/812028854715931404/85d03e113573486f916ffbc9daee41fe/tags/mlflow.source.git.commit b/mlruns/812028854715931404/85d03e113573486f916ffbc9daee41fe/tags/mlflow.source.git.commit
new file mode 100644
index 0000000..288ce21
--- /dev/null
+++ b/mlruns/812028854715931404/85d03e113573486f916ffbc9daee41fe/tags/mlflow.source.git.commit
@@ -0,0 +1 @@
+0daea9b5bbb40120a1bc07c702d171abc1f219c7
\ No newline at end of file
diff --git a/mlruns/812028854715931404/85d03e113573486f916ffbc9daee41fe/tags/mlflow.source.name b/mlruns/812028854715931404/85d03e113573486f916ffbc9daee41fe/tags/mlflow.source.name
new file mode 100644
index 0000000..db800eb
--- /dev/null
+++ b/mlruns/812028854715931404/85d03e113573486f916ffbc9daee41fe/tags/mlflow.source.name
@@ -0,0 +1 @@
+D:\project\python\tradenote\test\workflow_by_code.py
\ No newline at end of file
diff --git a/mlruns/812028854715931404/85d03e113573486f916ffbc9daee41fe/tags/mlflow.source.type b/mlruns/812028854715931404/85d03e113573486f916ffbc9daee41fe/tags/mlflow.source.type
new file mode 100644
index 0000000..0c2c1fe
--- /dev/null
+++ b/mlruns/812028854715931404/85d03e113573486f916ffbc9daee41fe/tags/mlflow.source.type
@@ -0,0 +1 @@
+LOCAL
\ No newline at end of file
diff --git a/mlruns/812028854715931404/85d03e113573486f916ffbc9daee41fe/tags/mlflow.user b/mlruns/812028854715931404/85d03e113573486f916ffbc9daee41fe/tags/mlflow.user
new file mode 100644
index 0000000..b9cec6f
--- /dev/null
+++ b/mlruns/812028854715931404/85d03e113573486f916ffbc9daee41fe/tags/mlflow.user
@@ -0,0 +1 @@
+abulimity
\ No newline at end of file
diff --git a/mlruns/812028854715931404/8921d110545647f39692283e29142411/artifacts/code_cached.txt b/mlruns/812028854715931404/8921d110545647f39692283e29142411/artifacts/code_cached.txt
new file mode 100644
index 0000000..e69de29
diff --git a/mlruns/812028854715931404/8921d110545647f39692283e29142411/artifacts/code_diff.txt b/mlruns/812028854715931404/8921d110545647f39692283e29142411/artifacts/code_diff.txt
new file mode 100644
index 0000000..9f92fc1
--- /dev/null
+++ b/mlruns/812028854715931404/8921d110545647f39692283e29142411/artifacts/code_diff.txt
@@ -0,0 +1,1473 @@
+diff --git a/github/examples/benchmarks/LightGBM/workflow_config_lightgbm_Alpha1582.yaml b/github/examples/benchmarks/LightGBM/workflow_config_lightgbm_Alpha1582.yaml
+index 8b4e7bf..7a5eee7 100644
+--- a/github/examples/benchmarks/LightGBM/workflow_config_lightgbm_Alpha1582.yaml
++++ b/github/examples/benchmarks/LightGBM/workflow_config_lightgbm_Alpha1582.yaml
+@@ -1,5 +1,5 @@
+ qlib_init:
+-    provider_uri: "D:/project/tradenote/qlib_data/cn_data"
++    provider_uri: "D:/sync/qlib/qlib_data/cn_data"
+     region: cn
+ market: &market csi300
+ benchmark: &benchmark SH000300
+diff --git a/test/README_MA_Strategy.md b/test/README_MA_Strategy.md
+deleted file mode 100644
+index 5facaf7..0000000
+--- a/test/README_MA_Strategy.md
++++ /dev/null
+@@ -1,197 +0,0 @@
+-# 均线交叉策略 (Moving Average Crossover Strategy)
+-
+-## 策略概述
+-
+-这是一个基于qlib框架实现的均线交叉策略，核心逻辑是：
+-- **金叉买入**：短期均线上穿长期均线时买入
+-- **死叉卖出**：短期均线下穿长期均线时卖出
+-
+-## 文件说明
+-
+-### 1. `ma_cross_strategy.py`
+-完整的策略实现，包含：
+-- `MACrossStrategy` 类：继承自qlib的TopkDropoutStrategy
+-- 完整的回测框架
+-- 结果分析和保存
+-
+-### 2. `ma_cross_strategy_improved.py`
+-改进版本，包含：
+-- 更完善的数据获取逻辑
+-- 错误处理机制
+-- 简化版回测功能
+-
+-### 3. `simple_ma_strategy.py` ⭐ **推荐使用**
+-简单实用的版本，包含：
+-- 清晰的数据获取和处理
+-- 均线信号计算
+-- 收益计算和分析
+-- 可视化图表生成
+-- 结果保存功能
+-
+-## 使用方法
+-
+-### 环境准备
+-
+-1. 确保已安装qlib：
+-```bash
+-pip install pyqlib
+-```
+-
+-2. 下载qlib数据（如果还没有）：
+-```bash
+-# 下载中国股票数据
+-python -m qlib.data.dump_bin --csv_path ~/.qlib/qlib_data/cn_data --include_fields close,open,high,low,volume
+-```
+-
+-### 运行策略
+-
+-#### 方法1：运行简单版本（推荐）
+-```bash
+-cd test
+-python simple_ma_strategy.py
+-```
+-
+-#### 方法2：运行完整版本
+-```bash
+-cd test
+-python ma_cross_strategy.py
+-```
+-
+-#### 方法3：运行改进版本
+-```bash
+-cd test
+-python ma_cross_strategy_improved.py
+-```
+-
+-## 策略参数
+-
+-可以在代码中修改以下参数：
+-
+-```python
+-# 均线周期
+-short_window = 5    # 短期均线周期
+-long_window = 20    # 长期均线周期
+-
+-# 回测时间
+-start_date = "2020-01-01"
+-end_date = "2023-12-31"
+-
+-# 初始资金
+-initial_capital = 100000
+-
+-# 股票池
+-instruments = "csi300"  # 沪深300成分股
+-```
+-
+-## 输出结果
+-
+-运行策略后会生成以下文件：
+-
+-1. **CSV文件**：
+-   - `ma_cross_signals.csv`：买卖信号数据
+-   - `ma_cross_cumulative_returns.csv`：累计收益数据
+-   - `ma_cross_capital_curve.csv`：资金曲线数据
+-
+-2. **图表文件**：
+-   - `ma_cross_strategy_results.png`：策略结果可视化图表
+-
+-3. **控制台输出**：
+-   - 策略分析结果
+-   - 收益统计
+-   - 风险指标
+-
+-## 策略分析指标
+-
+-### 收益指标
+-- 总收益率
+-- 年化收益率
+-- 最终资金
+-
+-### 风险指标
+-- 年化波动率
+-- 夏普比率
+-- 胜率
+-- 最大回撤
+-
+-### 交易统计
+-- 买入信号数量
+-- 卖出信号数量
+-- 总交易次数
+-
+-## 策略逻辑详解
+-
+-### 1. 均线计算
+-```python
+-# 计算短期和长期均线
+-short_ma = price_data.rolling(window=short_window).mean()
+-long_ma = price_data.rolling(window=long_window).mean()
+-```
+-
+-### 2. 交叉信号判断
+-```python
+-# 计算均线差值
+-diff = short_ma - long_ma
+-
+-# 金叉：短期均线从下方穿越长期均线
+-if diff.iloc[i-1] < 0 and diff.iloc[i] > 0:
+-    signal = 1  # 买入信号
+-
+-# 死叉：短期均线从上方穿越长期均线
+-elif diff.iloc[i-1] > 0 and diff.iloc[i] < 0:
+-    signal = -1  # 卖出信号
+-```
+-
+-### 3. 收益计算
+-```python
+-# 策略收益（简化处理）
+-strategy_returns = signals * 0.01
+-
+-# 累计收益
+-cumulative_returns = strategy_returns.sum(axis=1).cumsum()
+-```
+-
+-## 注意事项
+-
+-1. **数据依赖**：确保qlib数据已正确下载和配置
+-2. **参数调优**：可以根据不同市场环境调整均线周期
+-3. **风险控制**：实际交易中需要加入止损和仓位管理
+-4. **交易成本**：当前版本未考虑交易费用，实际应用需要考虑
+-
+-## 扩展功能
+-
+-可以基于此策略进行以下扩展：
+-
+-1. **多均线策略**：使用多条均线进行更复杂的信号判断
+-2. **量价配合**：结合成交量指标优化信号
+-3. **止损机制**：添加动态止损策略
+-4. **仓位管理**：根据信号强度调整仓位大小
+-5. **多股票组合**：构建股票组合分散风险
+-
+-## 常见问题
+-
+-### Q: 如何修改股票池？
+-A: 在代码中修改 `instruments` 参数，例如：
+-```python
+-instruments = "csi500"  # 中证500
+-instruments = ["000001.SZ", "000002.SZ"]  # 指定股票列表
+-```
+-
+-### Q: 如何调整均线周期？
+-A: 修改 `short_window` 和 `long_window` 参数：
+-```python
+-short_window = 10  # 10日均线
+-long_window = 30   # 30日均线
+-```
+-
+-### Q: 如何查看详细的交易记录？
+-A: 查看生成的 `ma_cross_signals.csv` 文件，其中包含每日的买卖信号。
+-
+-## 联系方式
+-
+-如有问题或建议，请通过以下方式联系：
+-- 提交Issue到项目仓库
+-- 发送邮件到项目维护者
+-
+----
+-
+-**免责声明**：本策略仅供学习和研究使用，不构成投资建议。实际投资请谨慎决策，并承担相应风险。 
+\ No newline at end of file
+diff --git a/test/damo1.py b/test/damo1.py
+index 03102e1..7142dd1 100644
+--- a/test/damo1.py
++++ b/test/damo1.py
+@@ -1,5 +1,5 @@
+-# python scripts/get_data.py qlib_data --target_dir ../qlib_data/cn_data --region cn
+-
++# python github/scripts/get_data.py qlib_data --target_dir D:/sync/qlib/qlib_data/cn_data --region cn
++D:/sync/qlib/qlib_data/cn_data
+ import qlib
+ # region in [REG_CN, REG_US]
+ from qlib.constant import REG_CN
+diff --git a/test/demo2.ipynb b/test/demo2.ipynb
+index 66a0215..ad02df5 100644
+--- a/test/demo2.ipynb
++++ b/test/demo2.ipynb
+@@ -2,7 +2,7 @@
+  "cells": [
+   {
+    "cell_type": "code",
+-   "execution_count": 4,
++   "execution_count": 12,
+    "id": "6acb4a77",
+    "metadata": {},
+    "outputs": [
+@@ -10,39 +10,75 @@
+      "name": "stderr",
+      "output_type": "stream",
+      "text": [
+-      "[5344:MainThread](2025-06-18 14:41:03,895) INFO - qlib.Initialization - [config.py:420] - default_conf: client.\n",
+-      "[5344:MainThread](2025-06-18 14:41:03,900) INFO - qlib.Initialization - [__init__.py:74] - qlib successfully initialized based on client settings.\n",
+-      "[5344:MainThread](2025-06-18 14:41:03,903) INFO - qlib.Initialization - [__init__.py:76] - data_path={'__DEFAULT_FREQ': WindowsPath('D:/sync/qlib/qlib_data/cn_data')}\n"
++      "[13736:MainThread](2025-06-19 15:30:19,504) INFO - qlib.Initialization - [config.py:420] - default_conf: client.\n",
++      "[13736:MainThread](2025-06-19 15:30:19,506) INFO - qlib.Initialization - [__init__.py:74] - qlib successfully initialized based on client settings.\n",
++      "[13736:MainThread](2025-06-19 15:30:19,508) INFO - qlib.Initialization - [__init__.py:76] - data_path={'__DEFAULT_FREQ': WindowsPath('D:/sync/qlib/qlib_data/cn_data')}\n"
+      ]
+     }
+    ],
+    "source": [
+     "import qlib\n",
+-    "qlib.init(provider_uri=\"D:/sync/qlib/qlib_data/cn_data\", region=\"cn\")"
++    "qlib.init(provider_uri=r\"D:\\sync\\qlib\\qlib_data\\cn_data\", region=\"cn\")"
+    ]
+   },
+   {
+    "cell_type": "code",
+-   "execution_count": 12,
++   "execution_count": 14,
+    "id": "295df9af",
+    "metadata": {},
+    "outputs": [
+     {
+      "data": {
+       "text/plain": [
+-       "array([Timestamp('2020-09-21 00:00:00'), Timestamp('2020-09-22 00:00:00'),\n",
+-       "       Timestamp('2020-09-23 00:00:00'), Timestamp('2020-09-24 00:00:00'),\n",
+-       "       Timestamp('2020-09-25 00:00:00')], dtype=object)"
++       "array([Timestamp('2017-01-03 00:00:00'), Timestamp('2017-01-04 00:00:00'),\n",
++       "       Timestamp('2017-01-05 00:00:00'), Timestamp('2017-01-06 00:00:00'),\n",
++       "       Timestamp('2017-01-09 00:00:00')], dtype=object)"
+       ]
+      },
+-     "execution_count": 12,
++     "execution_count": 14,
+      "metadata": {},
+      "output_type": "execute_result"
+     }
+    ],
+    "source": [
+     "from qlib.data import D\n",
+-    "D.calendar(start_time='2020-09-21', end_time='2020-10-30', freq='day')"
++    "D.calendar(start_time=\"2017-01-01\", end_time=\"2020-08-01\",freq=\"day\")[:5]"
++   ]
++  },
++  {
++   "cell_type": "code",
++   "execution_count": 21,
++   "id": "da009afa",
++   "metadata": {},
++   "outputs": [
++    {
++     "ename": "error",
++     "evalue": "nothing to repeat at position 0",
++     "output_type": "error",
++     "traceback": [
++      "\u001b[31m---------------------------------------------------------------------------\u001b[39m",
++      "\u001b[31merror\u001b[39m                                     Traceback (most recent call last)",
++      "\u001b[36mCell\u001b[39m\u001b[36m \u001b[39m\u001b[32mIn[21]\u001b[39m\u001b[32m, line 4\u001b[39m\n\u001b[32m      2\u001b[39m nameDFilter = NameDFilter(name_rule_re=\u001b[33m'\u001b[39m\u001b[33m*000858\u001b[39m\u001b[33m'\u001b[39m)\n\u001b[32m      3\u001b[39m instruments = D.instruments(market=\u001b[33m'\u001b[39m\u001b[33mall\u001b[39m\u001b[33m'\u001b[39m,filter_pipe=[nameDFilter])\n\u001b[32m----> \u001b[39m\u001b[32m4\u001b[39m \u001b[43mD\u001b[49m\u001b[43m.\u001b[49m\u001b[43mlist_instruments\u001b[49m\u001b[43m(\u001b[49m\u001b[43minstruments\u001b[49m\u001b[43m=\u001b[49m\u001b[43minstruments\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mstart_time\u001b[49m\u001b[43m=\u001b[49m\u001b[33;43m'\u001b[39;49m\u001b[33;43m2015-01-01\u001b[39;49m\u001b[33;43m'\u001b[39;49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mend_time\u001b[49m\u001b[43m=\u001b[49m\u001b[33;43m'\u001b[39;49m\u001b[33;43m2016-02-15\u001b[39;49m\u001b[33;43m'\u001b[39;49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mas_list\u001b[49m\u001b[43m=\u001b[49m\u001b[38;5;28;43;01mTrue\u001b[39;49;00m\u001b[43m)\u001b[49m\n",
++      "\u001b[36mFile \u001b[39m\u001b[32md:\\project\\python\\tradenote\\.venv\\Lib\\site-packages\\qlib\\data\\data.py:1160\u001b[39m, in \u001b[36mBaseProvider.list_instruments\u001b[39m\u001b[34m(self, instruments, start_time, end_time, freq, as_list)\u001b[39m\n\u001b[32m   1159\u001b[39m \u001b[38;5;28;01mdef\u001b[39;00m\u001b[38;5;250m \u001b[39m\u001b[34mlist_instruments\u001b[39m(\u001b[38;5;28mself\u001b[39m, instruments, start_time=\u001b[38;5;28;01mNone\u001b[39;00m, end_time=\u001b[38;5;28;01mNone\u001b[39;00m, freq=\u001b[33m\"\u001b[39m\u001b[33mday\u001b[39m\u001b[33m\"\u001b[39m, as_list=\u001b[38;5;28;01mFalse\u001b[39;00m):\n\u001b[32m-> \u001b[39m\u001b[32m1160\u001b[39m     \u001b[38;5;28;01mreturn\u001b[39;00m \u001b[43mInst\u001b[49m\u001b[43m.\u001b[49m\u001b[43mlist_instruments\u001b[49m\u001b[43m(\u001b[49m\u001b[43minstruments\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mstart_time\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mend_time\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mfreq\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mas_list\u001b[49m\u001b[43m)\u001b[49m\n",
++      "\u001b[36mFile \u001b[39m\u001b[32md:\\project\\python\\tradenote\\.venv\\Lib\\site-packages\\qlib\\data\\data.py:719\u001b[39m, in \u001b[36mLocalInstrumentProvider.list_instruments\u001b[39m\u001b[34m(self, instruments, start_time, end_time, freq, as_list)\u001b[39m\n\u001b[32m    716\u001b[39m     \u001b[38;5;28;01mfrom\u001b[39;00m\u001b[38;5;250m \u001b[39m\u001b[34;01m.\u001b[39;00m\u001b[38;5;250m \u001b[39m\u001b[38;5;28;01mimport\u001b[39;00m \u001b[38;5;28mfilter\u001b[39m \u001b[38;5;28;01mas\u001b[39;00m F  \u001b[38;5;66;03m# pylint: disable=C0415\u001b[39;00m\n\u001b[32m    718\u001b[39m     filter_t = \u001b[38;5;28mgetattr\u001b[39m(F, filter_config[\u001b[33m\"\u001b[39m\u001b[33mfilter_type\u001b[39m\u001b[33m\"\u001b[39m]).from_config(filter_config)\n\u001b[32m--> \u001b[39m\u001b[32m719\u001b[39m     _instruments_filtered = \u001b[43mfilter_t\u001b[49m\u001b[43m(\u001b[49m\u001b[43m_instruments_filtered\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mstart_time\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mend_time\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mfreq\u001b[49m\u001b[43m)\u001b[49m\n\u001b[32m    720\u001b[39m \u001b[38;5;66;03m# as list\u001b[39;00m\n\u001b[32m    721\u001b[39m \u001b[38;5;28;01mif\u001b[39;00m as_list:\n",
++      "\u001b[36mFile \u001b[39m\u001b[32md:\\project\\python\\tradenote\\.venv\\Lib\\site-packages\\qlib\\data\\filter.py:192\u001b[39m, in \u001b[36mSeriesDFilter.__call__\u001b[39m\u001b[34m(self, instruments, start_time, end_time, freq)\u001b[39m\n\u001b[32m    190\u001b[39m \u001b[38;5;250m\u001b[39m\u001b[33;03m\"\"\"Call this filter to get filtered instruments list\"\"\"\u001b[39;00m\n\u001b[32m    191\u001b[39m \u001b[38;5;28mself\u001b[39m.filter_freq = freq\n\u001b[32m--> \u001b[39m\u001b[32m192\u001b[39m \u001b[38;5;28;01mreturn\u001b[39;00m \u001b[38;5;28;43mself\u001b[39;49m\u001b[43m.\u001b[49m\u001b[43mfilter_main\u001b[49m\u001b[43m(\u001b[49m\u001b[43minstruments\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mstart_time\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mend_time\u001b[49m\u001b[43m)\u001b[49m\n",
++      "\u001b[36mFile \u001b[39m\u001b[32md:\\project\\python\\tradenote\\.venv\\Lib\\site-packages\\qlib\\data\\filter.py:243\u001b[39m, in \u001b[36mSeriesDFilter.filter_main\u001b[39m\u001b[34m(self, instruments, start_time, end_time)\u001b[39m\n\u001b[32m    237\u001b[39m _all_calendar = Cal.calendar(start_time=start_time, end_time=end_time, freq=\u001b[38;5;28mself\u001b[39m.filter_freq)\n\u001b[32m    238\u001b[39m _filter_calendar = Cal.calendar(\n\u001b[32m    239\u001b[39m     start_time=\u001b[38;5;28mself\u001b[39m.filter_start_time \u001b[38;5;129;01mand\u001b[39;00m \u001b[38;5;28mmax\u001b[39m(\u001b[38;5;28mself\u001b[39m.filter_start_time, _all_calendar[\u001b[32m0\u001b[39m]) \u001b[38;5;129;01mor\u001b[39;00m _all_calendar[\u001b[32m0\u001b[39m],\n\u001b[32m    240\u001b[39m     end_time=\u001b[38;5;28mself\u001b[39m.filter_end_time \u001b[38;5;129;01mand\u001b[39;00m \u001b[38;5;28mmin\u001b[39m(\u001b[38;5;28mself\u001b[39m.filter_end_time, _all_calendar[-\u001b[32m1\u001b[39m]) \u001b[38;5;129;01mor\u001b[39;00m _all_calendar[-\u001b[32m1\u001b[39m],\n\u001b[32m    241\u001b[39m     freq=\u001b[38;5;28mself\u001b[39m.filter_freq,\n\u001b[32m    242\u001b[39m )\n\u001b[32m--> \u001b[39m\u001b[32m243\u001b[39m _all_filter_series = \u001b[38;5;28;43mself\u001b[39;49m\u001b[43m.\u001b[49m\u001b[43m_getFilterSeries\u001b[49m\u001b[43m(\u001b[49m\u001b[43minstruments\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43m_filter_calendar\u001b[49m\u001b[43m[\u001b[49m\u001b[32;43m0\u001b[39;49m\u001b[43m]\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43m_filter_calendar\u001b[49m\u001b[43m[\u001b[49m\u001b[43m-\u001b[49m\u001b[32;43m1\u001b[39;49m\u001b[43m]\u001b[49m\u001b[43m)\u001b[49m\n\u001b[32m    244\u001b[39m \u001b[38;5;28;01mfor\u001b[39;00m inst, timestamp \u001b[38;5;129;01min\u001b[39;00m instruments.items():\n\u001b[32m    245\u001b[39m     \u001b[38;5;66;03m# Construct a whole map of date\u001b[39;00m\n\u001b[32m    246\u001b[39m     _timestamp_series = \u001b[38;5;28mself\u001b[39m._toSeries(_all_calendar, timestamp)\n",
++      "\u001b[36mFile \u001b[39m\u001b[32md:\\project\\python\\tradenote\\.venv\\Lib\\site-packages\\qlib\\data\\filter.py:288\u001b[39m, in \u001b[36mNameDFilter._getFilterSeries\u001b[39m\u001b[34m(self, instruments, fstart, fend)\u001b[39m\n\u001b[32m    286\u001b[39m filter_calendar = Cal.calendar(start_time=fstart, end_time=fend, freq=\u001b[38;5;28mself\u001b[39m.filter_freq)\n\u001b[32m    287\u001b[39m \u001b[38;5;28;01mfor\u001b[39;00m inst, timestamp \u001b[38;5;129;01min\u001b[39;00m instruments.items():\n\u001b[32m--> \u001b[39m\u001b[32m288\u001b[39m     \u001b[38;5;28;01mif\u001b[39;00m \u001b[43mre\u001b[49m\u001b[43m.\u001b[49m\u001b[43mmatch\u001b[49m\u001b[43m(\u001b[49m\u001b[38;5;28;43mself\u001b[39;49m\u001b[43m.\u001b[49m\u001b[43mname_rule_re\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43minst\u001b[49m\u001b[43m)\u001b[49m:\n\u001b[32m    289\u001b[39m         _filter_series = pd.Series({timestamp: \u001b[38;5;28;01mTrue\u001b[39;00m \u001b[38;5;28;01mfor\u001b[39;00m timestamp \u001b[38;5;129;01min\u001b[39;00m filter_calendar})\n\u001b[32m    290\u001b[39m     \u001b[38;5;28;01melse\u001b[39;00m:\n",
++      "\u001b[36mFile \u001b[39m\u001b[32m~\\AppData\\Roaming\\uv\\python\\cpython-3.12.11-windows-x86_64-none\\Lib\\re\\__init__.py:167\u001b[39m, in \u001b[36mmatch\u001b[39m\u001b[34m(pattern, string, flags)\u001b[39m\n\u001b[32m    164\u001b[39m \u001b[38;5;28;01mdef\u001b[39;00m\u001b[38;5;250m \u001b[39m\u001b[34mmatch\u001b[39m(pattern, string, flags=\u001b[32m0\u001b[39m):\n\u001b[32m    165\u001b[39m \u001b[38;5;250m    \u001b[39m\u001b[33;03m\"\"\"Try to apply the pattern at the start of the string, returning\u001b[39;00m\n\u001b[32m    166\u001b[39m \u001b[33;03m    a Match object, or None if no match was found.\"\"\"\u001b[39;00m\n\u001b[32m--> \u001b[39m\u001b[32m167\u001b[39m     \u001b[38;5;28;01mreturn\u001b[39;00m \u001b[43m_compile\u001b[49m\u001b[43m(\u001b[49m\u001b[43mpattern\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mflags\u001b[49m\u001b[43m)\u001b[49m.match(string)\n",
++      "\u001b[36mFile \u001b[39m\u001b[32m~\\AppData\\Roaming\\uv\\python\\cpython-3.12.11-windows-x86_64-none\\Lib\\re\\__init__.py:307\u001b[39m, in \u001b[36m_compile\u001b[39m\u001b[34m(pattern, flags)\u001b[39m\n\u001b[32m    301\u001b[39m     \u001b[38;5;28;01mimport\u001b[39;00m\u001b[38;5;250m \u001b[39m\u001b[34;01mwarnings\u001b[39;00m\n\u001b[32m    302\u001b[39m     warnings.warn(\u001b[33m\"\u001b[39m\u001b[33mThe re.TEMPLATE/re.T flag is deprecated \u001b[39m\u001b[33m\"\u001b[39m\n\u001b[32m    303\u001b[39m             \u001b[33m\"\u001b[39m\u001b[33mas it is an undocumented flag \u001b[39m\u001b[33m\"\u001b[39m\n\u001b[32m    304\u001b[39m             \u001b[33m\"\u001b[39m\u001b[33mwithout an obvious purpose. \u001b[39m\u001b[33m\"\u001b[39m\n\u001b[32m    305\u001b[39m             \u001b[33m\"\u001b[39m\u001b[33mDon\u001b[39m\u001b[33m'\u001b[39m\u001b[33mt use it.\u001b[39m\u001b[33m\"\u001b[39m,\n\u001b[32m    306\u001b[39m             \u001b[38;5;167;01mDeprecationWarning\u001b[39;00m)\n\u001b[32m--> \u001b[39m\u001b[32m307\u001b[39m p = \u001b[43m_compiler\u001b[49m\u001b[43m.\u001b[49m\u001b[43mcompile\u001b[49m\u001b[43m(\u001b[49m\u001b[43mpattern\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mflags\u001b[49m\u001b[43m)\u001b[49m\n\u001b[32m    308\u001b[39m \u001b[38;5;28;01mif\u001b[39;00m flags & DEBUG:\n\u001b[32m    309\u001b[39m     \u001b[38;5;28;01mreturn\u001b[39;00m p\n",
++      "\u001b[36mFile \u001b[39m\u001b[32m~\\AppData\\Roaming\\uv\\python\\cpython-3.12.11-windows-x86_64-none\\Lib\\re\\_compiler.py:750\u001b[39m, in \u001b[36mcompile\u001b[39m\u001b[34m(p, flags)\u001b[39m\n\u001b[32m    748\u001b[39m \u001b[38;5;28;01mif\u001b[39;00m isstring(p):\n\u001b[32m    749\u001b[39m     pattern = p\n\u001b[32m--> \u001b[39m\u001b[32m750\u001b[39m     p = \u001b[43m_parser\u001b[49m\u001b[43m.\u001b[49m\u001b[43mparse\u001b[49m\u001b[43m(\u001b[49m\u001b[43mp\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mflags\u001b[49m\u001b[43m)\u001b[49m\n\u001b[32m    751\u001b[39m \u001b[38;5;28;01melse\u001b[39;00m:\n\u001b[32m    752\u001b[39m     pattern = \u001b[38;5;28;01mNone\u001b[39;00m\n",
++      "\u001b[36mFile \u001b[39m\u001b[32m~\\AppData\\Roaming\\uv\\python\\cpython-3.12.11-windows-x86_64-none\\Lib\\re\\_parser.py:979\u001b[39m, in \u001b[36mparse\u001b[39m\u001b[34m(str, flags, state)\u001b[39m\n\u001b[32m    976\u001b[39m state.flags = flags\n\u001b[32m    977\u001b[39m state.str = \u001b[38;5;28mstr\u001b[39m\n\u001b[32m--> \u001b[39m\u001b[32m979\u001b[39m p = \u001b[43m_parse_sub\u001b[49m\u001b[43m(\u001b[49m\u001b[43msource\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mstate\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mflags\u001b[49m\u001b[43m \u001b[49m\u001b[43m&\u001b[49m\u001b[43m \u001b[49m\u001b[43mSRE_FLAG_VERBOSE\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[32;43m0\u001b[39;49m\u001b[43m)\u001b[49m\n\u001b[32m    980\u001b[39m p.state.flags = fix_flags(\u001b[38;5;28mstr\u001b[39m, p.state.flags)\n\u001b[32m    982\u001b[39m \u001b[38;5;28;01mif\u001b[39;00m source.next \u001b[38;5;129;01mis\u001b[39;00m \u001b[38;5;129;01mnot\u001b[39;00m \u001b[38;5;28;01mNone\u001b[39;00m:\n",
++      "\u001b[36mFile \u001b[39m\u001b[32m~\\AppData\\Roaming\\uv\\python\\cpython-3.12.11-windows-x86_64-none\\Lib\\re\\_parser.py:460\u001b[39m, in \u001b[36m_parse_sub\u001b[39m\u001b[34m(source, state, verbose, nested)\u001b[39m\n\u001b[32m    458\u001b[39m start = source.tell()\n\u001b[32m    459\u001b[39m \u001b[38;5;28;01mwhile\u001b[39;00m \u001b[38;5;28;01mTrue\u001b[39;00m:\n\u001b[32m--> \u001b[39m\u001b[32m460\u001b[39m     itemsappend(\u001b[43m_parse\u001b[49m\u001b[43m(\u001b[49m\u001b[43msource\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mstate\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mverbose\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mnested\u001b[49m\u001b[43m \u001b[49m\u001b[43m+\u001b[49m\u001b[43m \u001b[49m\u001b[32;43m1\u001b[39;49m\u001b[43m,\u001b[49m\n\u001b[32m    461\u001b[39m \u001b[43m                       \u001b[49m\u001b[38;5;129;43;01mnot\u001b[39;49;00m\u001b[43m \u001b[49m\u001b[43mnested\u001b[49m\u001b[43m \u001b[49m\u001b[38;5;129;43;01mand\u001b[39;49;00m\u001b[43m \u001b[49m\u001b[38;5;129;43;01mnot\u001b[39;49;00m\u001b[43m \u001b[49m\u001b[43mitems\u001b[49m\u001b[43m)\u001b[49m)\n\u001b[32m    462\u001b[39m     \u001b[38;5;28;01mif\u001b[39;00m \u001b[38;5;129;01mnot\u001b[39;00m sourcematch(\u001b[33m\"\u001b[39m\u001b[33m|\u001b[39m\u001b[33m\"\u001b[39m):\n\u001b[32m    463\u001b[39m         \u001b[38;5;28;01mbreak\u001b[39;00m\n",
++      "\u001b[36mFile \u001b[39m\u001b[32m~\\AppData\\Roaming\\uv\\python\\cpython-3.12.11-windows-x86_64-none\\Lib\\re\\_parser.py:687\u001b[39m, in \u001b[36m_parse\u001b[39m\u001b[34m(source, state, verbose, nested, first)\u001b[39m\n\u001b[32m    685\u001b[39m     item = \u001b[38;5;28;01mNone\u001b[39;00m\n\u001b[32m    686\u001b[39m \u001b[38;5;28;01mif\u001b[39;00m \u001b[38;5;129;01mnot\u001b[39;00m item \u001b[38;5;129;01mor\u001b[39;00m item[\u001b[32m0\u001b[39m][\u001b[32m0\u001b[39m] \u001b[38;5;129;01mis\u001b[39;00m AT:\n\u001b[32m--> \u001b[39m\u001b[32m687\u001b[39m     \u001b[38;5;28;01mraise\u001b[39;00m source.error(\u001b[33m\"\u001b[39m\u001b[33mnothing to repeat\u001b[39m\u001b[33m\"\u001b[39m,\n\u001b[32m    688\u001b[39m                        source.tell() - here + \u001b[38;5;28mlen\u001b[39m(this))\n\u001b[32m    689\u001b[39m \u001b[38;5;28;01mif\u001b[39;00m item[\u001b[32m0\u001b[39m][\u001b[32m0\u001b[39m] \u001b[38;5;129;01min\u001b[39;00m _REPEATCODES:\n\u001b[32m    690\u001b[39m     \u001b[38;5;28;01mraise\u001b[39;00m source.error(\u001b[33m\"\u001b[39m\u001b[33mmultiple repeat\u001b[39m\u001b[33m\"\u001b[39m,\n\u001b[32m    691\u001b[39m                        source.tell() - here + \u001b[38;5;28mlen\u001b[39m(this))\n",
++      "\u001b[31merror\u001b[39m: nothing to repeat at position 0"
++     ]
++    }
++   ],
++   "source": [
++    "from qlib.data.filter import NameDFilter\n",
++    "nameDFilter = NameDFilter(name_rule_re='*000858')\n",
++    "instruments = D.instruments(market='all',filter_pipe=[nameDFilter])\n",
++    "D.list_instruments(instruments=instruments, start_time='2015-01-01', end_time='2016-02-15', as_list=True)\n"
+    ]
+   }
+  ],
+diff --git a/test/ma_cross_strategy.py b/test/ma_cross_strategy.py
+deleted file mode 100644
+index 719d849..0000000
+--- a/test/ma_cross_strategy.py
++++ /dev/null
+@@ -1,274 +0,0 @@
+-"""
+-均线交叉策略：金叉买入，死叉卖出
+-使用qlib框架实现
+-"""
+-
+-import qlib
+-from qlib.constant import REG_CN
+-from qlib.utils import init_instance_by_config
+-from qlib.workflow import R
+-from qlib.workflow.record_temp import SignalRecord, PortAnaRecord
+-from qlib.contrib.evaluate import backtest_daily
+-from qlib.contrib.strategy import TopkDropoutStrategy
+-import pandas as pd
+-import numpy as np
+-from typing import Dict, List, Tuple
+-
+-
+-class MACrossStrategy(TopkDropoutStrategy):
+-    """
+-    均线交叉策略
+-    金叉（短期均线上穿长期均线）买入
+-    死叉（短期均线下穿长期均线）卖出
+-    """
+-    
+-    def __init__(self, 
+-                 short_window: int = 5,
+-                 long_window: int = 20,
+-                 topk: int = 50,
+-                 n_drop: int = 5,
+-                 **kwargs):
+-        """
+-        初始化策略参数
+-        
+-        Args:
+-            short_window: 短期均线周期
+-            long_window: 长期均线周期
+-            topk: 选择前k只股票
+-            n_drop: 剔除前n只股票
+-        """
+-        super().__init__(topk=topk, n_drop=n_drop, **kwargs)
+-        self.short_window = short_window
+-        self.long_window = long_window
+-        
+-    def generate_trade_decision(self, score: pd.Series, trade_step: int) -> pd.Series:
+-        """
+-        生成交易决策
+-        
+-        Args:
+-            score: 股票评分
+-            trade_step: 交易步骤
+-            
+-        Returns:
+-            交易决策，1表示买入，-1表示卖出，0表示持有
+-        """
+-        # 获取当前持仓
+-        current_pos = self.get_current_position()
+-        
+-        # 计算均线信号
+-        signal = self._calculate_ma_signal(score.index.tolist(), trade_step)
+-        
+-        # 生成交易决策
+-        decision = pd.Series(0, index=score.index)
+-        
+-        # 金叉买入信号
+-        buy_signal = signal == 1
+-        decision[buy_signal] = 1
+-        
+-        # 死叉卖出信号
+-        sell_signal = signal == -1
+-        decision[sell_signal] = -1
+-        
+-        return decision
+-    
+-    def _calculate_ma_signal(self, instruments: List[str], trade_step: int) -> pd.Series:
+-        """
+-        计算均线交叉信号
+-        
+-        Args:
+-            instruments: 股票代码列表
+-            trade_step: 交易步骤
+-            
+-        Returns:
+-            信号序列：1表示金叉买入，-1表示死叉卖出，0表示无信号
+-        """
+-        # 获取历史数据
+-        data = self._get_historical_data(instruments, trade_step)
+-        
+-        signals = pd.Series(0, index=instruments)
+-        
+-        for instrument in instruments:
+-            if instrument in data.index:
+-                # 计算短期和长期均线
+-                short_ma = data.loc[instrument].rolling(window=self.short_window).mean()
+-                long_ma = data.loc[instrument].rolling(window=self.long_window).mean()
+-                
+-                # 计算交叉信号
+-                if len(short_ma) >= 2 and len(long_ma) >= 2:
+-                    # 当前和前一个时间点的均线差值
+-                    current_diff = short_ma.iloc[-1] - long_ma.iloc[-1]
+-                    prev_diff = short_ma.iloc[-2] - long_ma.iloc[-2]
+-                    
+-                    # 金叉：短期均线从下方穿越长期均线
+-                    if prev_diff < 0 and current_diff > 0:
+-                        signals[instrument] = 1
+-                    # 死叉：短期均线从上方穿越长期均线
+-                    elif prev_diff > 0 and current_diff < 0:
+-                        signals[instrument] = -1
+-        
+-        return signals
+-    
+-    def _get_historical_data(self, instruments: List[str], trade_step: int) -> pd.DataFrame:
+-        """
+-        获取历史价格数据
+-        
+-        Args:
+-            instruments: 股票代码列表
+-            trade_step: 交易步骤
+-            
+-        Returns:
+-            历史价格数据
+-        """
+-        # 这里简化处理，实际应该从qlib数据源获取
+-        # 在实际应用中，您需要使用qlib的数据接口
+-        try:
+-            # 获取最近的数据用于计算均线
+-            # 这里使用模拟数据，实际应该从qlib获取
+-            dates = pd.date_range(end=pd.Timestamp.now(), periods=50, freq='D')
+-            data = pd.DataFrame(
+-                np.random.randn(len(dates), len(instruments)) * 0.02 + 1.0,
+-                index=dates,
+-                columns=instruments
+-            )
+-            return data
+-        except Exception as e:
+-            print(f"获取历史数据失败: {e}")
+-            return pd.DataFrame()
+-
+-
+-def create_ma_cross_strategy_config():
+-    """
+-    创建均线交叉策略配置
+-    """
+-    strategy_config = {
+-        "class": "MACrossStrategy",
+-        "module_path": "test.ma_cross_strategy",
+-        "kwargs": {
+-            "short_window": 5,
+-            "long_window": 20,
+-            "topk": 50,
+-            "n_drop": 5,
+-        }
+-    }
+-    
+-    return strategy_config
+-
+-
+-def run_backtest():
+-    """
+-    运行回测
+-    """
+-    # 初始化qlib
+-    qlib.init(provider_uri='~/.qlib/qlib_data/cn_data', region=REG_CN)
+-    
+-    # 策略配置
+-    strategy_config = create_ma_cross_strategy_config()
+-    
+-    # 回测配置
+-    backtest_config = {
+-        "start_time": "2020-01-01",
+-        "end_time": "2023-12-31",
+-        "benchmark": "SH000300",  # 沪深300作为基准
+-        "account": 100000000,     # 初始资金1亿
+-        "exchange_kwargs": {
+-            "freq": "day",
+-            "limit_threshold": 0.095,
+-            "deal_price": "close",
+-            "open_cost": 0.0005,
+-            "close_cost": 0.0015,
+-            "min_cost": 5,
+-        }
+-    }
+-    
+-    # 创建策略实例
+-    strategy = init_instance_by_config(strategy_config)
+-    
+-    # 运行回测
+-    with R.start(experiment_name="ma_cross_strategy"):
+-        # 记录信号
+-        sr = SignalRecord(model=strategy, dataset=None, recorder=R.get_recorder())
+-        sr.generate()
+-        
+-        # 记录投资组合分析
+-        par = PortAnaRecord(recorder=R.get_recorder(), config=backtest_config, strategy=strategy)
+-        par.generate()
+-        
+-        # 获取回测结果
+-        report_normal, positions_normal = backtest_daily(
+-            account=backtest_config["account"],
+-            benchmark=backtest_config["benchmark"],
+-            start_time=backtest_config["start_time"],
+-            end_time=backtest_config["end_time"],
+-            strategy=strategy,
+-            exchange_kwargs=backtest_config["exchange_kwargs"]
+-        )
+-        
+-        return report_normal, positions_normal
+-
+-
+-def analyze_results(report: pd.DataFrame, positions: pd.DataFrame):
+-    """
+-    分析回测结果
+-    
+-    Args:
+-        report: 回测报告
+-        positions: 持仓信息
+-    """
+-    print("=" * 50)
+-    print("均线交叉策略回测结果")
+-    print("=" * 50)
+-    
+-    # 基本统计信息
+-    print(f"总收益率: {report['return'].sum():.2%}")
+-    print(f"年化收益率: {report['return'].mean() * 252:.2%}")
+-    print(f"最大回撤: {report['drawdown'].min():.2%}")
+-    print(f"夏普比率: {report['sharpe'].iloc[-1]:.2f}")
+-    print(f"胜率: {(report['return'] > 0).mean():.2%}")
+-    
+-    # 风险指标
+-    volatility = report['return'].std() * np.sqrt(252)
+-    print(f"年化波动率: {volatility:.2%}")
+-    
+-    # 最大回撤期间
+-    max_drawdown_idx = report['drawdown'].idxmin()
+-    print(f"最大回撤发生时间: {max_drawdown_idx}")
+-    
+-    # 收益分布
+-    print("\n收益分布统计:")
+-    print(f"平均日收益: {report['return'].mean():.2%}")
+-    print(f"收益标准差: {report['return'].std():.2%}")
+-    print(f"最小日收益: {report['return'].min():.2%}")
+-    print(f"最大日收益: {report['return'].max():.2%}")
+-    
+-    # 交易统计
+-    if 'trade_count' in report.columns:
+-        print(f"\n总交易次数: {report['trade_count'].sum()}")
+-        print(f"平均每日交易次数: {report['trade_count'].mean():.1f}")
+-
+-
+-def main():
+-    """
+-    主函数
+-    """
+-    print("开始运行均线交叉策略回测...")
+-    
+-    try:
+-        # 运行回测
+-        report, positions = run_backtest()
+-        
+-        # 分析结果
+-        analyze_results(report, positions)
+-        
+-        # 保存结果
+-        report.to_csv("ma_cross_strategy_report.csv")
+-        positions.to_csv("ma_cross_strategy_positions.csv")
+-        
+-        print("\n回测完成！结果已保存到CSV文件。")
+-        
+-    except Exception as e:
+-        print(f"回测过程中出现错误: {e}")
+-        print("请确保已正确安装qlib并下载了相应的数据。")
+-
+-
+-if __name__ == "__main__":
+-    main() 
+\ No newline at end of file
+diff --git a/test/ma_cross_strategy_improved.py b/test/ma_cross_strategy_improved.py
+deleted file mode 100644
+index d166c68..0000000
+--- a/test/ma_cross_strategy_improved.py
++++ /dev/null
+@@ -1,443 +0,0 @@
+-"""
+-改进的均线交叉策略：金叉买入，死叉卖出
+-使用qlib框架实现，包含完整的数据获取和信号计算
+-"""
+-
+-import qlib
+-from qlib.constant import REG_CN
+-from qlib.utils import init_instance_by_config
+-from qlib.workflow import R
+-from qlib.workflow.record_temp import SignalRecord, PortAnaRecord
+-from qlib.contrib.evaluate import backtest_daily
+-from qlib.contrib.strategy import TopkDropoutStrategy
+-from qlib.data import D
+-from qlib.data.dataset import DatasetH
+-from qlib.data.dataset.handler import DataHandlerLP
+-import pandas as pd
+-import numpy as np
+-from typing import Dict, List, Tuple
+-import warnings
+-warnings.filterwarnings('ignore')
+-
+-
+-class MACrossStrategyImproved(TopkDropoutStrategy):
+-    """
+-    改进的均线交叉策略
+-    金叉（短期均线上穿长期均线）买入
+-    死叉（短期均线下穿长期均线）卖出
+-    """
+-    
+-    def __init__(self, 
+-                 short_window: int = 5,
+-                 long_window: int = 20,
+-                 topk: int = 50,
+-                 n_drop: int = 5,
+-                 universe: str = "csi300",
+-                 **kwargs):
+-        """
+-        初始化策略参数
+-        
+-        Args:
+-            short_window: 短期均线周期
+-            long_window: 长期均线周期
+-            topk: 选择前k只股票
+-            n_drop: 剔除前n只股票
+-            universe: 股票池
+-        """
+-        super().__init__(topk=topk, n_drop=n_drop, **kwargs)
+-        self.short_window = short_window
+-        self.long_window = long_window
+-        self.universe = universe
+-        self.instruments = None
+-        self.price_cache = {}
+-        
+-    def generate_trade_decision(self, score: pd.Series, trade_step: int) -> pd.Series:
+-        """
+-        生成交易决策
+-        
+-        Args:
+-            score: 股票评分
+-            trade_step: 交易步骤
+-            
+-        Returns:
+-            交易决策，1表示买入，-1表示卖出，0表示持有
+-        """
+-        # 获取当前持仓
+-        current_pos = self.get_current_position()
+-        
+-        # 计算均线信号
+-        signal = self._calculate_ma_signal(score.index.tolist(), trade_step)
+-        
+-        # 生成交易决策
+-        decision = pd.Series(0, index=score.index)
+-        
+-        # 金叉买入信号
+-        buy_signal = signal == 1
+-        decision[buy_signal] = 1
+-        
+-        # 死叉卖出信号
+-        sell_signal = signal == -1
+-        decision[sell_signal] = -1
+-        
+-        return decision
+-    
+-    def _calculate_ma_signal(self, instruments: List[str], trade_step: int) -> pd.Series:
+-        """
+-        计算均线交叉信号
+-        
+-        Args:
+-            instruments: 股票代码列表
+-            trade_step: 交易步骤
+-            
+-        Returns:
+-            信号序列：1表示金叉买入，-1表示死叉卖出，0表示无信号
+-        """
+-        signals = pd.Series(0, index=instruments)
+-        
+-        # 获取当前日期
+-        current_date = self._get_current_date(trade_step)
+-        
+-        for instrument in instruments:
+-            try:
+-                # 获取历史价格数据
+-                price_data = self._get_price_data(instrument, current_date)
+-                
+-                if price_data is not None and len(price_data) >= self.long_window:
+-                    # 计算短期和长期均线
+-                    short_ma = price_data['close'].rolling(window=self.short_window).mean()
+-                    long_ma = price_data['close'].rolling(window=self.long_window).mean()
+-                    
+-                    # 计算交叉信号
+-                    if len(short_ma) >= 2 and len(long_ma) >= 2:
+-                        # 当前和前一个时间点的均线差值
+-                        current_diff = short_ma.iloc[-1] - long_ma.iloc[-1]
+-                        prev_diff = short_ma.iloc[-2] - long_ma.iloc[-2]
+-                        
+-                        # 金叉：短期均线从下方穿越长期均线
+-                        if prev_diff < 0 and current_diff > 0:
+-                            signals[instrument] = 1
+-                        # 死叉：短期均线从上方穿越长期均线
+-                        elif prev_diff > 0 and current_diff < 0:
+-                            signals[instrument] = -1
+-                            
+-            except Exception as e:
+-                print(f"计算{instrument}均线信号时出错: {e}")
+-                continue
+-        
+-        return signals
+-    
+-    def _get_price_data(self, instrument: str, current_date: str) -> pd.DataFrame:
+-        """
+-        获取股票价格数据
+-        
+-        Args:
+-            instrument: 股票代码
+-            current_date: 当前日期
+-            
+-        Returns:
+-            价格数据DataFrame
+-        """
+-        try:
+-            # 计算开始日期（获取足够的历史数据来计算均线）
+-            start_date = pd.Timestamp(current_date) - pd.Timedelta(days=self.long_window * 2)
+-            
+-            # 从qlib获取数据
+-            data = D.features(
+-                instruments=[instrument],
+-                start_time=start_date.strftime('%Y-%m-%d'),
+-                end_time=current_date,
+-                freq='day',
+-                fields=['$close', '$open', '$high', '$low', '$volume']
+-            )
+-            
+-            if data is not None and not data.empty:
+-                # 重命名列
+-                data.columns = ['close', 'open', 'high', 'low', 'volume']
+-                return data
+-            else:
+-                return None
+-                
+-        except Exception as e:
+-            print(f"获取{instrument}价格数据失败: {e}")
+-            return None
+-    
+-    def _get_current_date(self, trade_step: int) -> str:
+-        """
+-        根据交易步骤获取当前日期
+-        
+-        Args:
+-            trade_step: 交易步骤
+-            
+-        Returns:
+-            当前日期字符串
+-        """
+-        # 这里简化处理，实际应该从qlib的日历获取
+-        # 假设从2020-01-01开始，每个trade_step代表一天
+-        start_date = pd.Timestamp('2020-01-01')
+-        current_date = start_date + pd.Timedelta(days=trade_step)
+-        return current_date.strftime('%Y-%m-%d')
+-
+-
+-def create_dataset_config():
+-    """
+-    创建数据集配置
+-    """
+-    dataset_config = {
+-        "class": "DatasetH",
+-        "module_path": "qlib.data.dataset",
+-        "kwargs": {
+-            "handler": {
+-                "class": "DataHandlerLP",
+-                "module_path": "qlib.data.dataset.handler",
+-                "kwargs": {
+-                    "start_time": "2020-01-01",
+-                    "end_time": "2023-12-31",
+-                    "fit_start_time": "2020-01-01",
+-                    "fit_end_time": "2023-12-31",
+-                    "instruments": "csi300",
+-                    "infer_processors": [
+-                        {
+-                            "class": "RobustZScoreNorm",
+-                            "module_path": "qlib.data.dataset.processor",
+-                            "kwargs": {
+-                                "fields_group": "feature",
+-                                "clip_outlier": True,
+-                            },
+-                        },
+-                        {
+-                            "class": "Fillna",
+-                            "module_path": "qlib.data.dataset.processor",
+-                            "kwargs": {
+-                                "fields_group": "feature",
+-                            },
+-                        },
+-                    ],
+-                    "learn_processors": [
+-                        {
+-                            "class": "DropnaLabel",
+-                            "module_path": "qlib.data.dataset.processor",
+-                        },
+-                        {
+-                            "class": "CSRankNorm",
+-                            "module_path": "qlib.data.dataset.processor",
+-                            "kwargs": {
+-                                "fields_group": "label",
+-                            },
+-                        },
+-                    ],
+-                    "instruments": "csi300",
+-                },
+-            },
+-            "segments": {
+-                "train": ("2020-01-01", "2022-12-31"),
+-                "valid": ("2023-01-01", "2023-06-30"),
+-                "test": ("2023-07-01", "2023-12-31"),
+-            },
+-        },
+-    }
+-    
+-    return dataset_config
+-
+-
+-def create_ma_cross_strategy_config():
+-    """
+-    创建均线交叉策略配置
+-    """
+-    strategy_config = {
+-        "class": "MACrossStrategyImproved",
+-        "module_path": "test.ma_cross_strategy_improved",
+-        "kwargs": {
+-            "short_window": 5,
+-            "long_window": 20,
+-            "topk": 50,
+-            "n_drop": 5,
+-            "universe": "csi300",
+-        }
+-    }
+-    
+-    return strategy_config
+-
+-
+-def run_backtest():
+-    """
+-    运行回测
+-    """
+-    # 初始化qlib
+-    qlib.init(provider_uri='~/.qlib/qlib_data/cn_data', region=REG_CN)
+-    
+-    # 策略配置
+-    strategy_config = create_ma_cross_strategy_config()
+-    
+-    # 回测配置
+-    backtest_config = {
+-        "start_time": "2020-01-01",
+-        "end_time": "2023-12-31",
+-        "benchmark": "SH000300",  # 沪深300作为基准
+-        "account": 100000000,     # 初始资金1亿
+-        "exchange_kwargs": {
+-            "freq": "day",
+-            "limit_threshold": 0.095,
+-            "deal_price": "close",
+-            "open_cost": 0.0005,
+-            "close_cost": 0.0015,
+-            "min_cost": 5,
+-        }
+-    }
+-    
+-    # 创建策略实例
+-    strategy = init_instance_by_config(strategy_config)
+-    
+-    # 运行回测
+-    with R.start(experiment_name="ma_cross_strategy_improved"):
+-        # 记录信号
+-        sr = SignalRecord(model=strategy, dataset=None, recorder=R.get_recorder())
+-        sr.generate()
+-        
+-        # 记录投资组合分析
+-        par = PortAnaRecord(recorder=R.get_recorder(), config=backtest_config, strategy=strategy)
+-        par.generate()
+-        
+-        # 获取回测结果
+-        report_normal, positions_normal = backtest_daily(
+-            account=backtest_config["account"],
+-            benchmark=backtest_config["benchmark"],
+-            start_time=backtest_config["start_time"],
+-            end_time=backtest_config["end_time"],
+-            strategy=strategy,
+-            exchange_kwargs=backtest_config["exchange_kwargs"]
+-        )
+-        
+-        return report_normal, positions_normal
+-
+-
+-def analyze_results(report: pd.DataFrame, positions: pd.DataFrame):
+-    """
+-    分析回测结果
+-    
+-    Args:
+-        report: 回测报告
+-        positions: 持仓信息
+-    """
+-    print("=" * 50)
+-    print("均线交叉策略回测结果")
+-    print("=" * 50)
+-    
+-    # 基本统计信息
+-    print(f"总收益率: {report['return'].sum():.2%}")
+-    print(f"年化收益率: {report['return'].mean() * 252:.2%}")
+-    print(f"最大回撤: {report['drawdown'].min():.2%}")
+-    
+-    if 'sharpe' in report.columns:
+-        print(f"夏普比率: {report['sharpe'].iloc[-1]:.2f}")
+-    
+-    print(f"胜率: {(report['return'] > 0).mean():.2%}")
+-    
+-    # 风险指标
+-    volatility = report['return'].std() * np.sqrt(252)
+-    print(f"年化波动率: {volatility:.2%}")
+-    
+-    # 最大回撤期间
+-    max_drawdown_idx = report['drawdown'].idxmin()
+-    print(f"最大回撤发生时间: {max_drawdown_idx}")
+-    
+-    # 收益分布
+-    print("\n收益分布统计:")
+-    print(f"平均日收益: {report['return'].mean():.2%}")
+-    print(f"收益标准差: {report['return'].std():.2%}")
+-    print(f"最小日收益: {report['return'].min():.2%}")
+-    print(f"最大日收益: {report['return'].max():.2%}")
+-    
+-    # 交易统计
+-    if 'trade_count' in report.columns:
+-        print(f"\n总交易次数: {report['trade_count'].sum()}")
+-        print(f"平均每日交易次数: {report['trade_count'].mean():.1f}")
+-
+-
+-def create_simple_backtest():
+-    """
+-    创建简化版回测，用于演示
+-    """
+-    print("创建简化版均线交叉策略回测...")
+-    
+-    # 初始化qlib
+-    qlib.init(provider_uri='~/.qlib/qlib_data/cn_data', region=REG_CN)
+-    
+-    # 获取股票列表
+-    instruments = D.list_instruments(instruments="csi300", start_time="2020-01-01", end_time="2023-12-31")
+-    
+-    print(f"获取到 {len(instruments)} 只股票")
+-    
+-    # 选择前10只股票进行演示
+-    demo_instruments = instruments[:10]
+-    
+-    # 获取价格数据
+-    data = D.features(
+-        instruments=demo_instruments,
+-        start_time="2020-01-01",
+-        end_time="2023-12-31",
+-        freq='day',
+-        fields=['$close']
+-    )
+-    
+-    print(f"获取到价格数据，形状: {data.shape}")
+-    
+-    # 计算均线
+-    short_ma = data.rolling(window=5).mean()
+-    long_ma = data.rolling(window=20).mean()
+-    
+-    # 计算交叉信号
+-    signals = pd.DataFrame(0, index=data.index, columns=data.columns)
+-    
+-    for col in data.columns:
+-        # 计算均线差值
+-        diff = short_ma[col] - long_ma[col]
+-        
+-        # 计算交叉信号
+-        for i in range(1, len(diff)):
+-            if diff.iloc[i-1] < 0 and diff.iloc[i] > 0:
+-                signals.iloc[i, signals.columns.get_loc(col)] = 1  # 金叉买入
+-            elif diff.iloc[i-1] > 0 and diff.iloc[i] < 0:
+-                signals.iloc[i, signals.columns.get_loc(col)] = -1  # 死叉卖出
+-    
+-    # 统计信号
+-    buy_signals = (signals == 1).sum().sum()
+-    sell_signals = (signals == -1).sum().sum()
+-    
+-    print(f"\n信号统计:")
+-    print(f"买入信号数量: {buy_signals}")
+-    print(f"卖出信号数量: {sell_signals}")
+-    
+-    # 计算简单收益（假设每次信号都产生1%的收益）
+-    returns = signals * 0.01
+-    cumulative_returns = returns.sum(axis=1).cumsum()
+-    
+-    print(f"\n累计收益: {cumulative_returns.iloc[-1]:.2%}")
+-    
+-    return signals, cumulative_returns
+-
+-
+-def main():
+-    """
+-    主函数
+-    """
+-    print("开始运行均线交叉策略回测...")
+-    
+-    try:
+-        # 运行简化版回测
+-        signals, cumulative_returns = create_simple_backtest()
+-        
+-        # 保存简化版结果
+-        signals.to_csv("ma_cross_signals.csv")
+-        cumulative_returns.to_csv("ma_cross_cumulative_returns.csv")
+-        
+-        print("\n简化版回测完成！")
+-        print("信号数据已保存到 ma_cross_signals.csv")
+-        print("累计收益已保存到 ma_cross_cumulative_returns.csv")
+-        
+-    except Exception as e:
+-        print(f"回测过程中出现错误: {e}")
+-        print("请确保已正确安装qlib并下载了相应的数据。")
+-
+-
+-if __name__ == "__main__":
+-    main() 
+\ No newline at end of file
+diff --git a/test/ma_strategy_demo.py b/test/ma_strategy_demo.py
+deleted file mode 100644
+index 1fa4fb4..0000000
+Binary files a/test/ma_strategy_demo.py and /dev/null differ
+diff --git a/test/simple_ma_strategy.py b/test/simple_ma_strategy.py
+deleted file mode 100644
+index 8d03f6b..0000000
+--- a/test/simple_ma_strategy.py
++++ /dev/null
+@@ -1,298 +0,0 @@
+-"""
+-简单实用的均线交叉策略
+-金叉买入，死叉卖出
+-"""
+-
+-import qlib
+-from qlib.constant import REG_CN
+-from qlib.data import D
+-import pandas as pd
+-import numpy as np
+-import matplotlib.pyplot as plt
+-from datetime import datetime, timedelta
+-
+-
+-def init_qlib():
+-    """初始化qlib"""
+-    try:
+-        qlib.init(provider_uri='~/.qlib/qlib_data/cn_data', region=REG_CN)
+-        print("qlib初始化成功")
+-        return True
+-    except Exception as e:
+-        print(f"qlib初始化失败: {e}")
+-        print("请确保已安装qlib并下载了数据")
+-        return False
+-
+-
+-def get_stock_data(instruments, start_date, end_date):
+-    """
+-    获取股票数据
+-    
+-    Args:
+-        instruments: 股票代码列表
+-        start_date: 开始日期
+-        end_date: 结束日期
+-    
+-    Returns:
+-        股票价格数据
+-    """
+-    try:
+-        data = D.features(
+-            instruments=instruments,
+-            start_time=start_date,
+-            end_time=end_date,
+-            freq='day',
+-            fields=['$close', '$open', '$high', '$low', '$volume']
+-        )
+-        
+-        if data is not None and not data.empty:
+-            # 重命名列
+-            data.columns = ['close', 'open', 'high', 'low', 'volume']
+-            return data
+-        else:
+-            print("未获取到数据")
+-            return None
+-            
+-    except Exception as e:
+-        print(f"获取数据失败: {e}")
+-        return None
+-
+-
+-def calculate_ma_signals(data, short_window=5, long_window=20):
+-    """
+-    计算均线交叉信号
+-    
+-    Args:
+-        data: 价格数据
+-        short_window: 短期均线周期
+-        long_window: 长期均线周期
+-    
+-    Returns:
+-        信号DataFrame，1表示买入，-1表示卖出，0表示无信号
+-    """
+-    signals = pd.DataFrame(0, index=data.index, columns=data.columns)
+-    
+-    for col in data.columns:
+-        if col == 'close':
+-            continue
+-            
+-        # 计算均线
+-        short_ma = data[col].rolling(window=short_window).mean()
+-        long_ma = data[col].rolling(window=long_window).mean()
+-        
+-        # 计算均线差值
+-        diff = short_ma - long_ma
+-        
+-        # 计算交叉信号
+-        for i in range(1, len(diff)):
+-            if pd.notna(diff.iloc[i-1]) and pd.notna(diff.iloc[i]):
+-                # 金叉：短期均线从下方穿越长期均线
+-                if diff.iloc[i-1] < 0 and diff.iloc[i] > 0:
+-                    signals.iloc[i, signals.columns.get_loc(col)] = 1
+-                # 死叉：短期均线从上方穿越长期均线
+-                elif diff.iloc[i-1] > 0 and diff.iloc[i] < 0:
+-                    signals.iloc[i, signals.columns.get_loc(col)] = -1
+-    
+-    return signals
+-
+-
+-def calculate_returns(data, signals, initial_capital=100000):
+-    """
+-    计算策略收益
+-    
+-    Args:
+-        data: 价格数据
+-        signals: 信号数据
+-        initial_capital: 初始资金
+-    
+-    Returns:
+-        收益数据
+-    """
+-    # 计算日收益率
+-    returns = data.pct_change()
+-    
+-    # 策略收益（假设每次信号产生1%的收益）
+-    strategy_returns = signals * 0.01
+-    
+-    # 累计收益
+-    cumulative_returns = strategy_returns.sum(axis=1).cumsum()
+-    
+-    # 资金曲线
+-    capital_curve = initial_capital * (1 + cumulative_returns)
+-    
+-    return {
+-        'strategy_returns': strategy_returns,
+-        'cumulative_returns': cumulative_returns,
+-        'capital_curve': capital_curve
+-    }
+-
+-
+-def analyze_strategy(signals, returns_data):
+-    """
+-    分析策略表现
+-    
+-    Args:
+-        signals: 信号数据
+-        returns_data: 收益数据
+-    """
+-    print("=" * 50)
+-    print("均线交叉策略分析结果")
+-    print("=" * 50)
+-    
+-    # 信号统计
+-    buy_signals = (signals == 1).sum().sum()
+-    sell_signals = (signals == -1).sum().sum()
+-    
+-    print(f"买入信号数量: {buy_signals}")
+-    print(f"卖出信号数量: {sell_signals}")
+-    print(f"总信号数量: {buy_signals + sell_signals}")
+-    
+-    # 收益统计
+-    cumulative_returns = returns_data['cumulative_returns']
+-    capital_curve = returns_data['capital_curve']
+-    
+-    total_return = cumulative_returns.iloc[-1]
+-    annual_return = total_return / (len(cumulative_returns) / 252)
+-    
+-    print(f"\n收益统计:")
+-    print(f"总收益率: {total_return:.2%}")
+-    print(f"年化收益率: {annual_return:.2%}")
+-    print(f"最终资金: {capital_curve.iloc[-1]:,.0f}")
+-    
+-    # 风险统计
+-    daily_returns = returns_data['strategy_returns'].sum(axis=1)
+-    volatility = daily_returns.std() * np.sqrt(252)
+-    sharpe_ratio = annual_return / volatility if volatility > 0 else 0
+-    
+-    print(f"\n风险统计:")
+-    print(f"年化波动率: {volatility:.2%}")
+-    print(f"夏普比率: {sharpe_ratio:.2f}")
+-    print(f"胜率: {(daily_returns > 0).mean():.2%}")
+-
+-
+-def plot_results(data, signals, returns_data, stock_code):
+-    """
+-    绘制结果图表
+-    
+-    Args:
+-        data: 价格数据
+-        signals: 信号数据
+-        returns_data: 收益数据
+-        stock_code: 股票代码
+-    """
+-    fig, axes = plt.subplots(3, 1, figsize=(12, 10))
+-    
+-    # 绘制价格和均线
+-    axes[0].plot(data.index, data[stock_code], label='收盘价', alpha=0.7)
+-    short_ma = data[stock_code].rolling(window=5).mean()
+-    long_ma = data[stock_code].rolling(window=20).mean()
+-    axes[0].plot(data.index, short_ma, label='5日均线', alpha=0.8)
+-    axes[0].plot(data.index, long_ma, label='20日均线', alpha=0.8)
+-    
+-    # 标记买卖信号
+-    buy_signals = signals[stock_code] == 1
+-    sell_signals = signals[stock_code] == -1
+-    
+-    axes[0].scatter(data.index[buy_signals], data.loc[buy_signals, stock_code], 
+-                   color='red', marker='^', s=100, label='买入信号', alpha=0.8)
+-    axes[0].scatter(data.index[sell_signals], data.loc[sell_signals, stock_code], 
+-                   color='green', marker='v', s=100, label='卖出信号', alpha=0.8)
+-    
+-    axes[0].set_title(f'{stock_code} 价格走势与均线交叉信号')
+-    axes[0].legend()
+-    axes[0].grid(True, alpha=0.3)
+-    
+-    # 绘制累计收益
+-    axes[1].plot(returns_data['cumulative_returns'].index, 
+-                returns_data['cumulative_returns'].values, 
+-                label='累计收益', color='blue')
+-    axes[1].set_title('策略累计收益')
+-    axes[1].legend()
+-    axes[1].grid(True, alpha=0.3)
+-    
+-    # 绘制资金曲线
+-    axes[2].plot(returns_data['capital_curve'].index, 
+-                returns_data['capital_curve'].values, 
+-                label='资金曲线', color='green')
+-    axes[2].set_title('资金曲线')
+-    axes[2].legend()
+-    axes[2].grid(True, alpha=0.3)
+-    
+-    plt.tight_layout()
+-    plt.savefig('ma_cross_strategy_results.png', dpi=300, bbox_inches='tight')
+-    plt.show()
+-
+-
+-def main():
+-    """
+-    主函数
+-    """
+-    print("开始运行均线交叉策略...")
+-    
+-    # 初始化qlib
+-    if not init_qlib():
+-        return
+-    
+-    # 策略参数
+-    start_date = "2020-01-01"
+-    end_date = "2023-12-31"
+-    short_window = 5
+-    long_window = 20
+-    initial_capital = 100000
+-    
+-    # 获取股票列表
+-    try:
+-        instruments = D.list_instruments(instruments="csi300", start_time=start_date, end_time=end_date)
+-        print(f"获取到 {len(instruments)} 只股票")
+-        
+-        # 选择前5只股票进行演示
+-        demo_instruments = instruments[:5]
+-        print(f"选择演示股票: {demo_instruments}")
+-        
+-    except Exception as e:
+-        print(f"获取股票列表失败: {e}")
+-        # 使用默认股票列表
+-        demo_instruments = ['000001.SZ', '000002.SZ', '000858.SZ', '002415.SZ', '600036.SH']
+-        print(f"使用默认股票列表: {demo_instruments}")
+-    
+-    # 获取价格数据
+-    data = get_stock_data(demo_instruments, start_date, end_date)
+-    
+-    if data is None:
+-        print("无法获取数据，程序退出")
+-        return
+-    
+-    print(f"获取到价格数据，形状: {data.shape}")
+-    
+-    # 计算均线信号
+-    signals = calculate_ma_signals(data, short_window, long_window)
+-    
+-    # 计算收益
+-    returns_data = calculate_returns(data, signals, initial_capital)
+-    
+-    # 分析策略
+-    analyze_strategy(signals, returns_data)
+-    
+-    # 保存结果
+-    signals.to_csv("ma_cross_signals.csv")
+-    returns_data['cumulative_returns'].to_csv("ma_cross_cumulative_returns.csv")
+-    returns_data['capital_curve'].to_csv("ma_cross_capital_curve.csv")
+-    
+-    print("\n结果已保存到CSV文件:")
+-    print("- ma_cross_signals.csv: 买卖信号")
+-    print("- ma_cross_cumulative_returns.csv: 累计收益")
+-    print("- ma_cross_capital_curve.csv: 资金曲线")
+-    
+-    # 绘制图表（选择第一只股票）
+-    if len(demo_instruments) > 0:
+-        try:
+-            plot_results(data, signals, returns_data, demo_instruments[0])
+-            print("图表已保存为 ma_cross_strategy_results.png")
+-        except Exception as e:
+-            print(f"绘制图表失败: {e}")
+-    
+-    print("\n策略回测完成！")
+-
+-
+-if __name__ == "__main__":
+-    main() 
+\ No newline at end of file
+diff --git a/test/two_ema_stragety.py b/test/two_ema_stragety.py
+index a72e7e8..a9890c7 100644
+--- a/test/two_ema_stragety.py
++++ b/test/two_ema_stragety.py
+@@ -1,2 +1,98 @@
+-from qlib.contrib.strategy import 
+-from qlib.backtest import backtest
+\ No newline at end of file
++import pandas as pd
++
++from abc import ABC
++from typing import Dict, List, Text, Tuple, Union
++from qlib.data.dataset import Dataset
++from qlib.model.base import BaseModel
++from qlib.backtest.signal import Signal, create_signal_from
++from qlib.strategy.base import BaseStrategy
++from qlib.backtest.decision import Order, OrderDir, OrderHelper, TradeDecisionWO
++# from qlib.strategy import 
++# from qlib.backtest import backtest
++
++class InnerStrategy(BaseStrategy):
++    """
++    Inner strategy for order execution:
++    - Buy: if price < 200, buy all cash; else buy 200,000 worth.
++    - Sell: if price > 200, sell all; else sell half.
++    """
++    STOCK_CODE = "000858.SZ"
++
++    def generate_trade_decision(self, execute_result: list = None, action: str = None, amount: float = None):
++        # action: 'buy' or 'sell', amount: suggested amount (shares) from outer
++        position = self.trade_position
++        trade_step = self.trade_calendar.get_trade_step()
++        trade_start_time, trade_end_time = self.trade_calendar.get_step_time(trade_step)
++        order_helper = self.trade_exchange.get_order_helper()
++        orders = []
++        price = self.trade_exchange.get_deal_price(self.STOCK_CODE, trade_start_time, trade_end_time)
++        if action == 'buy':
++            cash = position.get_cash()
++            if price <= 0:
++                return TradeDecisionWO([], self)
++            if price < 200:
++                buy_amount = cash // price
++            else:
++                buy_amount = min(cash // price, 200000 // price)
++            buy_amount = int(buy_amount)
++            if buy_amount > 0:
++                order = order_helper.create(
++                    code=self.STOCK_CODE,
++                    amount=buy_amount,
++                    direction=OrderDir.BUY,
++                    start_time=trade_start_time,
++                    end_time=trade_end_time,
++                )
++                orders.append(order)
++        elif action == 'sell':
++            held_amount = position.get_stock_amount(self.STOCK_CODE)
++            if held_amount <= 0 or price <= 0:
++                return TradeDecisionWO([], self)
++            if price > 200:
++                sell_amount = held_amount
++            else:
++                sell_amount = held_amount // 2
++            sell_amount = int(sell_amount)
++            if sell_amount > 0:
++                order = order_helper.create(
++                    code=self.STOCK_CODE,
++                    amount=sell_amount,
++                    direction=OrderDir.SELL,
++                    start_time=trade_start_time,
++                    end_time=trade_end_time,
++                )
++                orders.append(order)
++        return TradeDecisionWO(orders, self)
++
++class OuterStrategy(BaseStrategy):
++    """
++    Outer strategy:
++    - If not holding Wuliangye, issues a buy order via inner strategy.
++    - If holding, checks if held for 25 days, if so, issues a sell order via inner strategy.
++    - Otherwise, holds.
++    """
++    STOCK_CODE = "000858.SZ"
++    HOLD_DAYS = 25
++    BAR = "day"
++
++    def __init__(self, *args, **kwargs):
++        super().__init__(*args, **kwargs)
++        self.inner_strategy = InnerStrategy()
++
++    def generate_trade_decision(self, execute_result: list = None):
++        position = self.trade_position
++        stock_list = position.get_stock_list()
++        trade_step = self.trade_calendar.get_trade_step()
++        trade_start_time, trade_end_time = self.trade_calendar.get_step_time(trade_step)
++        # Pass infra to inner strategy
++        self.inner_strategy.reset(level_infra=self.level_infra, common_infra=self.common_infra)
++        if self.STOCK_CODE in stock_list:
++            hold_days = position.get_stock_count(self.STOCK_CODE, self.BAR)
++            if hold_days >= self.HOLD_DAYS:
++                # Sell via inner strategy
++                return self.inner_strategy.generate_trade_decision(action='sell')
++        else:
++            # Buy via inner strategy
++            return self.inner_strategy.generate_trade_decision(action='buy')
++        # Otherwise, hold
++        return TradeDecisionWO([], self)
+\ No newline at end of file
diff --git a/mlruns/812028854715931404/8921d110545647f39692283e29142411/artifacts/code_status.txt b/mlruns/812028854715931404/8921d110545647f39692283e29142411/artifacts/code_status.txt
new file mode 100644
index 0000000..d9b6458
--- /dev/null
+++ b/mlruns/812028854715931404/8921d110545647f39692283e29142411/artifacts/code_status.txt
@@ -0,0 +1,25 @@
+On branch main
+Your branch is up to date with 'origin/main'.
+
+Changes not staged for commit:
+  (use "git add/rm <file>..." to update what will be committed)
+  (use "git restore <file>..." to discard changes in working directory)
+	modified:   github/examples/benchmarks/LightGBM/workflow_config_lightgbm_Alpha1582.yaml
+	deleted:    test/README_MA_Strategy.md
+	modified:   test/damo1.py
+	modified:   test/demo2.ipynb
+	deleted:    test/ma_cross_strategy.py
+	deleted:    test/ma_cross_strategy_improved.py
+	deleted:    test/ma_strategy_demo.py
+	deleted:    test/simple_ma_strategy.py
+	modified:   test/two_ema_stragety.py
+
+Untracked files:
+  (use "git add <file>..." to include in what will be committed)
+	github/examples/mlruns/881301994755452456/157579a2201241aaafcff94e93d7da0e/
+	mlruns/
+	test/__pycache__/
+	test/buy_and_hold.py
+	test/workflow_by_code.py
+
+no changes added to commit (use "git add" and/or "git commit -a")
diff --git a/mlruns/812028854715931404/8921d110545647f39692283e29142411/meta.yaml b/mlruns/812028854715931404/8921d110545647f39692283e29142411/meta.yaml
new file mode 100644
index 0000000..b43acd9
--- /dev/null
+++ b/mlruns/812028854715931404/8921d110545647f39692283e29142411/meta.yaml
@@ -0,0 +1,14 @@
+artifact_uri: file:D:\project\python\tradenote\mlruns/812028854715931404/8921d110545647f39692283e29142411/artifacts
+end_time: 1750319300797
+entry_point_name: ''
+experiment_id: '812028854715931404'
+lifecycle_stage: active
+run_id: 8921d110545647f39692283e29142411
+run_name: mlflow_recorder
+source_name: ''
+source_type: 4
+source_version: ''
+start_time: 1750319300563
+status: 3
+tags: []
+user_id: abulimity
diff --git a/mlruns/812028854715931404/8921d110545647f39692283e29142411/params/cmd-sys.argv b/mlruns/812028854715931404/8921d110545647f39692283e29142411/params/cmd-sys.argv
new file mode 100644
index 0000000..db800eb
--- /dev/null
+++ b/mlruns/812028854715931404/8921d110545647f39692283e29142411/params/cmd-sys.argv
@@ -0,0 +1 @@
+D:\project\python\tradenote\test\workflow_by_code.py
\ No newline at end of file
diff --git a/mlruns/812028854715931404/8921d110545647f39692283e29142411/tags/mlflow.runName b/mlruns/812028854715931404/8921d110545647f39692283e29142411/tags/mlflow.runName
new file mode 100644
index 0000000..25487e4
--- /dev/null
+++ b/mlruns/812028854715931404/8921d110545647f39692283e29142411/tags/mlflow.runName
@@ -0,0 +1 @@
+mlflow_recorder
\ No newline at end of file
diff --git a/mlruns/812028854715931404/8921d110545647f39692283e29142411/tags/mlflow.source.git.commit b/mlruns/812028854715931404/8921d110545647f39692283e29142411/tags/mlflow.source.git.commit
new file mode 100644
index 0000000..288ce21
--- /dev/null
+++ b/mlruns/812028854715931404/8921d110545647f39692283e29142411/tags/mlflow.source.git.commit
@@ -0,0 +1 @@
+0daea9b5bbb40120a1bc07c702d171abc1f219c7
\ No newline at end of file
diff --git a/mlruns/812028854715931404/8921d110545647f39692283e29142411/tags/mlflow.source.name b/mlruns/812028854715931404/8921d110545647f39692283e29142411/tags/mlflow.source.name
new file mode 100644
index 0000000..db800eb
--- /dev/null
+++ b/mlruns/812028854715931404/8921d110545647f39692283e29142411/tags/mlflow.source.name
@@ -0,0 +1 @@
+D:\project\python\tradenote\test\workflow_by_code.py
\ No newline at end of file
diff --git a/mlruns/812028854715931404/8921d110545647f39692283e29142411/tags/mlflow.source.type b/mlruns/812028854715931404/8921d110545647f39692283e29142411/tags/mlflow.source.type
new file mode 100644
index 0000000..0c2c1fe
--- /dev/null
+++ b/mlruns/812028854715931404/8921d110545647f39692283e29142411/tags/mlflow.source.type
@@ -0,0 +1 @@
+LOCAL
\ No newline at end of file
diff --git a/mlruns/812028854715931404/8921d110545647f39692283e29142411/tags/mlflow.user b/mlruns/812028854715931404/8921d110545647f39692283e29142411/tags/mlflow.user
new file mode 100644
index 0000000..b9cec6f
--- /dev/null
+++ b/mlruns/812028854715931404/8921d110545647f39692283e29142411/tags/mlflow.user
@@ -0,0 +1 @@
+abulimity
\ No newline at end of file
diff --git a/mlruns/812028854715931404/a51ce1b415cd4346ade25311d72affed/artifacts/code_cached.txt b/mlruns/812028854715931404/a51ce1b415cd4346ade25311d72affed/artifacts/code_cached.txt
new file mode 100644
index 0000000..e69de29
diff --git a/mlruns/812028854715931404/a51ce1b415cd4346ade25311d72affed/artifacts/code_diff.txt b/mlruns/812028854715931404/a51ce1b415cd4346ade25311d72affed/artifacts/code_diff.txt
new file mode 100644
index 0000000..928524e
--- /dev/null
+++ b/mlruns/812028854715931404/a51ce1b415cd4346ade25311d72affed/artifacts/code_diff.txt
@@ -0,0 +1,1638 @@
+diff --git a/github/examples/benchmarks/LightGBM/workflow_config_lightgbm_Alpha1582.yaml b/github/examples/benchmarks/LightGBM/workflow_config_lightgbm_Alpha1582.yaml
+index 8b4e7bf..7a5eee7 100644
+--- a/github/examples/benchmarks/LightGBM/workflow_config_lightgbm_Alpha1582.yaml
++++ b/github/examples/benchmarks/LightGBM/workflow_config_lightgbm_Alpha1582.yaml
+@@ -1,5 +1,5 @@
+ qlib_init:
+-    provider_uri: "D:/project/tradenote/qlib_data/cn_data"
++    provider_uri: "D:/sync/qlib/qlib_data/cn_data"
+     region: cn
+ market: &market csi300
+ benchmark: &benchmark SH000300
+diff --git a/test/README_MA_Strategy.md b/test/README_MA_Strategy.md
+deleted file mode 100644
+index 5facaf7..0000000
+--- a/test/README_MA_Strategy.md
++++ /dev/null
+@@ -1,197 +0,0 @@
+-# 均线交叉策略 (Moving Average Crossover Strategy)
+-
+-## 策略概述
+-
+-这是一个基于qlib框架实现的均线交叉策略，核心逻辑是：
+-- **金叉买入**：短期均线上穿长期均线时买入
+-- **死叉卖出**：短期均线下穿长期均线时卖出
+-
+-## 文件说明
+-
+-### 1. `ma_cross_strategy.py`
+-完整的策略实现，包含：
+-- `MACrossStrategy` 类：继承自qlib的TopkDropoutStrategy
+-- 完整的回测框架
+-- 结果分析和保存
+-
+-### 2. `ma_cross_strategy_improved.py`
+-改进版本，包含：
+-- 更完善的数据获取逻辑
+-- 错误处理机制
+-- 简化版回测功能
+-
+-### 3. `simple_ma_strategy.py` ⭐ **推荐使用**
+-简单实用的版本，包含：
+-- 清晰的数据获取和处理
+-- 均线信号计算
+-- 收益计算和分析
+-- 可视化图表生成
+-- 结果保存功能
+-
+-## 使用方法
+-
+-### 环境准备
+-
+-1. 确保已安装qlib：
+-```bash
+-pip install pyqlib
+-```
+-
+-2. 下载qlib数据（如果还没有）：
+-```bash
+-# 下载中国股票数据
+-python -m qlib.data.dump_bin --csv_path ~/.qlib/qlib_data/cn_data --include_fields close,open,high,low,volume
+-```
+-
+-### 运行策略
+-
+-#### 方法1：运行简单版本（推荐）
+-```bash
+-cd test
+-python simple_ma_strategy.py
+-```
+-
+-#### 方法2：运行完整版本
+-```bash
+-cd test
+-python ma_cross_strategy.py
+-```
+-
+-#### 方法3：运行改进版本
+-```bash
+-cd test
+-python ma_cross_strategy_improved.py
+-```
+-
+-## 策略参数
+-
+-可以在代码中修改以下参数：
+-
+-```python
+-# 均线周期
+-short_window = 5    # 短期均线周期
+-long_window = 20    # 长期均线周期
+-
+-# 回测时间
+-start_date = "2020-01-01"
+-end_date = "2023-12-31"
+-
+-# 初始资金
+-initial_capital = 100000
+-
+-# 股票池
+-instruments = "csi300"  # 沪深300成分股
+-```
+-
+-## 输出结果
+-
+-运行策略后会生成以下文件：
+-
+-1. **CSV文件**：
+-   - `ma_cross_signals.csv`：买卖信号数据
+-   - `ma_cross_cumulative_returns.csv`：累计收益数据
+-   - `ma_cross_capital_curve.csv`：资金曲线数据
+-
+-2. **图表文件**：
+-   - `ma_cross_strategy_results.png`：策略结果可视化图表
+-
+-3. **控制台输出**：
+-   - 策略分析结果
+-   - 收益统计
+-   - 风险指标
+-
+-## 策略分析指标
+-
+-### 收益指标
+-- 总收益率
+-- 年化收益率
+-- 最终资金
+-
+-### 风险指标
+-- 年化波动率
+-- 夏普比率
+-- 胜率
+-- 最大回撤
+-
+-### 交易统计
+-- 买入信号数量
+-- 卖出信号数量
+-- 总交易次数
+-
+-## 策略逻辑详解
+-
+-### 1. 均线计算
+-```python
+-# 计算短期和长期均线
+-short_ma = price_data.rolling(window=short_window).mean()
+-long_ma = price_data.rolling(window=long_window).mean()
+-```
+-
+-### 2. 交叉信号判断
+-```python
+-# 计算均线差值
+-diff = short_ma - long_ma
+-
+-# 金叉：短期均线从下方穿越长期均线
+-if diff.iloc[i-1] < 0 and diff.iloc[i] > 0:
+-    signal = 1  # 买入信号
+-
+-# 死叉：短期均线从上方穿越长期均线
+-elif diff.iloc[i-1] > 0 and diff.iloc[i] < 0:
+-    signal = -1  # 卖出信号
+-```
+-
+-### 3. 收益计算
+-```python
+-# 策略收益（简化处理）
+-strategy_returns = signals * 0.01
+-
+-# 累计收益
+-cumulative_returns = strategy_returns.sum(axis=1).cumsum()
+-```
+-
+-## 注意事项
+-
+-1. **数据依赖**：确保qlib数据已正确下载和配置
+-2. **参数调优**：可以根据不同市场环境调整均线周期
+-3. **风险控制**：实际交易中需要加入止损和仓位管理
+-4. **交易成本**：当前版本未考虑交易费用，实际应用需要考虑
+-
+-## 扩展功能
+-
+-可以基于此策略进行以下扩展：
+-
+-1. **多均线策略**：使用多条均线进行更复杂的信号判断
+-2. **量价配合**：结合成交量指标优化信号
+-3. **止损机制**：添加动态止损策略
+-4. **仓位管理**：根据信号强度调整仓位大小
+-5. **多股票组合**：构建股票组合分散风险
+-
+-## 常见问题
+-
+-### Q: 如何修改股票池？
+-A: 在代码中修改 `instruments` 参数，例如：
+-```python
+-instruments = "csi500"  # 中证500
+-instruments = ["000001.SZ", "000002.SZ"]  # 指定股票列表
+-```
+-
+-### Q: 如何调整均线周期？
+-A: 修改 `short_window` 和 `long_window` 参数：
+-```python
+-short_window = 10  # 10日均线
+-long_window = 30   # 30日均线
+-```
+-
+-### Q: 如何查看详细的交易记录？
+-A: 查看生成的 `ma_cross_signals.csv` 文件，其中包含每日的买卖信号。
+-
+-## 联系方式
+-
+-如有问题或建议，请通过以下方式联系：
+-- 提交Issue到项目仓库
+-- 发送邮件到项目维护者
+-
+----
+-
+-**免责声明**：本策略仅供学习和研究使用，不构成投资建议。实际投资请谨慎决策，并承担相应风险。 
+\ No newline at end of file
+diff --git a/test/damo1.py b/test/damo1.py
+index 03102e1..afa2886 100644
+--- a/test/damo1.py
++++ b/test/damo1.py
+@@ -1,9 +1,35 @@
+-# python scripts/get_data.py qlib_data --target_dir ../qlib_data/cn_data --region cn
+-
+ import qlib
+-# region in [REG_CN, REG_US]
+-from qlib.constant import REG_CN
+-provider_uri = "D:/project/tradenote/qlib_data/cn_data"  # target_dir
+-qlib.init(provider_uri=provider_uri, region=REG_CN)
++from qlib.data import D
++
++# 初始化 Qlib
++qlib.init(provider_uri="D:/sync/qlib/qlib_data/cn_data", region="cn")
++
++# 检查目标股票和基准
++stock_code = "SZ000858"  # 你的BuyHold策略用的股票代码
++benchmark = "SH000300"
++
++print("--- 检查可用股票列表（前10只） ---")
++print(list(D.instruments(market="all"))[:10])
++
++print("--- 检查交易日（2017-01-01 ~ 2020-08-01，前10天） ---")
++print(D.calendar(start_time="2017-01-01", end_time="2020-08-01")[:10])
++
++print(f"--- 检查目标股票 {stock_code} 是否在股票池 ---")
++print(stock_code in D.instruments(market="all"))
++
++print(f"--- 检查基准 {benchmark} 是否在股票池 ---")
++print(benchmark in D.instruments(market="all"))
++
++print(f"--- 检查目标股票 {stock_code} 的行情数据（前5行） ---")
++try:
++    df = D.features([stock_code], ["$close", "$open", "$high", "$low", "$volume"], start_time="2017-01-01", end_time="2020-08-01")
++    print(df.head())
++except Exception as e:
++    print(f"获取行情数据失败: {e}")
+ 
+-# qrun benchmarks/LightGBM/workflow_config_lightgbm_Alpha1582.yaml
++print(f"--- 检查基准 {benchmark} 的行情数据（前5行） ---")
++try:
++    df_bench = D.features([benchmark], ["$close"], start_time="2017-01-01", end_time="2020-08-01")
++    print(df_bench.head())
++except Exception as e:
++    print(f"获取基准行情数据失败: {e}")
+diff --git a/test/demo2.ipynb b/test/demo2.ipynb
+index 66a0215..842a49e 100644
+--- a/test/demo2.ipynb
++++ b/test/demo2.ipynb
+@@ -2,7 +2,7 @@
+  "cells": [
+   {
+    "cell_type": "code",
+-   "execution_count": 4,
++   "execution_count": 12,
+    "id": "6acb4a77",
+    "metadata": {},
+    "outputs": [
+@@ -10,39 +10,205 @@
+      "name": "stderr",
+      "output_type": "stream",
+      "text": [
+-      "[5344:MainThread](2025-06-18 14:41:03,895) INFO - qlib.Initialization - [config.py:420] - default_conf: client.\n",
+-      "[5344:MainThread](2025-06-18 14:41:03,900) INFO - qlib.Initialization - [__init__.py:74] - qlib successfully initialized based on client settings.\n",
+-      "[5344:MainThread](2025-06-18 14:41:03,903) INFO - qlib.Initialization - [__init__.py:76] - data_path={'__DEFAULT_FREQ': WindowsPath('D:/sync/qlib/qlib_data/cn_data')}\n"
++      "[13736:MainThread](2025-06-19 15:30:19,504) INFO - qlib.Initialization - [config.py:420] - default_conf: client.\n",
++      "[13736:MainThread](2025-06-19 15:30:19,506) INFO - qlib.Initialization - [__init__.py:74] - qlib successfully initialized based on client settings.\n",
++      "[13736:MainThread](2025-06-19 15:30:19,508) INFO - qlib.Initialization - [__init__.py:76] - data_path={'__DEFAULT_FREQ': WindowsPath('D:/sync/qlib/qlib_data/cn_data')}\n"
+      ]
+     }
+    ],
+    "source": [
+     "import qlib\n",
+-    "qlib.init(provider_uri=\"D:/sync/qlib/qlib_data/cn_data\", region=\"cn\")"
++    "qlib.init(provider_uri=r\"D:\\sync\\qlib\\qlib_data\\cn_data\", region=\"cn\")"
+    ]
+   },
+   {
+    "cell_type": "code",
+-   "execution_count": 12,
++   "execution_count": 14,
+    "id": "295df9af",
+    "metadata": {},
+    "outputs": [
+     {
+      "data": {
+       "text/plain": [
+-       "array([Timestamp('2020-09-21 00:00:00'), Timestamp('2020-09-22 00:00:00'),\n",
+-       "       Timestamp('2020-09-23 00:00:00'), Timestamp('2020-09-24 00:00:00'),\n",
+-       "       Timestamp('2020-09-25 00:00:00')], dtype=object)"
++       "array([Timestamp('2017-01-03 00:00:00'), Timestamp('2017-01-04 00:00:00'),\n",
++       "       Timestamp('2017-01-05 00:00:00'), Timestamp('2017-01-06 00:00:00'),\n",
++       "       Timestamp('2017-01-09 00:00:00')], dtype=object)"
+       ]
+      },
+-     "execution_count": 12,
++     "execution_count": 14,
+      "metadata": {},
+      "output_type": "execute_result"
+     }
+    ],
+    "source": [
+     "from qlib.data import D\n",
+-    "D.calendar(start_time='2020-09-21', end_time='2020-10-30', freq='day')"
++    "D.calendar(start_time=\"2017-01-01\", end_time=\"2020-08-01\",freq=\"day\")[:5]"
++   ]
++  },
++  {
++   "cell_type": "code",
++   "execution_count": 24,
++   "id": "da009afa",
++   "metadata": {},
++   "outputs": [
++    {
++     "data": {
++      "text/html": [
++       "<div>\n",
++       "<style scoped>\n",
++       "    .dataframe tbody tr th:only-of-type {\n",
++       "        vertical-align: middle;\n",
++       "    }\n",
++       "\n",
++       "    .dataframe tbody tr th {\n",
++       "        vertical-align: top;\n",
++       "    }\n",
++       "\n",
++       "    .dataframe thead th {\n",
++       "        text-align: right;\n",
++       "    }\n",
++       "</style>\n",
++       "<table border=\"1\" class=\"dataframe\">\n",
++       "  <thead>\n",
++       "    <tr style=\"text-align: right;\">\n",
++       "      <th></th>\n",
++       "      <th></th>\n",
++       "      <th>$close</th>\n",
++       "      <th>$open</th>\n",
++       "      <th>$high</th>\n",
++       "      <th>$low</th>\n",
++       "      <th>$volume</th>\n",
++       "    </tr>\n",
++       "    <tr>\n",
++       "      <th>instrument</th>\n",
++       "      <th>datetime</th>\n",
++       "      <th></th>\n",
++       "      <th></th>\n",
++       "      <th></th>\n",
++       "      <th></th>\n",
++       "      <th></th>\n",
++       "    </tr>\n",
++       "  </thead>\n",
++       "  <tbody>\n",
++       "    <tr>\n",
++       "      <th rowspan=\"11\" valign=\"top\">SZ000858</th>\n",
++       "      <th>2017-01-03</th>\n",
++       "      <td>11.301954</td>\n",
++       "      <td>11.243259</td>\n",
++       "      <td>11.373693</td>\n",
++       "      <td>11.184565</td>\n",
++       "      <td>47640796.0</td>\n",
++       "    </tr>\n",
++       "    <tr>\n",
++       "      <th>2017-01-04</th>\n",
++       "      <td>11.706295</td>\n",
++       "      <td>11.301954</td>\n",
++       "      <td>11.722599</td>\n",
++       "      <td>11.266086</td>\n",
++       "      <td>141233984.0</td>\n",
++       "    </tr>\n",
++       "    <tr>\n",
++       "      <th>2017-01-05</th>\n",
++       "      <td>11.716078</td>\n",
++       "      <td>11.748685</td>\n",
++       "      <td>11.817163</td>\n",
++       "      <td>11.641079</td>\n",
++       "      <td>79170360.0</td>\n",
++       "    </tr>\n",
++       "    <tr>\n",
++       "      <th>2017-01-06</th>\n",
++       "      <td>11.771510</td>\n",
++       "      <td>11.716077</td>\n",
++       "      <td>11.934550</td>\n",
++       "      <td>11.660643</td>\n",
++       "      <td>103201592.0</td>\n",
++       "    </tr>\n",
++       "    <tr>\n",
++       "      <th>2017-01-09</th>\n",
++       "      <td>11.885638</td>\n",
++       "      <td>11.738902</td>\n",
++       "      <td>11.999766</td>\n",
++       "      <td>11.716077</td>\n",
++       "      <td>81857808.0</td>\n",
++       "    </tr>\n",
++       "    <tr>\n",
++       "      <th>...</th>\n",
++       "      <td>...</td>\n",
++       "      <td>...</td>\n",
++       "      <td>...</td>\n",
++       "      <td>...</td>\n",
++       "      <td>...</td>\n",
++       "    </tr>\n",
++       "    <tr>\n",
++       "      <th>2020-07-27</th>\n",
++       "      <td>71.358727</td>\n",
++       "      <td>71.110489</td>\n",
++       "      <td>72.302719</td>\n",
++       "      <td>70.418228</td>\n",
++       "      <td>69948368.0</td>\n",
++       "    </tr>\n",
++       "    <tr>\n",
++       "      <th>2020-07-28</th>\n",
++       "      <td>74.816528</td>\n",
++       "      <td>71.984558</td>\n",
++       "      <td>75.847931</td>\n",
++       "      <td>71.558014</td>\n",
++       "      <td>108913296.0</td>\n",
++       "    </tr>\n",
++       "    <tr>\n",
++       "      <th>2020-07-29</th>\n",
++       "      <td>75.173149</td>\n",
++       "      <td>74.942398</td>\n",
++       "      <td>75.337471</td>\n",
++       "      <td>73.075386</td>\n",
++       "      <td>85012816.0</td>\n",
++       "    </tr>\n",
++       "    <tr>\n",
++       "      <th>2020-07-30</th>\n",
++       "      <td>75.704582</td>\n",
++       "      <td>74.820023</td>\n",
++       "      <td>76.236015</td>\n",
++       "      <td>74.470398</td>\n",
++       "      <td>71618128.0</td>\n",
++       "    </tr>\n",
++       "    <tr>\n",
++       "      <th>2020-07-31</th>\n",
++       "      <td>76.054207</td>\n",
++       "      <td>75.697586</td>\n",
++       "      <td>77.270905</td>\n",
++       "      <td>74.917923</td>\n",
++       "      <td>74252152.0</td>\n",
++       "    </tr>\n",
++       "  </tbody>\n",
++       "</table>\n",
++       "<p>871 rows × 5 columns</p>\n",
++       "</div>"
++      ],
++      "text/plain": [
++       "                          $close      $open      $high       $low      $volume\n",
++       "instrument datetime                                                           \n",
++       "SZ000858   2017-01-03  11.301954  11.243259  11.373693  11.184565   47640796.0\n",
++       "           2017-01-04  11.706295  11.301954  11.722599  11.266086  141233984.0\n",
++       "           2017-01-05  11.716078  11.748685  11.817163  11.641079   79170360.0\n",
++       "           2017-01-06  11.771510  11.716077  11.934550  11.660643  103201592.0\n",
++       "           2017-01-09  11.885638  11.738902  11.999766  11.716077   81857808.0\n",
++       "...                          ...        ...        ...        ...          ...\n",
++       "           2020-07-27  71.358727  71.110489  72.302719  70.418228   69948368.0\n",
++       "           2020-07-28  74.816528  71.984558  75.847931  71.558014  108913296.0\n",
++       "           2020-07-29  75.173149  74.942398  75.337471  73.075386   85012816.0\n",
++       "           2020-07-30  75.704582  74.820023  76.236015  74.470398   71618128.0\n",
++       "           2020-07-31  76.054207  75.697586  77.270905  74.917923   74252152.0\n",
++       "\n",
++       "[871 rows x 5 columns]"
++      ]
++     },
++     "execution_count": 24,
++     "metadata": {},
++     "output_type": "execute_result"
++    }
++   ],
++   "source": [
++    "D.features([\"SZ000858\"], [\"$close\", \"$open\", \"$high\", \"$low\", \"$volume\"], start_time=\"2017-01-01\", end_time=\"2020-08-01\")"
+    ]
+   }
+  ],
+diff --git a/test/ma_cross_strategy.py b/test/ma_cross_strategy.py
+deleted file mode 100644
+index 719d849..0000000
+--- a/test/ma_cross_strategy.py
++++ /dev/null
+@@ -1,274 +0,0 @@
+-"""
+-均线交叉策略：金叉买入，死叉卖出
+-使用qlib框架实现
+-"""
+-
+-import qlib
+-from qlib.constant import REG_CN
+-from qlib.utils import init_instance_by_config
+-from qlib.workflow import R
+-from qlib.workflow.record_temp import SignalRecord, PortAnaRecord
+-from qlib.contrib.evaluate import backtest_daily
+-from qlib.contrib.strategy import TopkDropoutStrategy
+-import pandas as pd
+-import numpy as np
+-from typing import Dict, List, Tuple
+-
+-
+-class MACrossStrategy(TopkDropoutStrategy):
+-    """
+-    均线交叉策略
+-    金叉（短期均线上穿长期均线）买入
+-    死叉（短期均线下穿长期均线）卖出
+-    """
+-    
+-    def __init__(self, 
+-                 short_window: int = 5,
+-                 long_window: int = 20,
+-                 topk: int = 50,
+-                 n_drop: int = 5,
+-                 **kwargs):
+-        """
+-        初始化策略参数
+-        
+-        Args:
+-            short_window: 短期均线周期
+-            long_window: 长期均线周期
+-            topk: 选择前k只股票
+-            n_drop: 剔除前n只股票
+-        """
+-        super().__init__(topk=topk, n_drop=n_drop, **kwargs)
+-        self.short_window = short_window
+-        self.long_window = long_window
+-        
+-    def generate_trade_decision(self, score: pd.Series, trade_step: int) -> pd.Series:
+-        """
+-        生成交易决策
+-        
+-        Args:
+-            score: 股票评分
+-            trade_step: 交易步骤
+-            
+-        Returns:
+-            交易决策，1表示买入，-1表示卖出，0表示持有
+-        """
+-        # 获取当前持仓
+-        current_pos = self.get_current_position()
+-        
+-        # 计算均线信号
+-        signal = self._calculate_ma_signal(score.index.tolist(), trade_step)
+-        
+-        # 生成交易决策
+-        decision = pd.Series(0, index=score.index)
+-        
+-        # 金叉买入信号
+-        buy_signal = signal == 1
+-        decision[buy_signal] = 1
+-        
+-        # 死叉卖出信号
+-        sell_signal = signal == -1
+-        decision[sell_signal] = -1
+-        
+-        return decision
+-    
+-    def _calculate_ma_signal(self, instruments: List[str], trade_step: int) -> pd.Series:
+-        """
+-        计算均线交叉信号
+-        
+-        Args:
+-            instruments: 股票代码列表
+-            trade_step: 交易步骤
+-            
+-        Returns:
+-            信号序列：1表示金叉买入，-1表示死叉卖出，0表示无信号
+-        """
+-        # 获取历史数据
+-        data = self._get_historical_data(instruments, trade_step)
+-        
+-        signals = pd.Series(0, index=instruments)
+-        
+-        for instrument in instruments:
+-            if instrument in data.index:
+-                # 计算短期和长期均线
+-                short_ma = data.loc[instrument].rolling(window=self.short_window).mean()
+-                long_ma = data.loc[instrument].rolling(window=self.long_window).mean()
+-                
+-                # 计算交叉信号
+-                if len(short_ma) >= 2 and len(long_ma) >= 2:
+-                    # 当前和前一个时间点的均线差值
+-                    current_diff = short_ma.iloc[-1] - long_ma.iloc[-1]
+-                    prev_diff = short_ma.iloc[-2] - long_ma.iloc[-2]
+-                    
+-                    # 金叉：短期均线从下方穿越长期均线
+-                    if prev_diff < 0 and current_diff > 0:
+-                        signals[instrument] = 1
+-                    # 死叉：短期均线从上方穿越长期均线
+-                    elif prev_diff > 0 and current_diff < 0:
+-                        signals[instrument] = -1
+-        
+-        return signals
+-    
+-    def _get_historical_data(self, instruments: List[str], trade_step: int) -> pd.DataFrame:
+-        """
+-        获取历史价格数据
+-        
+-        Args:
+-            instruments: 股票代码列表
+-            trade_step: 交易步骤
+-            
+-        Returns:
+-            历史价格数据
+-        """
+-        # 这里简化处理，实际应该从qlib数据源获取
+-        # 在实际应用中，您需要使用qlib的数据接口
+-        try:
+-            # 获取最近的数据用于计算均线
+-            # 这里使用模拟数据，实际应该从qlib获取
+-            dates = pd.date_range(end=pd.Timestamp.now(), periods=50, freq='D')
+-            data = pd.DataFrame(
+-                np.random.randn(len(dates), len(instruments)) * 0.02 + 1.0,
+-                index=dates,
+-                columns=instruments
+-            )
+-            return data
+-        except Exception as e:
+-            print(f"获取历史数据失败: {e}")
+-            return pd.DataFrame()
+-
+-
+-def create_ma_cross_strategy_config():
+-    """
+-    创建均线交叉策略配置
+-    """
+-    strategy_config = {
+-        "class": "MACrossStrategy",
+-        "module_path": "test.ma_cross_strategy",
+-        "kwargs": {
+-            "short_window": 5,
+-            "long_window": 20,
+-            "topk": 50,
+-            "n_drop": 5,
+-        }
+-    }
+-    
+-    return strategy_config
+-
+-
+-def run_backtest():
+-    """
+-    运行回测
+-    """
+-    # 初始化qlib
+-    qlib.init(provider_uri='~/.qlib/qlib_data/cn_data', region=REG_CN)
+-    
+-    # 策略配置
+-    strategy_config = create_ma_cross_strategy_config()
+-    
+-    # 回测配置
+-    backtest_config = {
+-        "start_time": "2020-01-01",
+-        "end_time": "2023-12-31",
+-        "benchmark": "SH000300",  # 沪深300作为基准
+-        "account": 100000000,     # 初始资金1亿
+-        "exchange_kwargs": {
+-            "freq": "day",
+-            "limit_threshold": 0.095,
+-            "deal_price": "close",
+-            "open_cost": 0.0005,
+-            "close_cost": 0.0015,
+-            "min_cost": 5,
+-        }
+-    }
+-    
+-    # 创建策略实例
+-    strategy = init_instance_by_config(strategy_config)
+-    
+-    # 运行回测
+-    with R.start(experiment_name="ma_cross_strategy"):
+-        # 记录信号
+-        sr = SignalRecord(model=strategy, dataset=None, recorder=R.get_recorder())
+-        sr.generate()
+-        
+-        # 记录投资组合分析
+-        par = PortAnaRecord(recorder=R.get_recorder(), config=backtest_config, strategy=strategy)
+-        par.generate()
+-        
+-        # 获取回测结果
+-        report_normal, positions_normal = backtest_daily(
+-            account=backtest_config["account"],
+-            benchmark=backtest_config["benchmark"],
+-            start_time=backtest_config["start_time"],
+-            end_time=backtest_config["end_time"],
+-            strategy=strategy,
+-            exchange_kwargs=backtest_config["exchange_kwargs"]
+-        )
+-        
+-        return report_normal, positions_normal
+-
+-
+-def analyze_results(report: pd.DataFrame, positions: pd.DataFrame):
+-    """
+-    分析回测结果
+-    
+-    Args:
+-        report: 回测报告
+-        positions: 持仓信息
+-    """
+-    print("=" * 50)
+-    print("均线交叉策略回测结果")
+-    print("=" * 50)
+-    
+-    # 基本统计信息
+-    print(f"总收益率: {report['return'].sum():.2%}")
+-    print(f"年化收益率: {report['return'].mean() * 252:.2%}")
+-    print(f"最大回撤: {report['drawdown'].min():.2%}")
+-    print(f"夏普比率: {report['sharpe'].iloc[-1]:.2f}")
+-    print(f"胜率: {(report['return'] > 0).mean():.2%}")
+-    
+-    # 风险指标
+-    volatility = report['return'].std() * np.sqrt(252)
+-    print(f"年化波动率: {volatility:.2%}")
+-    
+-    # 最大回撤期间
+-    max_drawdown_idx = report['drawdown'].idxmin()
+-    print(f"最大回撤发生时间: {max_drawdown_idx}")
+-    
+-    # 收益分布
+-    print("\n收益分布统计:")
+-    print(f"平均日收益: {report['return'].mean():.2%}")
+-    print(f"收益标准差: {report['return'].std():.2%}")
+-    print(f"最小日收益: {report['return'].min():.2%}")
+-    print(f"最大日收益: {report['return'].max():.2%}")
+-    
+-    # 交易统计
+-    if 'trade_count' in report.columns:
+-        print(f"\n总交易次数: {report['trade_count'].sum()}")
+-        print(f"平均每日交易次数: {report['trade_count'].mean():.1f}")
+-
+-
+-def main():
+-    """
+-    主函数
+-    """
+-    print("开始运行均线交叉策略回测...")
+-    
+-    try:
+-        # 运行回测
+-        report, positions = run_backtest()
+-        
+-        # 分析结果
+-        analyze_results(report, positions)
+-        
+-        # 保存结果
+-        report.to_csv("ma_cross_strategy_report.csv")
+-        positions.to_csv("ma_cross_strategy_positions.csv")
+-        
+-        print("\n回测完成！结果已保存到CSV文件。")
+-        
+-    except Exception as e:
+-        print(f"回测过程中出现错误: {e}")
+-        print("请确保已正确安装qlib并下载了相应的数据。")
+-
+-
+-if __name__ == "__main__":
+-    main() 
+\ No newline at end of file
+diff --git a/test/ma_cross_strategy_improved.py b/test/ma_cross_strategy_improved.py
+deleted file mode 100644
+index d166c68..0000000
+--- a/test/ma_cross_strategy_improved.py
++++ /dev/null
+@@ -1,443 +0,0 @@
+-"""
+-改进的均线交叉策略：金叉买入，死叉卖出
+-使用qlib框架实现，包含完整的数据获取和信号计算
+-"""
+-
+-import qlib
+-from qlib.constant import REG_CN
+-from qlib.utils import init_instance_by_config
+-from qlib.workflow import R
+-from qlib.workflow.record_temp import SignalRecord, PortAnaRecord
+-from qlib.contrib.evaluate import backtest_daily
+-from qlib.contrib.strategy import TopkDropoutStrategy
+-from qlib.data import D
+-from qlib.data.dataset import DatasetH
+-from qlib.data.dataset.handler import DataHandlerLP
+-import pandas as pd
+-import numpy as np
+-from typing import Dict, List, Tuple
+-import warnings
+-warnings.filterwarnings('ignore')
+-
+-
+-class MACrossStrategyImproved(TopkDropoutStrategy):
+-    """
+-    改进的均线交叉策略
+-    金叉（短期均线上穿长期均线）买入
+-    死叉（短期均线下穿长期均线）卖出
+-    """
+-    
+-    def __init__(self, 
+-                 short_window: int = 5,
+-                 long_window: int = 20,
+-                 topk: int = 50,
+-                 n_drop: int = 5,
+-                 universe: str = "csi300",
+-                 **kwargs):
+-        """
+-        初始化策略参数
+-        
+-        Args:
+-            short_window: 短期均线周期
+-            long_window: 长期均线周期
+-            topk: 选择前k只股票
+-            n_drop: 剔除前n只股票
+-            universe: 股票池
+-        """
+-        super().__init__(topk=topk, n_drop=n_drop, **kwargs)
+-        self.short_window = short_window
+-        self.long_window = long_window
+-        self.universe = universe
+-        self.instruments = None
+-        self.price_cache = {}
+-        
+-    def generate_trade_decision(self, score: pd.Series, trade_step: int) -> pd.Series:
+-        """
+-        生成交易决策
+-        
+-        Args:
+-            score: 股票评分
+-            trade_step: 交易步骤
+-            
+-        Returns:
+-            交易决策，1表示买入，-1表示卖出，0表示持有
+-        """
+-        # 获取当前持仓
+-        current_pos = self.get_current_position()
+-        
+-        # 计算均线信号
+-        signal = self._calculate_ma_signal(score.index.tolist(), trade_step)
+-        
+-        # 生成交易决策
+-        decision = pd.Series(0, index=score.index)
+-        
+-        # 金叉买入信号
+-        buy_signal = signal == 1
+-        decision[buy_signal] = 1
+-        
+-        # 死叉卖出信号
+-        sell_signal = signal == -1
+-        decision[sell_signal] = -1
+-        
+-        return decision
+-    
+-    def _calculate_ma_signal(self, instruments: List[str], trade_step: int) -> pd.Series:
+-        """
+-        计算均线交叉信号
+-        
+-        Args:
+-            instruments: 股票代码列表
+-            trade_step: 交易步骤
+-            
+-        Returns:
+-            信号序列：1表示金叉买入，-1表示死叉卖出，0表示无信号
+-        """
+-        signals = pd.Series(0, index=instruments)
+-        
+-        # 获取当前日期
+-        current_date = self._get_current_date(trade_step)
+-        
+-        for instrument in instruments:
+-            try:
+-                # 获取历史价格数据
+-                price_data = self._get_price_data(instrument, current_date)
+-                
+-                if price_data is not None and len(price_data) >= self.long_window:
+-                    # 计算短期和长期均线
+-                    short_ma = price_data['close'].rolling(window=self.short_window).mean()
+-                    long_ma = price_data['close'].rolling(window=self.long_window).mean()
+-                    
+-                    # 计算交叉信号
+-                    if len(short_ma) >= 2 and len(long_ma) >= 2:
+-                        # 当前和前一个时间点的均线差值
+-                        current_diff = short_ma.iloc[-1] - long_ma.iloc[-1]
+-                        prev_diff = short_ma.iloc[-2] - long_ma.iloc[-2]
+-                        
+-                        # 金叉：短期均线从下方穿越长期均线
+-                        if prev_diff < 0 and current_diff > 0:
+-                            signals[instrument] = 1
+-                        # 死叉：短期均线从上方穿越长期均线
+-                        elif prev_diff > 0 and current_diff < 0:
+-                            signals[instrument] = -1
+-                            
+-            except Exception as e:
+-                print(f"计算{instrument}均线信号时出错: {e}")
+-                continue
+-        
+-        return signals
+-    
+-    def _get_price_data(self, instrument: str, current_date: str) -> pd.DataFrame:
+-        """
+-        获取股票价格数据
+-        
+-        Args:
+-            instrument: 股票代码
+-            current_date: 当前日期
+-            
+-        Returns:
+-            价格数据DataFrame
+-        """
+-        try:
+-            # 计算开始日期（获取足够的历史数据来计算均线）
+-            start_date = pd.Timestamp(current_date) - pd.Timedelta(days=self.long_window * 2)
+-            
+-            # 从qlib获取数据
+-            data = D.features(
+-                instruments=[instrument],
+-                start_time=start_date.strftime('%Y-%m-%d'),
+-                end_time=current_date,
+-                freq='day',
+-                fields=['$close', '$open', '$high', '$low', '$volume']
+-            )
+-            
+-            if data is not None and not data.empty:
+-                # 重命名列
+-                data.columns = ['close', 'open', 'high', 'low', 'volume']
+-                return data
+-            else:
+-                return None
+-                
+-        except Exception as e:
+-            print(f"获取{instrument}价格数据失败: {e}")
+-            return None
+-    
+-    def _get_current_date(self, trade_step: int) -> str:
+-        """
+-        根据交易步骤获取当前日期
+-        
+-        Args:
+-            trade_step: 交易步骤
+-            
+-        Returns:
+-            当前日期字符串
+-        """
+-        # 这里简化处理，实际应该从qlib的日历获取
+-        # 假设从2020-01-01开始，每个trade_step代表一天
+-        start_date = pd.Timestamp('2020-01-01')
+-        current_date = start_date + pd.Timedelta(days=trade_step)
+-        return current_date.strftime('%Y-%m-%d')
+-
+-
+-def create_dataset_config():
+-    """
+-    创建数据集配置
+-    """
+-    dataset_config = {
+-        "class": "DatasetH",
+-        "module_path": "qlib.data.dataset",
+-        "kwargs": {
+-            "handler": {
+-                "class": "DataHandlerLP",
+-                "module_path": "qlib.data.dataset.handler",
+-                "kwargs": {
+-                    "start_time": "2020-01-01",
+-                    "end_time": "2023-12-31",
+-                    "fit_start_time": "2020-01-01",
+-                    "fit_end_time": "2023-12-31",
+-                    "instruments": "csi300",
+-                    "infer_processors": [
+-                        {
+-                            "class": "RobustZScoreNorm",
+-                            "module_path": "qlib.data.dataset.processor",
+-                            "kwargs": {
+-                                "fields_group": "feature",
+-                                "clip_outlier": True,
+-                            },
+-                        },
+-                        {
+-                            "class": "Fillna",
+-                            "module_path": "qlib.data.dataset.processor",
+-                            "kwargs": {
+-                                "fields_group": "feature",
+-                            },
+-                        },
+-                    ],
+-                    "learn_processors": [
+-                        {
+-                            "class": "DropnaLabel",
+-                            "module_path": "qlib.data.dataset.processor",
+-                        },
+-                        {
+-                            "class": "CSRankNorm",
+-                            "module_path": "qlib.data.dataset.processor",
+-                            "kwargs": {
+-                                "fields_group": "label",
+-                            },
+-                        },
+-                    ],
+-                    "instruments": "csi300",
+-                },
+-            },
+-            "segments": {
+-                "train": ("2020-01-01", "2022-12-31"),
+-                "valid": ("2023-01-01", "2023-06-30"),
+-                "test": ("2023-07-01", "2023-12-31"),
+-            },
+-        },
+-    }
+-    
+-    return dataset_config
+-
+-
+-def create_ma_cross_strategy_config():
+-    """
+-    创建均线交叉策略配置
+-    """
+-    strategy_config = {
+-        "class": "MACrossStrategyImproved",
+-        "module_path": "test.ma_cross_strategy_improved",
+-        "kwargs": {
+-            "short_window": 5,
+-            "long_window": 20,
+-            "topk": 50,
+-            "n_drop": 5,
+-            "universe": "csi300",
+-        }
+-    }
+-    
+-    return strategy_config
+-
+-
+-def run_backtest():
+-    """
+-    运行回测
+-    """
+-    # 初始化qlib
+-    qlib.init(provider_uri='~/.qlib/qlib_data/cn_data', region=REG_CN)
+-    
+-    # 策略配置
+-    strategy_config = create_ma_cross_strategy_config()
+-    
+-    # 回测配置
+-    backtest_config = {
+-        "start_time": "2020-01-01",
+-        "end_time": "2023-12-31",
+-        "benchmark": "SH000300",  # 沪深300作为基准
+-        "account": 100000000,     # 初始资金1亿
+-        "exchange_kwargs": {
+-            "freq": "day",
+-            "limit_threshold": 0.095,
+-            "deal_price": "close",
+-            "open_cost": 0.0005,
+-            "close_cost": 0.0015,
+-            "min_cost": 5,
+-        }
+-    }
+-    
+-    # 创建策略实例
+-    strategy = init_instance_by_config(strategy_config)
+-    
+-    # 运行回测
+-    with R.start(experiment_name="ma_cross_strategy_improved"):
+-        # 记录信号
+-        sr = SignalRecord(model=strategy, dataset=None, recorder=R.get_recorder())
+-        sr.generate()
+-        
+-        # 记录投资组合分析
+-        par = PortAnaRecord(recorder=R.get_recorder(), config=backtest_config, strategy=strategy)
+-        par.generate()
+-        
+-        # 获取回测结果
+-        report_normal, positions_normal = backtest_daily(
+-            account=backtest_config["account"],
+-            benchmark=backtest_config["benchmark"],
+-            start_time=backtest_config["start_time"],
+-            end_time=backtest_config["end_time"],
+-            strategy=strategy,
+-            exchange_kwargs=backtest_config["exchange_kwargs"]
+-        )
+-        
+-        return report_normal, positions_normal
+-
+-
+-def analyze_results(report: pd.DataFrame, positions: pd.DataFrame):
+-    """
+-    分析回测结果
+-    
+-    Args:
+-        report: 回测报告
+-        positions: 持仓信息
+-    """
+-    print("=" * 50)
+-    print("均线交叉策略回测结果")
+-    print("=" * 50)
+-    
+-    # 基本统计信息
+-    print(f"总收益率: {report['return'].sum():.2%}")
+-    print(f"年化收益率: {report['return'].mean() * 252:.2%}")
+-    print(f"最大回撤: {report['drawdown'].min():.2%}")
+-    
+-    if 'sharpe' in report.columns:
+-        print(f"夏普比率: {report['sharpe'].iloc[-1]:.2f}")
+-    
+-    print(f"胜率: {(report['return'] > 0).mean():.2%}")
+-    
+-    # 风险指标
+-    volatility = report['return'].std() * np.sqrt(252)
+-    print(f"年化波动率: {volatility:.2%}")
+-    
+-    # 最大回撤期间
+-    max_drawdown_idx = report['drawdown'].idxmin()
+-    print(f"最大回撤发生时间: {max_drawdown_idx}")
+-    
+-    # 收益分布
+-    print("\n收益分布统计:")
+-    print(f"平均日收益: {report['return'].mean():.2%}")
+-    print(f"收益标准差: {report['return'].std():.2%}")
+-    print(f"最小日收益: {report['return'].min():.2%}")
+-    print(f"最大日收益: {report['return'].max():.2%}")
+-    
+-    # 交易统计
+-    if 'trade_count' in report.columns:
+-        print(f"\n总交易次数: {report['trade_count'].sum()}")
+-        print(f"平均每日交易次数: {report['trade_count'].mean():.1f}")
+-
+-
+-def create_simple_backtest():
+-    """
+-    创建简化版回测，用于演示
+-    """
+-    print("创建简化版均线交叉策略回测...")
+-    
+-    # 初始化qlib
+-    qlib.init(provider_uri='~/.qlib/qlib_data/cn_data', region=REG_CN)
+-    
+-    # 获取股票列表
+-    instruments = D.list_instruments(instruments="csi300", start_time="2020-01-01", end_time="2023-12-31")
+-    
+-    print(f"获取到 {len(instruments)} 只股票")
+-    
+-    # 选择前10只股票进行演示
+-    demo_instruments = instruments[:10]
+-    
+-    # 获取价格数据
+-    data = D.features(
+-        instruments=demo_instruments,
+-        start_time="2020-01-01",
+-        end_time="2023-12-31",
+-        freq='day',
+-        fields=['$close']
+-    )
+-    
+-    print(f"获取到价格数据，形状: {data.shape}")
+-    
+-    # 计算均线
+-    short_ma = data.rolling(window=5).mean()
+-    long_ma = data.rolling(window=20).mean()
+-    
+-    # 计算交叉信号
+-    signals = pd.DataFrame(0, index=data.index, columns=data.columns)
+-    
+-    for col in data.columns:
+-        # 计算均线差值
+-        diff = short_ma[col] - long_ma[col]
+-        
+-        # 计算交叉信号
+-        for i in range(1, len(diff)):
+-            if diff.iloc[i-1] < 0 and diff.iloc[i] > 0:
+-                signals.iloc[i, signals.columns.get_loc(col)] = 1  # 金叉买入
+-            elif diff.iloc[i-1] > 0 and diff.iloc[i] < 0:
+-                signals.iloc[i, signals.columns.get_loc(col)] = -1  # 死叉卖出
+-    
+-    # 统计信号
+-    buy_signals = (signals == 1).sum().sum()
+-    sell_signals = (signals == -1).sum().sum()
+-    
+-    print(f"\n信号统计:")
+-    print(f"买入信号数量: {buy_signals}")
+-    print(f"卖出信号数量: {sell_signals}")
+-    
+-    # 计算简单收益（假设每次信号都产生1%的收益）
+-    returns = signals * 0.01
+-    cumulative_returns = returns.sum(axis=1).cumsum()
+-    
+-    print(f"\n累计收益: {cumulative_returns.iloc[-1]:.2%}")
+-    
+-    return signals, cumulative_returns
+-
+-
+-def main():
+-    """
+-    主函数
+-    """
+-    print("开始运行均线交叉策略回测...")
+-    
+-    try:
+-        # 运行简化版回测
+-        signals, cumulative_returns = create_simple_backtest()
+-        
+-        # 保存简化版结果
+-        signals.to_csv("ma_cross_signals.csv")
+-        cumulative_returns.to_csv("ma_cross_cumulative_returns.csv")
+-        
+-        print("\n简化版回测完成！")
+-        print("信号数据已保存到 ma_cross_signals.csv")
+-        print("累计收益已保存到 ma_cross_cumulative_returns.csv")
+-        
+-    except Exception as e:
+-        print(f"回测过程中出现错误: {e}")
+-        print("请确保已正确安装qlib并下载了相应的数据。")
+-
+-
+-if __name__ == "__main__":
+-    main() 
+\ No newline at end of file
+diff --git a/test/ma_strategy_demo.py b/test/ma_strategy_demo.py
+deleted file mode 100644
+index 1fa4fb4..0000000
+Binary files a/test/ma_strategy_demo.py and /dev/null differ
+diff --git a/test/simple_ma_strategy.py b/test/simple_ma_strategy.py
+deleted file mode 100644
+index 8d03f6b..0000000
+--- a/test/simple_ma_strategy.py
++++ /dev/null
+@@ -1,298 +0,0 @@
+-"""
+-简单实用的均线交叉策略
+-金叉买入，死叉卖出
+-"""
+-
+-import qlib
+-from qlib.constant import REG_CN
+-from qlib.data import D
+-import pandas as pd
+-import numpy as np
+-import matplotlib.pyplot as plt
+-from datetime import datetime, timedelta
+-
+-
+-def init_qlib():
+-    """初始化qlib"""
+-    try:
+-        qlib.init(provider_uri='~/.qlib/qlib_data/cn_data', region=REG_CN)
+-        print("qlib初始化成功")
+-        return True
+-    except Exception as e:
+-        print(f"qlib初始化失败: {e}")
+-        print("请确保已安装qlib并下载了数据")
+-        return False
+-
+-
+-def get_stock_data(instruments, start_date, end_date):
+-    """
+-    获取股票数据
+-    
+-    Args:
+-        instruments: 股票代码列表
+-        start_date: 开始日期
+-        end_date: 结束日期
+-    
+-    Returns:
+-        股票价格数据
+-    """
+-    try:
+-        data = D.features(
+-            instruments=instruments,
+-            start_time=start_date,
+-            end_time=end_date,
+-            freq='day',
+-            fields=['$close', '$open', '$high', '$low', '$volume']
+-        )
+-        
+-        if data is not None and not data.empty:
+-            # 重命名列
+-            data.columns = ['close', 'open', 'high', 'low', 'volume']
+-            return data
+-        else:
+-            print("未获取到数据")
+-            return None
+-            
+-    except Exception as e:
+-        print(f"获取数据失败: {e}")
+-        return None
+-
+-
+-def calculate_ma_signals(data, short_window=5, long_window=20):
+-    """
+-    计算均线交叉信号
+-    
+-    Args:
+-        data: 价格数据
+-        short_window: 短期均线周期
+-        long_window: 长期均线周期
+-    
+-    Returns:
+-        信号DataFrame，1表示买入，-1表示卖出，0表示无信号
+-    """
+-    signals = pd.DataFrame(0, index=data.index, columns=data.columns)
+-    
+-    for col in data.columns:
+-        if col == 'close':
+-            continue
+-            
+-        # 计算均线
+-        short_ma = data[col].rolling(window=short_window).mean()
+-        long_ma = data[col].rolling(window=long_window).mean()
+-        
+-        # 计算均线差值
+-        diff = short_ma - long_ma
+-        
+-        # 计算交叉信号
+-        for i in range(1, len(diff)):
+-            if pd.notna(diff.iloc[i-1]) and pd.notna(diff.iloc[i]):
+-                # 金叉：短期均线从下方穿越长期均线
+-                if diff.iloc[i-1] < 0 and diff.iloc[i] > 0:
+-                    signals.iloc[i, signals.columns.get_loc(col)] = 1
+-                # 死叉：短期均线从上方穿越长期均线
+-                elif diff.iloc[i-1] > 0 and diff.iloc[i] < 0:
+-                    signals.iloc[i, signals.columns.get_loc(col)] = -1
+-    
+-    return signals
+-
+-
+-def calculate_returns(data, signals, initial_capital=100000):
+-    """
+-    计算策略收益
+-    
+-    Args:
+-        data: 价格数据
+-        signals: 信号数据
+-        initial_capital: 初始资金
+-    
+-    Returns:
+-        收益数据
+-    """
+-    # 计算日收益率
+-    returns = data.pct_change()
+-    
+-    # 策略收益（假设每次信号产生1%的收益）
+-    strategy_returns = signals * 0.01
+-    
+-    # 累计收益
+-    cumulative_returns = strategy_returns.sum(axis=1).cumsum()
+-    
+-    # 资金曲线
+-    capital_curve = initial_capital * (1 + cumulative_returns)
+-    
+-    return {
+-        'strategy_returns': strategy_returns,
+-        'cumulative_returns': cumulative_returns,
+-        'capital_curve': capital_curve
+-    }
+-
+-
+-def analyze_strategy(signals, returns_data):
+-    """
+-    分析策略表现
+-    
+-    Args:
+-        signals: 信号数据
+-        returns_data: 收益数据
+-    """
+-    print("=" * 50)
+-    print("均线交叉策略分析结果")
+-    print("=" * 50)
+-    
+-    # 信号统计
+-    buy_signals = (signals == 1).sum().sum()
+-    sell_signals = (signals == -1).sum().sum()
+-    
+-    print(f"买入信号数量: {buy_signals}")
+-    print(f"卖出信号数量: {sell_signals}")
+-    print(f"总信号数量: {buy_signals + sell_signals}")
+-    
+-    # 收益统计
+-    cumulative_returns = returns_data['cumulative_returns']
+-    capital_curve = returns_data['capital_curve']
+-    
+-    total_return = cumulative_returns.iloc[-1]
+-    annual_return = total_return / (len(cumulative_returns) / 252)
+-    
+-    print(f"\n收益统计:")
+-    print(f"总收益率: {total_return:.2%}")
+-    print(f"年化收益率: {annual_return:.2%}")
+-    print(f"最终资金: {capital_curve.iloc[-1]:,.0f}")
+-    
+-    # 风险统计
+-    daily_returns = returns_data['strategy_returns'].sum(axis=1)
+-    volatility = daily_returns.std() * np.sqrt(252)
+-    sharpe_ratio = annual_return / volatility if volatility > 0 else 0
+-    
+-    print(f"\n风险统计:")
+-    print(f"年化波动率: {volatility:.2%}")
+-    print(f"夏普比率: {sharpe_ratio:.2f}")
+-    print(f"胜率: {(daily_returns > 0).mean():.2%}")
+-
+-
+-def plot_results(data, signals, returns_data, stock_code):
+-    """
+-    绘制结果图表
+-    
+-    Args:
+-        data: 价格数据
+-        signals: 信号数据
+-        returns_data: 收益数据
+-        stock_code: 股票代码
+-    """
+-    fig, axes = plt.subplots(3, 1, figsize=(12, 10))
+-    
+-    # 绘制价格和均线
+-    axes[0].plot(data.index, data[stock_code], label='收盘价', alpha=0.7)
+-    short_ma = data[stock_code].rolling(window=5).mean()
+-    long_ma = data[stock_code].rolling(window=20).mean()
+-    axes[0].plot(data.index, short_ma, label='5日均线', alpha=0.8)
+-    axes[0].plot(data.index, long_ma, label='20日均线', alpha=0.8)
+-    
+-    # 标记买卖信号
+-    buy_signals = signals[stock_code] == 1
+-    sell_signals = signals[stock_code] == -1
+-    
+-    axes[0].scatter(data.index[buy_signals], data.loc[buy_signals, stock_code], 
+-                   color='red', marker='^', s=100, label='买入信号', alpha=0.8)
+-    axes[0].scatter(data.index[sell_signals], data.loc[sell_signals, stock_code], 
+-                   color='green', marker='v', s=100, label='卖出信号', alpha=0.8)
+-    
+-    axes[0].set_title(f'{stock_code} 价格走势与均线交叉信号')
+-    axes[0].legend()
+-    axes[0].grid(True, alpha=0.3)
+-    
+-    # 绘制累计收益
+-    axes[1].plot(returns_data['cumulative_returns'].index, 
+-                returns_data['cumulative_returns'].values, 
+-                label='累计收益', color='blue')
+-    axes[1].set_title('策略累计收益')
+-    axes[1].legend()
+-    axes[1].grid(True, alpha=0.3)
+-    
+-    # 绘制资金曲线
+-    axes[2].plot(returns_data['capital_curve'].index, 
+-                returns_data['capital_curve'].values, 
+-                label='资金曲线', color='green')
+-    axes[2].set_title('资金曲线')
+-    axes[2].legend()
+-    axes[2].grid(True, alpha=0.3)
+-    
+-    plt.tight_layout()
+-    plt.savefig('ma_cross_strategy_results.png', dpi=300, bbox_inches='tight')
+-    plt.show()
+-
+-
+-def main():
+-    """
+-    主函数
+-    """
+-    print("开始运行均线交叉策略...")
+-    
+-    # 初始化qlib
+-    if not init_qlib():
+-        return
+-    
+-    # 策略参数
+-    start_date = "2020-01-01"
+-    end_date = "2023-12-31"
+-    short_window = 5
+-    long_window = 20
+-    initial_capital = 100000
+-    
+-    # 获取股票列表
+-    try:
+-        instruments = D.list_instruments(instruments="csi300", start_time=start_date, end_time=end_date)
+-        print(f"获取到 {len(instruments)} 只股票")
+-        
+-        # 选择前5只股票进行演示
+-        demo_instruments = instruments[:5]
+-        print(f"选择演示股票: {demo_instruments}")
+-        
+-    except Exception as e:
+-        print(f"获取股票列表失败: {e}")
+-        # 使用默认股票列表
+-        demo_instruments = ['000001.SZ', '000002.SZ', '000858.SZ', '002415.SZ', '600036.SH']
+-        print(f"使用默认股票列表: {demo_instruments}")
+-    
+-    # 获取价格数据
+-    data = get_stock_data(demo_instruments, start_date, end_date)
+-    
+-    if data is None:
+-        print("无法获取数据，程序退出")
+-        return
+-    
+-    print(f"获取到价格数据，形状: {data.shape}")
+-    
+-    # 计算均线信号
+-    signals = calculate_ma_signals(data, short_window, long_window)
+-    
+-    # 计算收益
+-    returns_data = calculate_returns(data, signals, initial_capital)
+-    
+-    # 分析策略
+-    analyze_strategy(signals, returns_data)
+-    
+-    # 保存结果
+-    signals.to_csv("ma_cross_signals.csv")
+-    returns_data['cumulative_returns'].to_csv("ma_cross_cumulative_returns.csv")
+-    returns_data['capital_curve'].to_csv("ma_cross_capital_curve.csv")
+-    
+-    print("\n结果已保存到CSV文件:")
+-    print("- ma_cross_signals.csv: 买卖信号")
+-    print("- ma_cross_cumulative_returns.csv: 累计收益")
+-    print("- ma_cross_capital_curve.csv: 资金曲线")
+-    
+-    # 绘制图表（选择第一只股票）
+-    if len(demo_instruments) > 0:
+-        try:
+-            plot_results(data, signals, returns_data, demo_instruments[0])
+-            print("图表已保存为 ma_cross_strategy_results.png")
+-        except Exception as e:
+-            print(f"绘制图表失败: {e}")
+-    
+-    print("\n策略回测完成！")
+-
+-
+-if __name__ == "__main__":
+-    main() 
+\ No newline at end of file
+diff --git a/test/two_ema_stragety.py b/test/two_ema_stragety.py
+index a72e7e8..a9890c7 100644
+--- a/test/two_ema_stragety.py
++++ b/test/two_ema_stragety.py
+@@ -1,2 +1,98 @@
+-from qlib.contrib.strategy import 
+-from qlib.backtest import backtest
+\ No newline at end of file
++import pandas as pd
++
++from abc import ABC
++from typing import Dict, List, Text, Tuple, Union
++from qlib.data.dataset import Dataset
++from qlib.model.base import BaseModel
++from qlib.backtest.signal import Signal, create_signal_from
++from qlib.strategy.base import BaseStrategy
++from qlib.backtest.decision import Order, OrderDir, OrderHelper, TradeDecisionWO
++# from qlib.strategy import 
++# from qlib.backtest import backtest
++
++class InnerStrategy(BaseStrategy):
++    """
++    Inner strategy for order execution:
++    - Buy: if price < 200, buy all cash; else buy 200,000 worth.
++    - Sell: if price > 200, sell all; else sell half.
++    """
++    STOCK_CODE = "000858.SZ"
++
++    def generate_trade_decision(self, execute_result: list = None, action: str = None, amount: float = None):
++        # action: 'buy' or 'sell', amount: suggested amount (shares) from outer
++        position = self.trade_position
++        trade_step = self.trade_calendar.get_trade_step()
++        trade_start_time, trade_end_time = self.trade_calendar.get_step_time(trade_step)
++        order_helper = self.trade_exchange.get_order_helper()
++        orders = []
++        price = self.trade_exchange.get_deal_price(self.STOCK_CODE, trade_start_time, trade_end_time)
++        if action == 'buy':
++            cash = position.get_cash()
++            if price <= 0:
++                return TradeDecisionWO([], self)
++            if price < 200:
++                buy_amount = cash // price
++            else:
++                buy_amount = min(cash // price, 200000 // price)
++            buy_amount = int(buy_amount)
++            if buy_amount > 0:
++                order = order_helper.create(
++                    code=self.STOCK_CODE,
++                    amount=buy_amount,
++                    direction=OrderDir.BUY,
++                    start_time=trade_start_time,
++                    end_time=trade_end_time,
++                )
++                orders.append(order)
++        elif action == 'sell':
++            held_amount = position.get_stock_amount(self.STOCK_CODE)
++            if held_amount <= 0 or price <= 0:
++                return TradeDecisionWO([], self)
++            if price > 200:
++                sell_amount = held_amount
++            else:
++                sell_amount = held_amount // 2
++            sell_amount = int(sell_amount)
++            if sell_amount > 0:
++                order = order_helper.create(
++                    code=self.STOCK_CODE,
++                    amount=sell_amount,
++                    direction=OrderDir.SELL,
++                    start_time=trade_start_time,
++                    end_time=trade_end_time,
++                )
++                orders.append(order)
++        return TradeDecisionWO(orders, self)
++
++class OuterStrategy(BaseStrategy):
++    """
++    Outer strategy:
++    - If not holding Wuliangye, issues a buy order via inner strategy.
++    - If holding, checks if held for 25 days, if so, issues a sell order via inner strategy.
++    - Otherwise, holds.
++    """
++    STOCK_CODE = "000858.SZ"
++    HOLD_DAYS = 25
++    BAR = "day"
++
++    def __init__(self, *args, **kwargs):
++        super().__init__(*args, **kwargs)
++        self.inner_strategy = InnerStrategy()
++
++    def generate_trade_decision(self, execute_result: list = None):
++        position = self.trade_position
++        stock_list = position.get_stock_list()
++        trade_step = self.trade_calendar.get_trade_step()
++        trade_start_time, trade_end_time = self.trade_calendar.get_step_time(trade_step)
++        # Pass infra to inner strategy
++        self.inner_strategy.reset(level_infra=self.level_infra, common_infra=self.common_infra)
++        if self.STOCK_CODE in stock_list:
++            hold_days = position.get_stock_count(self.STOCK_CODE, self.BAR)
++            if hold_days >= self.HOLD_DAYS:
++                # Sell via inner strategy
++                return self.inner_strategy.generate_trade_decision(action='sell')
++        else:
++            # Buy via inner strategy
++            return self.inner_strategy.generate_trade_decision(action='buy')
++        # Otherwise, hold
++        return TradeDecisionWO([], self)
+\ No newline at end of file
diff --git a/mlruns/812028854715931404/a51ce1b415cd4346ade25311d72affed/artifacts/code_status.txt b/mlruns/812028854715931404/a51ce1b415cd4346ade25311d72affed/artifacts/code_status.txt
new file mode 100644
index 0000000..d9b6458
--- /dev/null
+++ b/mlruns/812028854715931404/a51ce1b415cd4346ade25311d72affed/artifacts/code_status.txt
@@ -0,0 +1,25 @@
+On branch main
+Your branch is up to date with 'origin/main'.
+
+Changes not staged for commit:
+  (use "git add/rm <file>..." to update what will be committed)
+  (use "git restore <file>..." to discard changes in working directory)
+	modified:   github/examples/benchmarks/LightGBM/workflow_config_lightgbm_Alpha1582.yaml
+	deleted:    test/README_MA_Strategy.md
+	modified:   test/damo1.py
+	modified:   test/demo2.ipynb
+	deleted:    test/ma_cross_strategy.py
+	deleted:    test/ma_cross_strategy_improved.py
+	deleted:    test/ma_strategy_demo.py
+	deleted:    test/simple_ma_strategy.py
+	modified:   test/two_ema_stragety.py
+
+Untracked files:
+  (use "git add <file>..." to include in what will be committed)
+	github/examples/mlruns/881301994755452456/157579a2201241aaafcff94e93d7da0e/
+	mlruns/
+	test/__pycache__/
+	test/buy_and_hold.py
+	test/workflow_by_code.py
+
+no changes added to commit (use "git add" and/or "git commit -a")
diff --git a/mlruns/812028854715931404/a51ce1b415cd4346ade25311d72affed/meta.yaml b/mlruns/812028854715931404/a51ce1b415cd4346ade25311d72affed/meta.yaml
new file mode 100644
index 0000000..147f263
--- /dev/null
+++ b/mlruns/812028854715931404/a51ce1b415cd4346ade25311d72affed/meta.yaml
@@ -0,0 +1,14 @@
+artifact_uri: file:D:\project\python\tradenote\mlruns/812028854715931404/a51ce1b415cd4346ade25311d72affed/artifacts
+end_time: 1750320138904
+entry_point_name: ''
+experiment_id: '812028854715931404'
+lifecycle_stage: active
+run_id: a51ce1b415cd4346ade25311d72affed
+run_name: mlflow_recorder
+source_name: ''
+source_type: 4
+source_version: ''
+start_time: 1750320138684
+status: 3
+tags: []
+user_id: abulimity
diff --git a/mlruns/812028854715931404/a51ce1b415cd4346ade25311d72affed/params/cmd-sys.argv b/mlruns/812028854715931404/a51ce1b415cd4346ade25311d72affed/params/cmd-sys.argv
new file mode 100644
index 0000000..db800eb
--- /dev/null
+++ b/mlruns/812028854715931404/a51ce1b415cd4346ade25311d72affed/params/cmd-sys.argv
@@ -0,0 +1 @@
+D:\project\python\tradenote\test\workflow_by_code.py
\ No newline at end of file
diff --git a/mlruns/812028854715931404/a51ce1b415cd4346ade25311d72affed/tags/mlflow.runName b/mlruns/812028854715931404/a51ce1b415cd4346ade25311d72affed/tags/mlflow.runName
new file mode 100644
index 0000000..25487e4
--- /dev/null
+++ b/mlruns/812028854715931404/a51ce1b415cd4346ade25311d72affed/tags/mlflow.runName
@@ -0,0 +1 @@
+mlflow_recorder
\ No newline at end of file
diff --git a/mlruns/812028854715931404/a51ce1b415cd4346ade25311d72affed/tags/mlflow.source.git.commit b/mlruns/812028854715931404/a51ce1b415cd4346ade25311d72affed/tags/mlflow.source.git.commit
new file mode 100644
index 0000000..288ce21
--- /dev/null
+++ b/mlruns/812028854715931404/a51ce1b415cd4346ade25311d72affed/tags/mlflow.source.git.commit
@@ -0,0 +1 @@
+0daea9b5bbb40120a1bc07c702d171abc1f219c7
\ No newline at end of file
diff --git a/mlruns/812028854715931404/a51ce1b415cd4346ade25311d72affed/tags/mlflow.source.name b/mlruns/812028854715931404/a51ce1b415cd4346ade25311d72affed/tags/mlflow.source.name
new file mode 100644
index 0000000..db800eb
--- /dev/null
+++ b/mlruns/812028854715931404/a51ce1b415cd4346ade25311d72affed/tags/mlflow.source.name
@@ -0,0 +1 @@
+D:\project\python\tradenote\test\workflow_by_code.py
\ No newline at end of file
diff --git a/mlruns/812028854715931404/a51ce1b415cd4346ade25311d72affed/tags/mlflow.source.type b/mlruns/812028854715931404/a51ce1b415cd4346ade25311d72affed/tags/mlflow.source.type
new file mode 100644
index 0000000..0c2c1fe
--- /dev/null
+++ b/mlruns/812028854715931404/a51ce1b415cd4346ade25311d72affed/tags/mlflow.source.type
@@ -0,0 +1 @@
+LOCAL
\ No newline at end of file
diff --git a/mlruns/812028854715931404/a51ce1b415cd4346ade25311d72affed/tags/mlflow.user b/mlruns/812028854715931404/a51ce1b415cd4346ade25311d72affed/tags/mlflow.user
new file mode 100644
index 0000000..b9cec6f
--- /dev/null
+++ b/mlruns/812028854715931404/a51ce1b415cd4346ade25311d72affed/tags/mlflow.user
@@ -0,0 +1 @@
+abulimity
\ No newline at end of file
diff --git a/mlruns/812028854715931404/a784ffc1e7a244eeb797b751150b8fe2/artifacts/code_cached.txt b/mlruns/812028854715931404/a784ffc1e7a244eeb797b751150b8fe2/artifacts/code_cached.txt
new file mode 100644
index 0000000..e69de29
diff --git a/mlruns/812028854715931404/a784ffc1e7a244eeb797b751150b8fe2/artifacts/code_diff.txt b/mlruns/812028854715931404/a784ffc1e7a244eeb797b751150b8fe2/artifacts/code_diff.txt
new file mode 100644
index 0000000..ded99a3
--- /dev/null
+++ b/mlruns/812028854715931404/a784ffc1e7a244eeb797b751150b8fe2/artifacts/code_diff.txt
@@ -0,0 +1,1351 @@
+diff --git a/test/README_MA_Strategy.md b/test/README_MA_Strategy.md
+deleted file mode 100644
+index 5facaf7..0000000
+--- a/test/README_MA_Strategy.md
++++ /dev/null
+@@ -1,197 +0,0 @@
+-# 均线交叉策略 (Moving Average Crossover Strategy)
+-
+-## 策略概述
+-
+-这是一个基于qlib框架实现的均线交叉策略，核心逻辑是：
+-- **金叉买入**：短期均线上穿长期均线时买入
+-- **死叉卖出**：短期均线下穿长期均线时卖出
+-
+-## 文件说明
+-
+-### 1. `ma_cross_strategy.py`
+-完整的策略实现，包含：
+-- `MACrossStrategy` 类：继承自qlib的TopkDropoutStrategy
+-- 完整的回测框架
+-- 结果分析和保存
+-
+-### 2. `ma_cross_strategy_improved.py`
+-改进版本，包含：
+-- 更完善的数据获取逻辑
+-- 错误处理机制
+-- 简化版回测功能
+-
+-### 3. `simple_ma_strategy.py` ⭐ **推荐使用**
+-简单实用的版本，包含：
+-- 清晰的数据获取和处理
+-- 均线信号计算
+-- 收益计算和分析
+-- 可视化图表生成
+-- 结果保存功能
+-
+-## 使用方法
+-
+-### 环境准备
+-
+-1. 确保已安装qlib：
+-```bash
+-pip install pyqlib
+-```
+-
+-2. 下载qlib数据（如果还没有）：
+-```bash
+-# 下载中国股票数据
+-python -m qlib.data.dump_bin --csv_path ~/.qlib/qlib_data/cn_data --include_fields close,open,high,low,volume
+-```
+-
+-### 运行策略
+-
+-#### 方法1：运行简单版本（推荐）
+-```bash
+-cd test
+-python simple_ma_strategy.py
+-```
+-
+-#### 方法2：运行完整版本
+-```bash
+-cd test
+-python ma_cross_strategy.py
+-```
+-
+-#### 方法3：运行改进版本
+-```bash
+-cd test
+-python ma_cross_strategy_improved.py
+-```
+-
+-## 策略参数
+-
+-可以在代码中修改以下参数：
+-
+-```python
+-# 均线周期
+-short_window = 5    # 短期均线周期
+-long_window = 20    # 长期均线周期
+-
+-# 回测时间
+-start_date = "2020-01-01"
+-end_date = "2023-12-31"
+-
+-# 初始资金
+-initial_capital = 100000
+-
+-# 股票池
+-instruments = "csi300"  # 沪深300成分股
+-```
+-
+-## 输出结果
+-
+-运行策略后会生成以下文件：
+-
+-1. **CSV文件**：
+-   - `ma_cross_signals.csv`：买卖信号数据
+-   - `ma_cross_cumulative_returns.csv`：累计收益数据
+-   - `ma_cross_capital_curve.csv`：资金曲线数据
+-
+-2. **图表文件**：
+-   - `ma_cross_strategy_results.png`：策略结果可视化图表
+-
+-3. **控制台输出**：
+-   - 策略分析结果
+-   - 收益统计
+-   - 风险指标
+-
+-## 策略分析指标
+-
+-### 收益指标
+-- 总收益率
+-- 年化收益率
+-- 最终资金
+-
+-### 风险指标
+-- 年化波动率
+-- 夏普比率
+-- 胜率
+-- 最大回撤
+-
+-### 交易统计
+-- 买入信号数量
+-- 卖出信号数量
+-- 总交易次数
+-
+-## 策略逻辑详解
+-
+-### 1. 均线计算
+-```python
+-# 计算短期和长期均线
+-short_ma = price_data.rolling(window=short_window).mean()
+-long_ma = price_data.rolling(window=long_window).mean()
+-```
+-
+-### 2. 交叉信号判断
+-```python
+-# 计算均线差值
+-diff = short_ma - long_ma
+-
+-# 金叉：短期均线从下方穿越长期均线
+-if diff.iloc[i-1] < 0 and diff.iloc[i] > 0:
+-    signal = 1  # 买入信号
+-
+-# 死叉：短期均线从上方穿越长期均线
+-elif diff.iloc[i-1] > 0 and diff.iloc[i] < 0:
+-    signal = -1  # 卖出信号
+-```
+-
+-### 3. 收益计算
+-```python
+-# 策略收益（简化处理）
+-strategy_returns = signals * 0.01
+-
+-# 累计收益
+-cumulative_returns = strategy_returns.sum(axis=1).cumsum()
+-```
+-
+-## 注意事项
+-
+-1. **数据依赖**：确保qlib数据已正确下载和配置
+-2. **参数调优**：可以根据不同市场环境调整均线周期
+-3. **风险控制**：实际交易中需要加入止损和仓位管理
+-4. **交易成本**：当前版本未考虑交易费用，实际应用需要考虑
+-
+-## 扩展功能
+-
+-可以基于此策略进行以下扩展：
+-
+-1. **多均线策略**：使用多条均线进行更复杂的信号判断
+-2. **量价配合**：结合成交量指标优化信号
+-3. **止损机制**：添加动态止损策略
+-4. **仓位管理**：根据信号强度调整仓位大小
+-5. **多股票组合**：构建股票组合分散风险
+-
+-## 常见问题
+-
+-### Q: 如何修改股票池？
+-A: 在代码中修改 `instruments` 参数，例如：
+-```python
+-instruments = "csi500"  # 中证500
+-instruments = ["000001.SZ", "000002.SZ"]  # 指定股票列表
+-```
+-
+-### Q: 如何调整均线周期？
+-A: 修改 `short_window` 和 `long_window` 参数：
+-```python
+-short_window = 10  # 10日均线
+-long_window = 30   # 30日均线
+-```
+-
+-### Q: 如何查看详细的交易记录？
+-A: 查看生成的 `ma_cross_signals.csv` 文件，其中包含每日的买卖信号。
+-
+-## 联系方式
+-
+-如有问题或建议，请通过以下方式联系：
+-- 提交Issue到项目仓库
+-- 发送邮件到项目维护者
+-
+----
+-
+-**免责声明**：本策略仅供学习和研究使用，不构成投资建议。实际投资请谨慎决策，并承担相应风险。 
+\ No newline at end of file
+diff --git a/test/ma_cross_strategy.py b/test/ma_cross_strategy.py
+deleted file mode 100644
+index 719d849..0000000
+--- a/test/ma_cross_strategy.py
++++ /dev/null
+@@ -1,274 +0,0 @@
+-"""
+-均线交叉策略：金叉买入，死叉卖出
+-使用qlib框架实现
+-"""
+-
+-import qlib
+-from qlib.constant import REG_CN
+-from qlib.utils import init_instance_by_config
+-from qlib.workflow import R
+-from qlib.workflow.record_temp import SignalRecord, PortAnaRecord
+-from qlib.contrib.evaluate import backtest_daily
+-from qlib.contrib.strategy import TopkDropoutStrategy
+-import pandas as pd
+-import numpy as np
+-from typing import Dict, List, Tuple
+-
+-
+-class MACrossStrategy(TopkDropoutStrategy):
+-    """
+-    均线交叉策略
+-    金叉（短期均线上穿长期均线）买入
+-    死叉（短期均线下穿长期均线）卖出
+-    """
+-    
+-    def __init__(self, 
+-                 short_window: int = 5,
+-                 long_window: int = 20,
+-                 topk: int = 50,
+-                 n_drop: int = 5,
+-                 **kwargs):
+-        """
+-        初始化策略参数
+-        
+-        Args:
+-            short_window: 短期均线周期
+-            long_window: 长期均线周期
+-            topk: 选择前k只股票
+-            n_drop: 剔除前n只股票
+-        """
+-        super().__init__(topk=topk, n_drop=n_drop, **kwargs)
+-        self.short_window = short_window
+-        self.long_window = long_window
+-        
+-    def generate_trade_decision(self, score: pd.Series, trade_step: int) -> pd.Series:
+-        """
+-        生成交易决策
+-        
+-        Args:
+-            score: 股票评分
+-            trade_step: 交易步骤
+-            
+-        Returns:
+-            交易决策，1表示买入，-1表示卖出，0表示持有
+-        """
+-        # 获取当前持仓
+-        current_pos = self.get_current_position()
+-        
+-        # 计算均线信号
+-        signal = self._calculate_ma_signal(score.index.tolist(), trade_step)
+-        
+-        # 生成交易决策
+-        decision = pd.Series(0, index=score.index)
+-        
+-        # 金叉买入信号
+-        buy_signal = signal == 1
+-        decision[buy_signal] = 1
+-        
+-        # 死叉卖出信号
+-        sell_signal = signal == -1
+-        decision[sell_signal] = -1
+-        
+-        return decision
+-    
+-    def _calculate_ma_signal(self, instruments: List[str], trade_step: int) -> pd.Series:
+-        """
+-        计算均线交叉信号
+-        
+-        Args:
+-            instruments: 股票代码列表
+-            trade_step: 交易步骤
+-            
+-        Returns:
+-            信号序列：1表示金叉买入，-1表示死叉卖出，0表示无信号
+-        """
+-        # 获取历史数据
+-        data = self._get_historical_data(instruments, trade_step)
+-        
+-        signals = pd.Series(0, index=instruments)
+-        
+-        for instrument in instruments:
+-            if instrument in data.index:
+-                # 计算短期和长期均线
+-                short_ma = data.loc[instrument].rolling(window=self.short_window).mean()
+-                long_ma = data.loc[instrument].rolling(window=self.long_window).mean()
+-                
+-                # 计算交叉信号
+-                if len(short_ma) >= 2 and len(long_ma) >= 2:
+-                    # 当前和前一个时间点的均线差值
+-                    current_diff = short_ma.iloc[-1] - long_ma.iloc[-1]
+-                    prev_diff = short_ma.iloc[-2] - long_ma.iloc[-2]
+-                    
+-                    # 金叉：短期均线从下方穿越长期均线
+-                    if prev_diff < 0 and current_diff > 0:
+-                        signals[instrument] = 1
+-                    # 死叉：短期均线从上方穿越长期均线
+-                    elif prev_diff > 0 and current_diff < 0:
+-                        signals[instrument] = -1
+-        
+-        return signals
+-    
+-    def _get_historical_data(self, instruments: List[str], trade_step: int) -> pd.DataFrame:
+-        """
+-        获取历史价格数据
+-        
+-        Args:
+-            instruments: 股票代码列表
+-            trade_step: 交易步骤
+-            
+-        Returns:
+-            历史价格数据
+-        """
+-        # 这里简化处理，实际应该从qlib数据源获取
+-        # 在实际应用中，您需要使用qlib的数据接口
+-        try:
+-            # 获取最近的数据用于计算均线
+-            # 这里使用模拟数据，实际应该从qlib获取
+-            dates = pd.date_range(end=pd.Timestamp.now(), periods=50, freq='D')
+-            data = pd.DataFrame(
+-                np.random.randn(len(dates), len(instruments)) * 0.02 + 1.0,
+-                index=dates,
+-                columns=instruments
+-            )
+-            return data
+-        except Exception as e:
+-            print(f"获取历史数据失败: {e}")
+-            return pd.DataFrame()
+-
+-
+-def create_ma_cross_strategy_config():
+-    """
+-    创建均线交叉策略配置
+-    """
+-    strategy_config = {
+-        "class": "MACrossStrategy",
+-        "module_path": "test.ma_cross_strategy",
+-        "kwargs": {
+-            "short_window": 5,
+-            "long_window": 20,
+-            "topk": 50,
+-            "n_drop": 5,
+-        }
+-    }
+-    
+-    return strategy_config
+-
+-
+-def run_backtest():
+-    """
+-    运行回测
+-    """
+-    # 初始化qlib
+-    qlib.init(provider_uri='~/.qlib/qlib_data/cn_data', region=REG_CN)
+-    
+-    # 策略配置
+-    strategy_config = create_ma_cross_strategy_config()
+-    
+-    # 回测配置
+-    backtest_config = {
+-        "start_time": "2020-01-01",
+-        "end_time": "2023-12-31",
+-        "benchmark": "SH000300",  # 沪深300作为基准
+-        "account": 100000000,     # 初始资金1亿
+-        "exchange_kwargs": {
+-            "freq": "day",
+-            "limit_threshold": 0.095,
+-            "deal_price": "close",
+-            "open_cost": 0.0005,
+-            "close_cost": 0.0015,
+-            "min_cost": 5,
+-        }
+-    }
+-    
+-    # 创建策略实例
+-    strategy = init_instance_by_config(strategy_config)
+-    
+-    # 运行回测
+-    with R.start(experiment_name="ma_cross_strategy"):
+-        # 记录信号
+-        sr = SignalRecord(model=strategy, dataset=None, recorder=R.get_recorder())
+-        sr.generate()
+-        
+-        # 记录投资组合分析
+-        par = PortAnaRecord(recorder=R.get_recorder(), config=backtest_config, strategy=strategy)
+-        par.generate()
+-        
+-        # 获取回测结果
+-        report_normal, positions_normal = backtest_daily(
+-            account=backtest_config["account"],
+-            benchmark=backtest_config["benchmark"],
+-            start_time=backtest_config["start_time"],
+-            end_time=backtest_config["end_time"],
+-            strategy=strategy,
+-            exchange_kwargs=backtest_config["exchange_kwargs"]
+-        )
+-        
+-        return report_normal, positions_normal
+-
+-
+-def analyze_results(report: pd.DataFrame, positions: pd.DataFrame):
+-    """
+-    分析回测结果
+-    
+-    Args:
+-        report: 回测报告
+-        positions: 持仓信息
+-    """
+-    print("=" * 50)
+-    print("均线交叉策略回测结果")
+-    print("=" * 50)
+-    
+-    # 基本统计信息
+-    print(f"总收益率: {report['return'].sum():.2%}")
+-    print(f"年化收益率: {report['return'].mean() * 252:.2%}")
+-    print(f"最大回撤: {report['drawdown'].min():.2%}")
+-    print(f"夏普比率: {report['sharpe'].iloc[-1]:.2f}")
+-    print(f"胜率: {(report['return'] > 0).mean():.2%}")
+-    
+-    # 风险指标
+-    volatility = report['return'].std() * np.sqrt(252)
+-    print(f"年化波动率: {volatility:.2%}")
+-    
+-    # 最大回撤期间
+-    max_drawdown_idx = report['drawdown'].idxmin()
+-    print(f"最大回撤发生时间: {max_drawdown_idx}")
+-    
+-    # 收益分布
+-    print("\n收益分布统计:")
+-    print(f"平均日收益: {report['return'].mean():.2%}")
+-    print(f"收益标准差: {report['return'].std():.2%}")
+-    print(f"最小日收益: {report['return'].min():.2%}")
+-    print(f"最大日收益: {report['return'].max():.2%}")
+-    
+-    # 交易统计
+-    if 'trade_count' in report.columns:
+-        print(f"\n总交易次数: {report['trade_count'].sum()}")
+-        print(f"平均每日交易次数: {report['trade_count'].mean():.1f}")
+-
+-
+-def main():
+-    """
+-    主函数
+-    """
+-    print("开始运行均线交叉策略回测...")
+-    
+-    try:
+-        # 运行回测
+-        report, positions = run_backtest()
+-        
+-        # 分析结果
+-        analyze_results(report, positions)
+-        
+-        # 保存结果
+-        report.to_csv("ma_cross_strategy_report.csv")
+-        positions.to_csv("ma_cross_strategy_positions.csv")
+-        
+-        print("\n回测完成！结果已保存到CSV文件。")
+-        
+-    except Exception as e:
+-        print(f"回测过程中出现错误: {e}")
+-        print("请确保已正确安装qlib并下载了相应的数据。")
+-
+-
+-if __name__ == "__main__":
+-    main() 
+\ No newline at end of file
+diff --git a/test/ma_cross_strategy_improved.py b/test/ma_cross_strategy_improved.py
+deleted file mode 100644
+index d166c68..0000000
+--- a/test/ma_cross_strategy_improved.py
++++ /dev/null
+@@ -1,443 +0,0 @@
+-"""
+-改进的均线交叉策略：金叉买入，死叉卖出
+-使用qlib框架实现，包含完整的数据获取和信号计算
+-"""
+-
+-import qlib
+-from qlib.constant import REG_CN
+-from qlib.utils import init_instance_by_config
+-from qlib.workflow import R
+-from qlib.workflow.record_temp import SignalRecord, PortAnaRecord
+-from qlib.contrib.evaluate import backtest_daily
+-from qlib.contrib.strategy import TopkDropoutStrategy
+-from qlib.data import D
+-from qlib.data.dataset import DatasetH
+-from qlib.data.dataset.handler import DataHandlerLP
+-import pandas as pd
+-import numpy as np
+-from typing import Dict, List, Tuple
+-import warnings
+-warnings.filterwarnings('ignore')
+-
+-
+-class MACrossStrategyImproved(TopkDropoutStrategy):
+-    """
+-    改进的均线交叉策略
+-    金叉（短期均线上穿长期均线）买入
+-    死叉（短期均线下穿长期均线）卖出
+-    """
+-    
+-    def __init__(self, 
+-                 short_window: int = 5,
+-                 long_window: int = 20,
+-                 topk: int = 50,
+-                 n_drop: int = 5,
+-                 universe: str = "csi300",
+-                 **kwargs):
+-        """
+-        初始化策略参数
+-        
+-        Args:
+-            short_window: 短期均线周期
+-            long_window: 长期均线周期
+-            topk: 选择前k只股票
+-            n_drop: 剔除前n只股票
+-            universe: 股票池
+-        """
+-        super().__init__(topk=topk, n_drop=n_drop, **kwargs)
+-        self.short_window = short_window
+-        self.long_window = long_window
+-        self.universe = universe
+-        self.instruments = None
+-        self.price_cache = {}
+-        
+-    def generate_trade_decision(self, score: pd.Series, trade_step: int) -> pd.Series:
+-        """
+-        生成交易决策
+-        
+-        Args:
+-            score: 股票评分
+-            trade_step: 交易步骤
+-            
+-        Returns:
+-            交易决策，1表示买入，-1表示卖出，0表示持有
+-        """
+-        # 获取当前持仓
+-        current_pos = self.get_current_position()
+-        
+-        # 计算均线信号
+-        signal = self._calculate_ma_signal(score.index.tolist(), trade_step)
+-        
+-        # 生成交易决策
+-        decision = pd.Series(0, index=score.index)
+-        
+-        # 金叉买入信号
+-        buy_signal = signal == 1
+-        decision[buy_signal] = 1
+-        
+-        # 死叉卖出信号
+-        sell_signal = signal == -1
+-        decision[sell_signal] = -1
+-        
+-        return decision
+-    
+-    def _calculate_ma_signal(self, instruments: List[str], trade_step: int) -> pd.Series:
+-        """
+-        计算均线交叉信号
+-        
+-        Args:
+-            instruments: 股票代码列表
+-            trade_step: 交易步骤
+-            
+-        Returns:
+-            信号序列：1表示金叉买入，-1表示死叉卖出，0表示无信号
+-        """
+-        signals = pd.Series(0, index=instruments)
+-        
+-        # 获取当前日期
+-        current_date = self._get_current_date(trade_step)
+-        
+-        for instrument in instruments:
+-            try:
+-                # 获取历史价格数据
+-                price_data = self._get_price_data(instrument, current_date)
+-                
+-                if price_data is not None and len(price_data) >= self.long_window:
+-                    # 计算短期和长期均线
+-                    short_ma = price_data['close'].rolling(window=self.short_window).mean()
+-                    long_ma = price_data['close'].rolling(window=self.long_window).mean()
+-                    
+-                    # 计算交叉信号
+-                    if len(short_ma) >= 2 and len(long_ma) >= 2:
+-                        # 当前和前一个时间点的均线差值
+-                        current_diff = short_ma.iloc[-1] - long_ma.iloc[-1]
+-                        prev_diff = short_ma.iloc[-2] - long_ma.iloc[-2]
+-                        
+-                        # 金叉：短期均线从下方穿越长期均线
+-                        if prev_diff < 0 and current_diff > 0:
+-                            signals[instrument] = 1
+-                        # 死叉：短期均线从上方穿越长期均线
+-                        elif prev_diff > 0 and current_diff < 0:
+-                            signals[instrument] = -1
+-                            
+-            except Exception as e:
+-                print(f"计算{instrument}均线信号时出错: {e}")
+-                continue
+-        
+-        return signals
+-    
+-    def _get_price_data(self, instrument: str, current_date: str) -> pd.DataFrame:
+-        """
+-        获取股票价格数据
+-        
+-        Args:
+-            instrument: 股票代码
+-            current_date: 当前日期
+-            
+-        Returns:
+-            价格数据DataFrame
+-        """
+-        try:
+-            # 计算开始日期（获取足够的历史数据来计算均线）
+-            start_date = pd.Timestamp(current_date) - pd.Timedelta(days=self.long_window * 2)
+-            
+-            # 从qlib获取数据
+-            data = D.features(
+-                instruments=[instrument],
+-                start_time=start_date.strftime('%Y-%m-%d'),
+-                end_time=current_date,
+-                freq='day',
+-                fields=['$close', '$open', '$high', '$low', '$volume']
+-            )
+-            
+-            if data is not None and not data.empty:
+-                # 重命名列
+-                data.columns = ['close', 'open', 'high', 'low', 'volume']
+-                return data
+-            else:
+-                return None
+-                
+-        except Exception as e:
+-            print(f"获取{instrument}价格数据失败: {e}")
+-            return None
+-    
+-    def _get_current_date(self, trade_step: int) -> str:
+-        """
+-        根据交易步骤获取当前日期
+-        
+-        Args:
+-            trade_step: 交易步骤
+-            
+-        Returns:
+-            当前日期字符串
+-        """
+-        # 这里简化处理，实际应该从qlib的日历获取
+-        # 假设从2020-01-01开始，每个trade_step代表一天
+-        start_date = pd.Timestamp('2020-01-01')
+-        current_date = start_date + pd.Timedelta(days=trade_step)
+-        return current_date.strftime('%Y-%m-%d')
+-
+-
+-def create_dataset_config():
+-    """
+-    创建数据集配置
+-    """
+-    dataset_config = {
+-        "class": "DatasetH",
+-        "module_path": "qlib.data.dataset",
+-        "kwargs": {
+-            "handler": {
+-                "class": "DataHandlerLP",
+-                "module_path": "qlib.data.dataset.handler",
+-                "kwargs": {
+-                    "start_time": "2020-01-01",
+-                    "end_time": "2023-12-31",
+-                    "fit_start_time": "2020-01-01",
+-                    "fit_end_time": "2023-12-31",
+-                    "instruments": "csi300",
+-                    "infer_processors": [
+-                        {
+-                            "class": "RobustZScoreNorm",
+-                            "module_path": "qlib.data.dataset.processor",
+-                            "kwargs": {
+-                                "fields_group": "feature",
+-                                "clip_outlier": True,
+-                            },
+-                        },
+-                        {
+-                            "class": "Fillna",
+-                            "module_path": "qlib.data.dataset.processor",
+-                            "kwargs": {
+-                                "fields_group": "feature",
+-                            },
+-                        },
+-                    ],
+-                    "learn_processors": [
+-                        {
+-                            "class": "DropnaLabel",
+-                            "module_path": "qlib.data.dataset.processor",
+-                        },
+-                        {
+-                            "class": "CSRankNorm",
+-                            "module_path": "qlib.data.dataset.processor",
+-                            "kwargs": {
+-                                "fields_group": "label",
+-                            },
+-                        },
+-                    ],
+-                    "instruments": "csi300",
+-                },
+-            },
+-            "segments": {
+-                "train": ("2020-01-01", "2022-12-31"),
+-                "valid": ("2023-01-01", "2023-06-30"),
+-                "test": ("2023-07-01", "2023-12-31"),
+-            },
+-        },
+-    }
+-    
+-    return dataset_config
+-
+-
+-def create_ma_cross_strategy_config():
+-    """
+-    创建均线交叉策略配置
+-    """
+-    strategy_config = {
+-        "class": "MACrossStrategyImproved",
+-        "module_path": "test.ma_cross_strategy_improved",
+-        "kwargs": {
+-            "short_window": 5,
+-            "long_window": 20,
+-            "topk": 50,
+-            "n_drop": 5,
+-            "universe": "csi300",
+-        }
+-    }
+-    
+-    return strategy_config
+-
+-
+-def run_backtest():
+-    """
+-    运行回测
+-    """
+-    # 初始化qlib
+-    qlib.init(provider_uri='~/.qlib/qlib_data/cn_data', region=REG_CN)
+-    
+-    # 策略配置
+-    strategy_config = create_ma_cross_strategy_config()
+-    
+-    # 回测配置
+-    backtest_config = {
+-        "start_time": "2020-01-01",
+-        "end_time": "2023-12-31",
+-        "benchmark": "SH000300",  # 沪深300作为基准
+-        "account": 100000000,     # 初始资金1亿
+-        "exchange_kwargs": {
+-            "freq": "day",
+-            "limit_threshold": 0.095,
+-            "deal_price": "close",
+-            "open_cost": 0.0005,
+-            "close_cost": 0.0015,
+-            "min_cost": 5,
+-        }
+-    }
+-    
+-    # 创建策略实例
+-    strategy = init_instance_by_config(strategy_config)
+-    
+-    # 运行回测
+-    with R.start(experiment_name="ma_cross_strategy_improved"):
+-        # 记录信号
+-        sr = SignalRecord(model=strategy, dataset=None, recorder=R.get_recorder())
+-        sr.generate()
+-        
+-        # 记录投资组合分析
+-        par = PortAnaRecord(recorder=R.get_recorder(), config=backtest_config, strategy=strategy)
+-        par.generate()
+-        
+-        # 获取回测结果
+-        report_normal, positions_normal = backtest_daily(
+-            account=backtest_config["account"],
+-            benchmark=backtest_config["benchmark"],
+-            start_time=backtest_config["start_time"],
+-            end_time=backtest_config["end_time"],
+-            strategy=strategy,
+-            exchange_kwargs=backtest_config["exchange_kwargs"]
+-        )
+-        
+-        return report_normal, positions_normal
+-
+-
+-def analyze_results(report: pd.DataFrame, positions: pd.DataFrame):
+-    """
+-    分析回测结果
+-    
+-    Args:
+-        report: 回测报告
+-        positions: 持仓信息
+-    """
+-    print("=" * 50)
+-    print("均线交叉策略回测结果")
+-    print("=" * 50)
+-    
+-    # 基本统计信息
+-    print(f"总收益率: {report['return'].sum():.2%}")
+-    print(f"年化收益率: {report['return'].mean() * 252:.2%}")
+-    print(f"最大回撤: {report['drawdown'].min():.2%}")
+-    
+-    if 'sharpe' in report.columns:
+-        print(f"夏普比率: {report['sharpe'].iloc[-1]:.2f}")
+-    
+-    print(f"胜率: {(report['return'] > 0).mean():.2%}")
+-    
+-    # 风险指标
+-    volatility = report['return'].std() * np.sqrt(252)
+-    print(f"年化波动率: {volatility:.2%}")
+-    
+-    # 最大回撤期间
+-    max_drawdown_idx = report['drawdown'].idxmin()
+-    print(f"最大回撤发生时间: {max_drawdown_idx}")
+-    
+-    # 收益分布
+-    print("\n收益分布统计:")
+-    print(f"平均日收益: {report['return'].mean():.2%}")
+-    print(f"收益标准差: {report['return'].std():.2%}")
+-    print(f"最小日收益: {report['return'].min():.2%}")
+-    print(f"最大日收益: {report['return'].max():.2%}")
+-    
+-    # 交易统计
+-    if 'trade_count' in report.columns:
+-        print(f"\n总交易次数: {report['trade_count'].sum()}")
+-        print(f"平均每日交易次数: {report['trade_count'].mean():.1f}")
+-
+-
+-def create_simple_backtest():
+-    """
+-    创建简化版回测，用于演示
+-    """
+-    print("创建简化版均线交叉策略回测...")
+-    
+-    # 初始化qlib
+-    qlib.init(provider_uri='~/.qlib/qlib_data/cn_data', region=REG_CN)
+-    
+-    # 获取股票列表
+-    instruments = D.list_instruments(instruments="csi300", start_time="2020-01-01", end_time="2023-12-31")
+-    
+-    print(f"获取到 {len(instruments)} 只股票")
+-    
+-    # 选择前10只股票进行演示
+-    demo_instruments = instruments[:10]
+-    
+-    # 获取价格数据
+-    data = D.features(
+-        instruments=demo_instruments,
+-        start_time="2020-01-01",
+-        end_time="2023-12-31",
+-        freq='day',
+-        fields=['$close']
+-    )
+-    
+-    print(f"获取到价格数据，形状: {data.shape}")
+-    
+-    # 计算均线
+-    short_ma = data.rolling(window=5).mean()
+-    long_ma = data.rolling(window=20).mean()
+-    
+-    # 计算交叉信号
+-    signals = pd.DataFrame(0, index=data.index, columns=data.columns)
+-    
+-    for col in data.columns:
+-        # 计算均线差值
+-        diff = short_ma[col] - long_ma[col]
+-        
+-        # 计算交叉信号
+-        for i in range(1, len(diff)):
+-            if diff.iloc[i-1] < 0 and diff.iloc[i] > 0:
+-                signals.iloc[i, signals.columns.get_loc(col)] = 1  # 金叉买入
+-            elif diff.iloc[i-1] > 0 and diff.iloc[i] < 0:
+-                signals.iloc[i, signals.columns.get_loc(col)] = -1  # 死叉卖出
+-    
+-    # 统计信号
+-    buy_signals = (signals == 1).sum().sum()
+-    sell_signals = (signals == -1).sum().sum()
+-    
+-    print(f"\n信号统计:")
+-    print(f"买入信号数量: {buy_signals}")
+-    print(f"卖出信号数量: {sell_signals}")
+-    
+-    # 计算简单收益（假设每次信号都产生1%的收益）
+-    returns = signals * 0.01
+-    cumulative_returns = returns.sum(axis=1).cumsum()
+-    
+-    print(f"\n累计收益: {cumulative_returns.iloc[-1]:.2%}")
+-    
+-    return signals, cumulative_returns
+-
+-
+-def main():
+-    """
+-    主函数
+-    """
+-    print("开始运行均线交叉策略回测...")
+-    
+-    try:
+-        # 运行简化版回测
+-        signals, cumulative_returns = create_simple_backtest()
+-        
+-        # 保存简化版结果
+-        signals.to_csv("ma_cross_signals.csv")
+-        cumulative_returns.to_csv("ma_cross_cumulative_returns.csv")
+-        
+-        print("\n简化版回测完成！")
+-        print("信号数据已保存到 ma_cross_signals.csv")
+-        print("累计收益已保存到 ma_cross_cumulative_returns.csv")
+-        
+-    except Exception as e:
+-        print(f"回测过程中出现错误: {e}")
+-        print("请确保已正确安装qlib并下载了相应的数据。")
+-
+-
+-if __name__ == "__main__":
+-    main() 
+\ No newline at end of file
+diff --git a/test/ma_strategy_demo.py b/test/ma_strategy_demo.py
+deleted file mode 100644
+index 1fa4fb4..0000000
+Binary files a/test/ma_strategy_demo.py and /dev/null differ
+diff --git a/test/simple_ma_strategy.py b/test/simple_ma_strategy.py
+deleted file mode 100644
+index 8d03f6b..0000000
+--- a/test/simple_ma_strategy.py
++++ /dev/null
+@@ -1,298 +0,0 @@
+-"""
+-简单实用的均线交叉策略
+-金叉买入，死叉卖出
+-"""
+-
+-import qlib
+-from qlib.constant import REG_CN
+-from qlib.data import D
+-import pandas as pd
+-import numpy as np
+-import matplotlib.pyplot as plt
+-from datetime import datetime, timedelta
+-
+-
+-def init_qlib():
+-    """初始化qlib"""
+-    try:
+-        qlib.init(provider_uri='~/.qlib/qlib_data/cn_data', region=REG_CN)
+-        print("qlib初始化成功")
+-        return True
+-    except Exception as e:
+-        print(f"qlib初始化失败: {e}")
+-        print("请确保已安装qlib并下载了数据")
+-        return False
+-
+-
+-def get_stock_data(instruments, start_date, end_date):
+-    """
+-    获取股票数据
+-    
+-    Args:
+-        instruments: 股票代码列表
+-        start_date: 开始日期
+-        end_date: 结束日期
+-    
+-    Returns:
+-        股票价格数据
+-    """
+-    try:
+-        data = D.features(
+-            instruments=instruments,
+-            start_time=start_date,
+-            end_time=end_date,
+-            freq='day',
+-            fields=['$close', '$open', '$high', '$low', '$volume']
+-        )
+-        
+-        if data is not None and not data.empty:
+-            # 重命名列
+-            data.columns = ['close', 'open', 'high', 'low', 'volume']
+-            return data
+-        else:
+-            print("未获取到数据")
+-            return None
+-            
+-    except Exception as e:
+-        print(f"获取数据失败: {e}")
+-        return None
+-
+-
+-def calculate_ma_signals(data, short_window=5, long_window=20):
+-    """
+-    计算均线交叉信号
+-    
+-    Args:
+-        data: 价格数据
+-        short_window: 短期均线周期
+-        long_window: 长期均线周期
+-    
+-    Returns:
+-        信号DataFrame，1表示买入，-1表示卖出，0表示无信号
+-    """
+-    signals = pd.DataFrame(0, index=data.index, columns=data.columns)
+-    
+-    for col in data.columns:
+-        if col == 'close':
+-            continue
+-            
+-        # 计算均线
+-        short_ma = data[col].rolling(window=short_window).mean()
+-        long_ma = data[col].rolling(window=long_window).mean()
+-        
+-        # 计算均线差值
+-        diff = short_ma - long_ma
+-        
+-        # 计算交叉信号
+-        for i in range(1, len(diff)):
+-            if pd.notna(diff.iloc[i-1]) and pd.notna(diff.iloc[i]):
+-                # 金叉：短期均线从下方穿越长期均线
+-                if diff.iloc[i-1] < 0 and diff.iloc[i] > 0:
+-                    signals.iloc[i, signals.columns.get_loc(col)] = 1
+-                # 死叉：短期均线从上方穿越长期均线
+-                elif diff.iloc[i-1] > 0 and diff.iloc[i] < 0:
+-                    signals.iloc[i, signals.columns.get_loc(col)] = -1
+-    
+-    return signals
+-
+-
+-def calculate_returns(data, signals, initial_capital=100000):
+-    """
+-    计算策略收益
+-    
+-    Args:
+-        data: 价格数据
+-        signals: 信号数据
+-        initial_capital: 初始资金
+-    
+-    Returns:
+-        收益数据
+-    """
+-    # 计算日收益率
+-    returns = data.pct_change()
+-    
+-    # 策略收益（假设每次信号产生1%的收益）
+-    strategy_returns = signals * 0.01
+-    
+-    # 累计收益
+-    cumulative_returns = strategy_returns.sum(axis=1).cumsum()
+-    
+-    # 资金曲线
+-    capital_curve = initial_capital * (1 + cumulative_returns)
+-    
+-    return {
+-        'strategy_returns': strategy_returns,
+-        'cumulative_returns': cumulative_returns,
+-        'capital_curve': capital_curve
+-    }
+-
+-
+-def analyze_strategy(signals, returns_data):
+-    """
+-    分析策略表现
+-    
+-    Args:
+-        signals: 信号数据
+-        returns_data: 收益数据
+-    """
+-    print("=" * 50)
+-    print("均线交叉策略分析结果")
+-    print("=" * 50)
+-    
+-    # 信号统计
+-    buy_signals = (signals == 1).sum().sum()
+-    sell_signals = (signals == -1).sum().sum()
+-    
+-    print(f"买入信号数量: {buy_signals}")
+-    print(f"卖出信号数量: {sell_signals}")
+-    print(f"总信号数量: {buy_signals + sell_signals}")
+-    
+-    # 收益统计
+-    cumulative_returns = returns_data['cumulative_returns']
+-    capital_curve = returns_data['capital_curve']
+-    
+-    total_return = cumulative_returns.iloc[-1]
+-    annual_return = total_return / (len(cumulative_returns) / 252)
+-    
+-    print(f"\n收益统计:")
+-    print(f"总收益率: {total_return:.2%}")
+-    print(f"年化收益率: {annual_return:.2%}")
+-    print(f"最终资金: {capital_curve.iloc[-1]:,.0f}")
+-    
+-    # 风险统计
+-    daily_returns = returns_data['strategy_returns'].sum(axis=1)
+-    volatility = daily_returns.std() * np.sqrt(252)
+-    sharpe_ratio = annual_return / volatility if volatility > 0 else 0
+-    
+-    print(f"\n风险统计:")
+-    print(f"年化波动率: {volatility:.2%}")
+-    print(f"夏普比率: {sharpe_ratio:.2f}")
+-    print(f"胜率: {(daily_returns > 0).mean():.2%}")
+-
+-
+-def plot_results(data, signals, returns_data, stock_code):
+-    """
+-    绘制结果图表
+-    
+-    Args:
+-        data: 价格数据
+-        signals: 信号数据
+-        returns_data: 收益数据
+-        stock_code: 股票代码
+-    """
+-    fig, axes = plt.subplots(3, 1, figsize=(12, 10))
+-    
+-    # 绘制价格和均线
+-    axes[0].plot(data.index, data[stock_code], label='收盘价', alpha=0.7)
+-    short_ma = data[stock_code].rolling(window=5).mean()
+-    long_ma = data[stock_code].rolling(window=20).mean()
+-    axes[0].plot(data.index, short_ma, label='5日均线', alpha=0.8)
+-    axes[0].plot(data.index, long_ma, label='20日均线', alpha=0.8)
+-    
+-    # 标记买卖信号
+-    buy_signals = signals[stock_code] == 1
+-    sell_signals = signals[stock_code] == -1
+-    
+-    axes[0].scatter(data.index[buy_signals], data.loc[buy_signals, stock_code], 
+-                   color='red', marker='^', s=100, label='买入信号', alpha=0.8)
+-    axes[0].scatter(data.index[sell_signals], data.loc[sell_signals, stock_code], 
+-                   color='green', marker='v', s=100, label='卖出信号', alpha=0.8)
+-    
+-    axes[0].set_title(f'{stock_code} 价格走势与均线交叉信号')
+-    axes[0].legend()
+-    axes[0].grid(True, alpha=0.3)
+-    
+-    # 绘制累计收益
+-    axes[1].plot(returns_data['cumulative_returns'].index, 
+-                returns_data['cumulative_returns'].values, 
+-                label='累计收益', color='blue')
+-    axes[1].set_title('策略累计收益')
+-    axes[1].legend()
+-    axes[1].grid(True, alpha=0.3)
+-    
+-    # 绘制资金曲线
+-    axes[2].plot(returns_data['capital_curve'].index, 
+-                returns_data['capital_curve'].values, 
+-                label='资金曲线', color='green')
+-    axes[2].set_title('资金曲线')
+-    axes[2].legend()
+-    axes[2].grid(True, alpha=0.3)
+-    
+-    plt.tight_layout()
+-    plt.savefig('ma_cross_strategy_results.png', dpi=300, bbox_inches='tight')
+-    plt.show()
+-
+-
+-def main():
+-    """
+-    主函数
+-    """
+-    print("开始运行均线交叉策略...")
+-    
+-    # 初始化qlib
+-    if not init_qlib():
+-        return
+-    
+-    # 策略参数
+-    start_date = "2020-01-01"
+-    end_date = "2023-12-31"
+-    short_window = 5
+-    long_window = 20
+-    initial_capital = 100000
+-    
+-    # 获取股票列表
+-    try:
+-        instruments = D.list_instruments(instruments="csi300", start_time=start_date, end_time=end_date)
+-        print(f"获取到 {len(instruments)} 只股票")
+-        
+-        # 选择前5只股票进行演示
+-        demo_instruments = instruments[:5]
+-        print(f"选择演示股票: {demo_instruments}")
+-        
+-    except Exception as e:
+-        print(f"获取股票列表失败: {e}")
+-        # 使用默认股票列表
+-        demo_instruments = ['000001.SZ', '000002.SZ', '000858.SZ', '002415.SZ', '600036.SH']
+-        print(f"使用默认股票列表: {demo_instruments}")
+-    
+-    # 获取价格数据
+-    data = get_stock_data(demo_instruments, start_date, end_date)
+-    
+-    if data is None:
+-        print("无法获取数据，程序退出")
+-        return
+-    
+-    print(f"获取到价格数据，形状: {data.shape}")
+-    
+-    # 计算均线信号
+-    signals = calculate_ma_signals(data, short_window, long_window)
+-    
+-    # 计算收益
+-    returns_data = calculate_returns(data, signals, initial_capital)
+-    
+-    # 分析策略
+-    analyze_strategy(signals, returns_data)
+-    
+-    # 保存结果
+-    signals.to_csv("ma_cross_signals.csv")
+-    returns_data['cumulative_returns'].to_csv("ma_cross_cumulative_returns.csv")
+-    returns_data['capital_curve'].to_csv("ma_cross_capital_curve.csv")
+-    
+-    print("\n结果已保存到CSV文件:")
+-    print("- ma_cross_signals.csv: 买卖信号")
+-    print("- ma_cross_cumulative_returns.csv: 累计收益")
+-    print("- ma_cross_capital_curve.csv: 资金曲线")
+-    
+-    # 绘制图表（选择第一只股票）
+-    if len(demo_instruments) > 0:
+-        try:
+-            plot_results(data, signals, returns_data, demo_instruments[0])
+-            print("图表已保存为 ma_cross_strategy_results.png")
+-        except Exception as e:
+-            print(f"绘制图表失败: {e}")
+-    
+-    print("\n策略回测完成！")
+-
+-
+-if __name__ == "__main__":
+-    main() 
+\ No newline at end of file
+diff --git a/test/two_ema_stragety.py b/test/two_ema_stragety.py
+index a72e7e8..a9890c7 100644
+--- a/test/two_ema_stragety.py
++++ b/test/two_ema_stragety.py
+@@ -1,2 +1,98 @@
+-from qlib.contrib.strategy import 
+-from qlib.backtest import backtest
+\ No newline at end of file
++import pandas as pd
++
++from abc import ABC
++from typing import Dict, List, Text, Tuple, Union
++from qlib.data.dataset import Dataset
++from qlib.model.base import BaseModel
++from qlib.backtest.signal import Signal, create_signal_from
++from qlib.strategy.base import BaseStrategy
++from qlib.backtest.decision import Order, OrderDir, OrderHelper, TradeDecisionWO
++# from qlib.strategy import 
++# from qlib.backtest import backtest
++
++class InnerStrategy(BaseStrategy):
++    """
++    Inner strategy for order execution:
++    - Buy: if price < 200, buy all cash; else buy 200,000 worth.
++    - Sell: if price > 200, sell all; else sell half.
++    """
++    STOCK_CODE = "000858.SZ"
++
++    def generate_trade_decision(self, execute_result: list = None, action: str = None, amount: float = None):
++        # action: 'buy' or 'sell', amount: suggested amount (shares) from outer
++        position = self.trade_position
++        trade_step = self.trade_calendar.get_trade_step()
++        trade_start_time, trade_end_time = self.trade_calendar.get_step_time(trade_step)
++        order_helper = self.trade_exchange.get_order_helper()
++        orders = []
++        price = self.trade_exchange.get_deal_price(self.STOCK_CODE, trade_start_time, trade_end_time)
++        if action == 'buy':
++            cash = position.get_cash()
++            if price <= 0:
++                return TradeDecisionWO([], self)
++            if price < 200:
++                buy_amount = cash // price
++            else:
++                buy_amount = min(cash // price, 200000 // price)
++            buy_amount = int(buy_amount)
++            if buy_amount > 0:
++                order = order_helper.create(
++                    code=self.STOCK_CODE,
++                    amount=buy_amount,
++                    direction=OrderDir.BUY,
++                    start_time=trade_start_time,
++                    end_time=trade_end_time,
++                )
++                orders.append(order)
++        elif action == 'sell':
++            held_amount = position.get_stock_amount(self.STOCK_CODE)
++            if held_amount <= 0 or price <= 0:
++                return TradeDecisionWO([], self)
++            if price > 200:
++                sell_amount = held_amount
++            else:
++                sell_amount = held_amount // 2
++            sell_amount = int(sell_amount)
++            if sell_amount > 0:
++                order = order_helper.create(
++                    code=self.STOCK_CODE,
++                    amount=sell_amount,
++                    direction=OrderDir.SELL,
++                    start_time=trade_start_time,
++                    end_time=trade_end_time,
++                )
++                orders.append(order)
++        return TradeDecisionWO(orders, self)
++
++class OuterStrategy(BaseStrategy):
++    """
++    Outer strategy:
++    - If not holding Wuliangye, issues a buy order via inner strategy.
++    - If holding, checks if held for 25 days, if so, issues a sell order via inner strategy.
++    - Otherwise, holds.
++    """
++    STOCK_CODE = "000858.SZ"
++    HOLD_DAYS = 25
++    BAR = "day"
++
++    def __init__(self, *args, **kwargs):
++        super().__init__(*args, **kwargs)
++        self.inner_strategy = InnerStrategy()
++
++    def generate_trade_decision(self, execute_result: list = None):
++        position = self.trade_position
++        stock_list = position.get_stock_list()
++        trade_step = self.trade_calendar.get_trade_step()
++        trade_start_time, trade_end_time = self.trade_calendar.get_step_time(trade_step)
++        # Pass infra to inner strategy
++        self.inner_strategy.reset(level_infra=self.level_infra, common_infra=self.common_infra)
++        if self.STOCK_CODE in stock_list:
++            hold_days = position.get_stock_count(self.STOCK_CODE, self.BAR)
++            if hold_days >= self.HOLD_DAYS:
++                # Sell via inner strategy
++                return self.inner_strategy.generate_trade_decision(action='sell')
++        else:
++            # Buy via inner strategy
++            return self.inner_strategy.generate_trade_decision(action='buy')
++        # Otherwise, hold
++        return TradeDecisionWO([], self)
+\ No newline at end of file
diff --git a/mlruns/812028854715931404/a784ffc1e7a244eeb797b751150b8fe2/artifacts/code_status.txt b/mlruns/812028854715931404/a784ffc1e7a244eeb797b751150b8fe2/artifacts/code_status.txt
new file mode 100644
index 0000000..ee86d81
--- /dev/null
+++ b/mlruns/812028854715931404/a784ffc1e7a244eeb797b751150b8fe2/artifacts/code_status.txt
@@ -0,0 +1,21 @@
+On branch main
+Your branch is up to date with 'origin/main'.
+
+Changes not staged for commit:
+  (use "git add/rm <file>..." to update what will be committed)
+  (use "git restore <file>..." to discard changes in working directory)
+	deleted:    test/README_MA_Strategy.md
+	deleted:    test/ma_cross_strategy.py
+	deleted:    test/ma_cross_strategy_improved.py
+	deleted:    test/ma_strategy_demo.py
+	deleted:    test/simple_ma_strategy.py
+	modified:   test/two_ema_stragety.py
+
+Untracked files:
+  (use "git add <file>..." to include in what will be committed)
+	mlruns/
+	test/__pycache__/
+	test/buy_and_hold.py
+	test/workflow_by_code.py
+
+no changes added to commit (use "git add" and/or "git commit -a")
diff --git a/mlruns/812028854715931404/a784ffc1e7a244eeb797b751150b8fe2/meta.yaml b/mlruns/812028854715931404/a784ffc1e7a244eeb797b751150b8fe2/meta.yaml
new file mode 100644
index 0000000..62e8a09
--- /dev/null
+++ b/mlruns/812028854715931404/a784ffc1e7a244eeb797b751150b8fe2/meta.yaml
@@ -0,0 +1,14 @@
+artifact_uri: file:D:\project\python\tradenote\mlruns/812028854715931404/a784ffc1e7a244eeb797b751150b8fe2/artifacts
+end_time: 1750314276988
+entry_point_name: ''
+experiment_id: '812028854715931404'
+lifecycle_stage: active
+run_id: a784ffc1e7a244eeb797b751150b8fe2
+run_name: mlflow_recorder
+source_name: ''
+source_type: 4
+source_version: ''
+start_time: 1750314276802
+status: 3
+tags: []
+user_id: abulimity
diff --git a/mlruns/812028854715931404/a784ffc1e7a244eeb797b751150b8fe2/params/cmd-sys.argv b/mlruns/812028854715931404/a784ffc1e7a244eeb797b751150b8fe2/params/cmd-sys.argv
new file mode 100644
index 0000000..db800eb
--- /dev/null
+++ b/mlruns/812028854715931404/a784ffc1e7a244eeb797b751150b8fe2/params/cmd-sys.argv
@@ -0,0 +1 @@
+D:\project\python\tradenote\test\workflow_by_code.py
\ No newline at end of file
diff --git a/mlruns/812028854715931404/a784ffc1e7a244eeb797b751150b8fe2/tags/mlflow.runName b/mlruns/812028854715931404/a784ffc1e7a244eeb797b751150b8fe2/tags/mlflow.runName
new file mode 100644
index 0000000..25487e4
--- /dev/null
+++ b/mlruns/812028854715931404/a784ffc1e7a244eeb797b751150b8fe2/tags/mlflow.runName
@@ -0,0 +1 @@
+mlflow_recorder
\ No newline at end of file
diff --git a/mlruns/812028854715931404/a784ffc1e7a244eeb797b751150b8fe2/tags/mlflow.source.git.commit b/mlruns/812028854715931404/a784ffc1e7a244eeb797b751150b8fe2/tags/mlflow.source.git.commit
new file mode 100644
index 0000000..288ce21
--- /dev/null
+++ b/mlruns/812028854715931404/a784ffc1e7a244eeb797b751150b8fe2/tags/mlflow.source.git.commit
@@ -0,0 +1 @@
+0daea9b5bbb40120a1bc07c702d171abc1f219c7
\ No newline at end of file
diff --git a/mlruns/812028854715931404/a784ffc1e7a244eeb797b751150b8fe2/tags/mlflow.source.name b/mlruns/812028854715931404/a784ffc1e7a244eeb797b751150b8fe2/tags/mlflow.source.name
new file mode 100644
index 0000000..db800eb
--- /dev/null
+++ b/mlruns/812028854715931404/a784ffc1e7a244eeb797b751150b8fe2/tags/mlflow.source.name
@@ -0,0 +1 @@
+D:\project\python\tradenote\test\workflow_by_code.py
\ No newline at end of file
diff --git a/mlruns/812028854715931404/a784ffc1e7a244eeb797b751150b8fe2/tags/mlflow.source.type b/mlruns/812028854715931404/a784ffc1e7a244eeb797b751150b8fe2/tags/mlflow.source.type
new file mode 100644
index 0000000..0c2c1fe
--- /dev/null
+++ b/mlruns/812028854715931404/a784ffc1e7a244eeb797b751150b8fe2/tags/mlflow.source.type
@@ -0,0 +1 @@
+LOCAL
\ No newline at end of file
diff --git a/mlruns/812028854715931404/a784ffc1e7a244eeb797b751150b8fe2/tags/mlflow.user b/mlruns/812028854715931404/a784ffc1e7a244eeb797b751150b8fe2/tags/mlflow.user
new file mode 100644
index 0000000..b9cec6f
--- /dev/null
+++ b/mlruns/812028854715931404/a784ffc1e7a244eeb797b751150b8fe2/tags/mlflow.user
@@ -0,0 +1 @@
+abulimity
\ No newline at end of file
diff --git a/mlruns/812028854715931404/ca4ee27d93794592827cc16b8355e682/artifacts/code_cached.txt b/mlruns/812028854715931404/ca4ee27d93794592827cc16b8355e682/artifacts/code_cached.txt
new file mode 100644
index 0000000..e69de29
diff --git a/mlruns/812028854715931404/ca4ee27d93794592827cc16b8355e682/artifacts/code_diff.txt b/mlruns/812028854715931404/ca4ee27d93794592827cc16b8355e682/artifacts/code_diff.txt
new file mode 100644
index 0000000..37c25d9
--- /dev/null
+++ b/mlruns/812028854715931404/ca4ee27d93794592827cc16b8355e682/artifacts/code_diff.txt
@@ -0,0 +1,1640 @@
+diff --git a/github/examples/benchmarks/LightGBM/workflow_config_lightgbm_Alpha1582.yaml b/github/examples/benchmarks/LightGBM/workflow_config_lightgbm_Alpha1582.yaml
+index 8b4e7bf..7a5eee7 100644
+--- a/github/examples/benchmarks/LightGBM/workflow_config_lightgbm_Alpha1582.yaml
++++ b/github/examples/benchmarks/LightGBM/workflow_config_lightgbm_Alpha1582.yaml
+@@ -1,5 +1,5 @@
+ qlib_init:
+-    provider_uri: "D:/project/tradenote/qlib_data/cn_data"
++    provider_uri: "D:/sync/qlib/qlib_data/cn_data"
+     region: cn
+ market: &market csi300
+ benchmark: &benchmark SH000300
+diff --git a/test/README_MA_Strategy.md b/test/README_MA_Strategy.md
+deleted file mode 100644
+index 5facaf7..0000000
+--- a/test/README_MA_Strategy.md
++++ /dev/null
+@@ -1,197 +0,0 @@
+-# 均线交叉策略 (Moving Average Crossover Strategy)
+-
+-## 策略概述
+-
+-这是一个基于qlib框架实现的均线交叉策略，核心逻辑是：
+-- **金叉买入**：短期均线上穿长期均线时买入
+-- **死叉卖出**：短期均线下穿长期均线时卖出
+-
+-## 文件说明
+-
+-### 1. `ma_cross_strategy.py`
+-完整的策略实现，包含：
+-- `MACrossStrategy` 类：继承自qlib的TopkDropoutStrategy
+-- 完整的回测框架
+-- 结果分析和保存
+-
+-### 2. `ma_cross_strategy_improved.py`
+-改进版本，包含：
+-- 更完善的数据获取逻辑
+-- 错误处理机制
+-- 简化版回测功能
+-
+-### 3. `simple_ma_strategy.py` ⭐ **推荐使用**
+-简单实用的版本，包含：
+-- 清晰的数据获取和处理
+-- 均线信号计算
+-- 收益计算和分析
+-- 可视化图表生成
+-- 结果保存功能
+-
+-## 使用方法
+-
+-### 环境准备
+-
+-1. 确保已安装qlib：
+-```bash
+-pip install pyqlib
+-```
+-
+-2. 下载qlib数据（如果还没有）：
+-```bash
+-# 下载中国股票数据
+-python -m qlib.data.dump_bin --csv_path ~/.qlib/qlib_data/cn_data --include_fields close,open,high,low,volume
+-```
+-
+-### 运行策略
+-
+-#### 方法1：运行简单版本（推荐）
+-```bash
+-cd test
+-python simple_ma_strategy.py
+-```
+-
+-#### 方法2：运行完整版本
+-```bash
+-cd test
+-python ma_cross_strategy.py
+-```
+-
+-#### 方法3：运行改进版本
+-```bash
+-cd test
+-python ma_cross_strategy_improved.py
+-```
+-
+-## 策略参数
+-
+-可以在代码中修改以下参数：
+-
+-```python
+-# 均线周期
+-short_window = 5    # 短期均线周期
+-long_window = 20    # 长期均线周期
+-
+-# 回测时间
+-start_date = "2020-01-01"
+-end_date = "2023-12-31"
+-
+-# 初始资金
+-initial_capital = 100000
+-
+-# 股票池
+-instruments = "csi300"  # 沪深300成分股
+-```
+-
+-## 输出结果
+-
+-运行策略后会生成以下文件：
+-
+-1. **CSV文件**：
+-   - `ma_cross_signals.csv`：买卖信号数据
+-   - `ma_cross_cumulative_returns.csv`：累计收益数据
+-   - `ma_cross_capital_curve.csv`：资金曲线数据
+-
+-2. **图表文件**：
+-   - `ma_cross_strategy_results.png`：策略结果可视化图表
+-
+-3. **控制台输出**：
+-   - 策略分析结果
+-   - 收益统计
+-   - 风险指标
+-
+-## 策略分析指标
+-
+-### 收益指标
+-- 总收益率
+-- 年化收益率
+-- 最终资金
+-
+-### 风险指标
+-- 年化波动率
+-- 夏普比率
+-- 胜率
+-- 最大回撤
+-
+-### 交易统计
+-- 买入信号数量
+-- 卖出信号数量
+-- 总交易次数
+-
+-## 策略逻辑详解
+-
+-### 1. 均线计算
+-```python
+-# 计算短期和长期均线
+-short_ma = price_data.rolling(window=short_window).mean()
+-long_ma = price_data.rolling(window=long_window).mean()
+-```
+-
+-### 2. 交叉信号判断
+-```python
+-# 计算均线差值
+-diff = short_ma - long_ma
+-
+-# 金叉：短期均线从下方穿越长期均线
+-if diff.iloc[i-1] < 0 and diff.iloc[i] > 0:
+-    signal = 1  # 买入信号
+-
+-# 死叉：短期均线从上方穿越长期均线
+-elif diff.iloc[i-1] > 0 and diff.iloc[i] < 0:
+-    signal = -1  # 卖出信号
+-```
+-
+-### 3. 收益计算
+-```python
+-# 策略收益（简化处理）
+-strategy_returns = signals * 0.01
+-
+-# 累计收益
+-cumulative_returns = strategy_returns.sum(axis=1).cumsum()
+-```
+-
+-## 注意事项
+-
+-1. **数据依赖**：确保qlib数据已正确下载和配置
+-2. **参数调优**：可以根据不同市场环境调整均线周期
+-3. **风险控制**：实际交易中需要加入止损和仓位管理
+-4. **交易成本**：当前版本未考虑交易费用，实际应用需要考虑
+-
+-## 扩展功能
+-
+-可以基于此策略进行以下扩展：
+-
+-1. **多均线策略**：使用多条均线进行更复杂的信号判断
+-2. **量价配合**：结合成交量指标优化信号
+-3. **止损机制**：添加动态止损策略
+-4. **仓位管理**：根据信号强度调整仓位大小
+-5. **多股票组合**：构建股票组合分散风险
+-
+-## 常见问题
+-
+-### Q: 如何修改股票池？
+-A: 在代码中修改 `instruments` 参数，例如：
+-```python
+-instruments = "csi500"  # 中证500
+-instruments = ["000001.SZ", "000002.SZ"]  # 指定股票列表
+-```
+-
+-### Q: 如何调整均线周期？
+-A: 修改 `short_window` 和 `long_window` 参数：
+-```python
+-short_window = 10  # 10日均线
+-long_window = 30   # 30日均线
+-```
+-
+-### Q: 如何查看详细的交易记录？
+-A: 查看生成的 `ma_cross_signals.csv` 文件，其中包含每日的买卖信号。
+-
+-## 联系方式
+-
+-如有问题或建议，请通过以下方式联系：
+-- 提交Issue到项目仓库
+-- 发送邮件到项目维护者
+-
+----
+-
+-**免责声明**：本策略仅供学习和研究使用，不构成投资建议。实际投资请谨慎决策，并承担相应风险。 
+\ No newline at end of file
+diff --git a/test/damo1.py b/test/damo1.py
+index 03102e1..8dadef5 100644
+--- a/test/damo1.py
++++ b/test/damo1.py
+@@ -1,9 +1,36 @@
+-# python scripts/get_data.py qlib_data --target_dir ../qlib_data/cn_data --region cn
+-
+ import qlib
+-# region in [REG_CN, REG_US]
+-from qlib.constant import REG_CN
+-provider_uri = "D:/project/tradenote/qlib_data/cn_data"  # target_dir
+-qlib.init(provider_uri=provider_uri, region=REG_CN)
++from qlib.data import D
++
++# 初始化 Qlib
++qlib.init(provider_uri="D:/project/python/tradenote/qlibz/qlib_data/cn_data", region="cn")
++
++# 检查目标股票和基准
++stock_code = "SZ000858"  # 你的BuyHold策略用的股票代码
++benchmark = "SH000300"
++
++print("--- 检查可用股票列表（前10只） ---")
++print("全部股票：", list(D.instruments(market="all")))
++
++print("--- 检查交易日（2017-01-01 ~ 2020-08-01，前10天） ---")
++print(D.calendar(start_time="2017-01-01", end_time="2020-08-01")[:10])
++
++print(f"--- 检查目标股票 {stock_code} 是否在股票池 ---")
++print(stock_code in D.instruments(market="all"))
++
++print(f"--- 检查基准 {benchmark} 是否在股票池 ---")
++print(benchmark in D.instruments(market="all"))
++
++print(f"--- 检查目标股票 {stock_code} 的行情数据（前5行） ---")
++try:
++    df = D.features([stock_code], ["$close", "$open", "$high", "$low", "$volume"], start_time="2017-01-01", end_time="2020-08-01")
++    print(df.head())
++except Exception as e:
++    print(f"获取行情数据失败: {e}")
+ 
+-# qrun benchmarks/LightGBM/workflow_config_lightgbm_Alpha1582.yaml
++print(f"--- 检查基准 {benchmark} 的行情数据（前5行） ---")
++try:
++    df_bench = D.features([benchmark], ["$close"], start_time="2017-01-01", end_time="2020-08-01")
++    print(df_bench.head())
++except Exception as e:
++    print(f"获取基准行情数据失败: {e}")
++# python scripts/get_data.py qlib_data --target_dir D:/project/python/tradenote/qlibz/qlib_data/cn_data --region cn
+\ No newline at end of file
+diff --git a/test/demo2.ipynb b/test/demo2.ipynb
+index 66a0215..842a49e 100644
+--- a/test/demo2.ipynb
++++ b/test/demo2.ipynb
+@@ -2,7 +2,7 @@
+  "cells": [
+   {
+    "cell_type": "code",
+-   "execution_count": 4,
++   "execution_count": 12,
+    "id": "6acb4a77",
+    "metadata": {},
+    "outputs": [
+@@ -10,39 +10,205 @@
+      "name": "stderr",
+      "output_type": "stream",
+      "text": [
+-      "[5344:MainThread](2025-06-18 14:41:03,895) INFO - qlib.Initialization - [config.py:420] - default_conf: client.\n",
+-      "[5344:MainThread](2025-06-18 14:41:03,900) INFO - qlib.Initialization - [__init__.py:74] - qlib successfully initialized based on client settings.\n",
+-      "[5344:MainThread](2025-06-18 14:41:03,903) INFO - qlib.Initialization - [__init__.py:76] - data_path={'__DEFAULT_FREQ': WindowsPath('D:/sync/qlib/qlib_data/cn_data')}\n"
++      "[13736:MainThread](2025-06-19 15:30:19,504) INFO - qlib.Initialization - [config.py:420] - default_conf: client.\n",
++      "[13736:MainThread](2025-06-19 15:30:19,506) INFO - qlib.Initialization - [__init__.py:74] - qlib successfully initialized based on client settings.\n",
++      "[13736:MainThread](2025-06-19 15:30:19,508) INFO - qlib.Initialization - [__init__.py:76] - data_path={'__DEFAULT_FREQ': WindowsPath('D:/sync/qlib/qlib_data/cn_data')}\n"
+      ]
+     }
+    ],
+    "source": [
+     "import qlib\n",
+-    "qlib.init(provider_uri=\"D:/sync/qlib/qlib_data/cn_data\", region=\"cn\")"
++    "qlib.init(provider_uri=r\"D:\\sync\\qlib\\qlib_data\\cn_data\", region=\"cn\")"
+    ]
+   },
+   {
+    "cell_type": "code",
+-   "execution_count": 12,
++   "execution_count": 14,
+    "id": "295df9af",
+    "metadata": {},
+    "outputs": [
+     {
+      "data": {
+       "text/plain": [
+-       "array([Timestamp('2020-09-21 00:00:00'), Timestamp('2020-09-22 00:00:00'),\n",
+-       "       Timestamp('2020-09-23 00:00:00'), Timestamp('2020-09-24 00:00:00'),\n",
+-       "       Timestamp('2020-09-25 00:00:00')], dtype=object)"
++       "array([Timestamp('2017-01-03 00:00:00'), Timestamp('2017-01-04 00:00:00'),\n",
++       "       Timestamp('2017-01-05 00:00:00'), Timestamp('2017-01-06 00:00:00'),\n",
++       "       Timestamp('2017-01-09 00:00:00')], dtype=object)"
+       ]
+      },
+-     "execution_count": 12,
++     "execution_count": 14,
+      "metadata": {},
+      "output_type": "execute_result"
+     }
+    ],
+    "source": [
+     "from qlib.data import D\n",
+-    "D.calendar(start_time='2020-09-21', end_time='2020-10-30', freq='day')"
++    "D.calendar(start_time=\"2017-01-01\", end_time=\"2020-08-01\",freq=\"day\")[:5]"
++   ]
++  },
++  {
++   "cell_type": "code",
++   "execution_count": 24,
++   "id": "da009afa",
++   "metadata": {},
++   "outputs": [
++    {
++     "data": {
++      "text/html": [
++       "<div>\n",
++       "<style scoped>\n",
++       "    .dataframe tbody tr th:only-of-type {\n",
++       "        vertical-align: middle;\n",
++       "    }\n",
++       "\n",
++       "    .dataframe tbody tr th {\n",
++       "        vertical-align: top;\n",
++       "    }\n",
++       "\n",
++       "    .dataframe thead th {\n",
++       "        text-align: right;\n",
++       "    }\n",
++       "</style>\n",
++       "<table border=\"1\" class=\"dataframe\">\n",
++       "  <thead>\n",
++       "    <tr style=\"text-align: right;\">\n",
++       "      <th></th>\n",
++       "      <th></th>\n",
++       "      <th>$close</th>\n",
++       "      <th>$open</th>\n",
++       "      <th>$high</th>\n",
++       "      <th>$low</th>\n",
++       "      <th>$volume</th>\n",
++       "    </tr>\n",
++       "    <tr>\n",
++       "      <th>instrument</th>\n",
++       "      <th>datetime</th>\n",
++       "      <th></th>\n",
++       "      <th></th>\n",
++       "      <th></th>\n",
++       "      <th></th>\n",
++       "      <th></th>\n",
++       "    </tr>\n",
++       "  </thead>\n",
++       "  <tbody>\n",
++       "    <tr>\n",
++       "      <th rowspan=\"11\" valign=\"top\">SZ000858</th>\n",
++       "      <th>2017-01-03</th>\n",
++       "      <td>11.301954</td>\n",
++       "      <td>11.243259</td>\n",
++       "      <td>11.373693</td>\n",
++       "      <td>11.184565</td>\n",
++       "      <td>47640796.0</td>\n",
++       "    </tr>\n",
++       "    <tr>\n",
++       "      <th>2017-01-04</th>\n",
++       "      <td>11.706295</td>\n",
++       "      <td>11.301954</td>\n",
++       "      <td>11.722599</td>\n",
++       "      <td>11.266086</td>\n",
++       "      <td>141233984.0</td>\n",
++       "    </tr>\n",
++       "    <tr>\n",
++       "      <th>2017-01-05</th>\n",
++       "      <td>11.716078</td>\n",
++       "      <td>11.748685</td>\n",
++       "      <td>11.817163</td>\n",
++       "      <td>11.641079</td>\n",
++       "      <td>79170360.0</td>\n",
++       "    </tr>\n",
++       "    <tr>\n",
++       "      <th>2017-01-06</th>\n",
++       "      <td>11.771510</td>\n",
++       "      <td>11.716077</td>\n",
++       "      <td>11.934550</td>\n",
++       "      <td>11.660643</td>\n",
++       "      <td>103201592.0</td>\n",
++       "    </tr>\n",
++       "    <tr>\n",
++       "      <th>2017-01-09</th>\n",
++       "      <td>11.885638</td>\n",
++       "      <td>11.738902</td>\n",
++       "      <td>11.999766</td>\n",
++       "      <td>11.716077</td>\n",
++       "      <td>81857808.0</td>\n",
++       "    </tr>\n",
++       "    <tr>\n",
++       "      <th>...</th>\n",
++       "      <td>...</td>\n",
++       "      <td>...</td>\n",
++       "      <td>...</td>\n",
++       "      <td>...</td>\n",
++       "      <td>...</td>\n",
++       "    </tr>\n",
++       "    <tr>\n",
++       "      <th>2020-07-27</th>\n",
++       "      <td>71.358727</td>\n",
++       "      <td>71.110489</td>\n",
++       "      <td>72.302719</td>\n",
++       "      <td>70.418228</td>\n",
++       "      <td>69948368.0</td>\n",
++       "    </tr>\n",
++       "    <tr>\n",
++       "      <th>2020-07-28</th>\n",
++       "      <td>74.816528</td>\n",
++       "      <td>71.984558</td>\n",
++       "      <td>75.847931</td>\n",
++       "      <td>71.558014</td>\n",
++       "      <td>108913296.0</td>\n",
++       "    </tr>\n",
++       "    <tr>\n",
++       "      <th>2020-07-29</th>\n",
++       "      <td>75.173149</td>\n",
++       "      <td>74.942398</td>\n",
++       "      <td>75.337471</td>\n",
++       "      <td>73.075386</td>\n",
++       "      <td>85012816.0</td>\n",
++       "    </tr>\n",
++       "    <tr>\n",
++       "      <th>2020-07-30</th>\n",
++       "      <td>75.704582</td>\n",
++       "      <td>74.820023</td>\n",
++       "      <td>76.236015</td>\n",
++       "      <td>74.470398</td>\n",
++       "      <td>71618128.0</td>\n",
++       "    </tr>\n",
++       "    <tr>\n",
++       "      <th>2020-07-31</th>\n",
++       "      <td>76.054207</td>\n",
++       "      <td>75.697586</td>\n",
++       "      <td>77.270905</td>\n",
++       "      <td>74.917923</td>\n",
++       "      <td>74252152.0</td>\n",
++       "    </tr>\n",
++       "  </tbody>\n",
++       "</table>\n",
++       "<p>871 rows × 5 columns</p>\n",
++       "</div>"
++      ],
++      "text/plain": [
++       "                          $close      $open      $high       $low      $volume\n",
++       "instrument datetime                                                           \n",
++       "SZ000858   2017-01-03  11.301954  11.243259  11.373693  11.184565   47640796.0\n",
++       "           2017-01-04  11.706295  11.301954  11.722599  11.266086  141233984.0\n",
++       "           2017-01-05  11.716078  11.748685  11.817163  11.641079   79170360.0\n",
++       "           2017-01-06  11.771510  11.716077  11.934550  11.660643  103201592.0\n",
++       "           2017-01-09  11.885638  11.738902  11.999766  11.716077   81857808.0\n",
++       "...                          ...        ...        ...        ...          ...\n",
++       "           2020-07-27  71.358727  71.110489  72.302719  70.418228   69948368.0\n",
++       "           2020-07-28  74.816528  71.984558  75.847931  71.558014  108913296.0\n",
++       "           2020-07-29  75.173149  74.942398  75.337471  73.075386   85012816.0\n",
++       "           2020-07-30  75.704582  74.820023  76.236015  74.470398   71618128.0\n",
++       "           2020-07-31  76.054207  75.697586  77.270905  74.917923   74252152.0\n",
++       "\n",
++       "[871 rows x 5 columns]"
++      ]
++     },
++     "execution_count": 24,
++     "metadata": {},
++     "output_type": "execute_result"
++    }
++   ],
++   "source": [
++    "D.features([\"SZ000858\"], [\"$close\", \"$open\", \"$high\", \"$low\", \"$volume\"], start_time=\"2017-01-01\", end_time=\"2020-08-01\")"
+    ]
+   }
+  ],
+diff --git a/test/ma_cross_strategy.py b/test/ma_cross_strategy.py
+deleted file mode 100644
+index 719d849..0000000
+--- a/test/ma_cross_strategy.py
++++ /dev/null
+@@ -1,274 +0,0 @@
+-"""
+-均线交叉策略：金叉买入，死叉卖出
+-使用qlib框架实现
+-"""
+-
+-import qlib
+-from qlib.constant import REG_CN
+-from qlib.utils import init_instance_by_config
+-from qlib.workflow import R
+-from qlib.workflow.record_temp import SignalRecord, PortAnaRecord
+-from qlib.contrib.evaluate import backtest_daily
+-from qlib.contrib.strategy import TopkDropoutStrategy
+-import pandas as pd
+-import numpy as np
+-from typing import Dict, List, Tuple
+-
+-
+-class MACrossStrategy(TopkDropoutStrategy):
+-    """
+-    均线交叉策略
+-    金叉（短期均线上穿长期均线）买入
+-    死叉（短期均线下穿长期均线）卖出
+-    """
+-    
+-    def __init__(self, 
+-                 short_window: int = 5,
+-                 long_window: int = 20,
+-                 topk: int = 50,
+-                 n_drop: int = 5,
+-                 **kwargs):
+-        """
+-        初始化策略参数
+-        
+-        Args:
+-            short_window: 短期均线周期
+-            long_window: 长期均线周期
+-            topk: 选择前k只股票
+-            n_drop: 剔除前n只股票
+-        """
+-        super().__init__(topk=topk, n_drop=n_drop, **kwargs)
+-        self.short_window = short_window
+-        self.long_window = long_window
+-        
+-    def generate_trade_decision(self, score: pd.Series, trade_step: int) -> pd.Series:
+-        """
+-        生成交易决策
+-        
+-        Args:
+-            score: 股票评分
+-            trade_step: 交易步骤
+-            
+-        Returns:
+-            交易决策，1表示买入，-1表示卖出，0表示持有
+-        """
+-        # 获取当前持仓
+-        current_pos = self.get_current_position()
+-        
+-        # 计算均线信号
+-        signal = self._calculate_ma_signal(score.index.tolist(), trade_step)
+-        
+-        # 生成交易决策
+-        decision = pd.Series(0, index=score.index)
+-        
+-        # 金叉买入信号
+-        buy_signal = signal == 1
+-        decision[buy_signal] = 1
+-        
+-        # 死叉卖出信号
+-        sell_signal = signal == -1
+-        decision[sell_signal] = -1
+-        
+-        return decision
+-    
+-    def _calculate_ma_signal(self, instruments: List[str], trade_step: int) -> pd.Series:
+-        """
+-        计算均线交叉信号
+-        
+-        Args:
+-            instruments: 股票代码列表
+-            trade_step: 交易步骤
+-            
+-        Returns:
+-            信号序列：1表示金叉买入，-1表示死叉卖出，0表示无信号
+-        """
+-        # 获取历史数据
+-        data = self._get_historical_data(instruments, trade_step)
+-        
+-        signals = pd.Series(0, index=instruments)
+-        
+-        for instrument in instruments:
+-            if instrument in data.index:
+-                # 计算短期和长期均线
+-                short_ma = data.loc[instrument].rolling(window=self.short_window).mean()
+-                long_ma = data.loc[instrument].rolling(window=self.long_window).mean()
+-                
+-                # 计算交叉信号
+-                if len(short_ma) >= 2 and len(long_ma) >= 2:
+-                    # 当前和前一个时间点的均线差值
+-                    current_diff = short_ma.iloc[-1] - long_ma.iloc[-1]
+-                    prev_diff = short_ma.iloc[-2] - long_ma.iloc[-2]
+-                    
+-                    # 金叉：短期均线从下方穿越长期均线
+-                    if prev_diff < 0 and current_diff > 0:
+-                        signals[instrument] = 1
+-                    # 死叉：短期均线从上方穿越长期均线
+-                    elif prev_diff > 0 and current_diff < 0:
+-                        signals[instrument] = -1
+-        
+-        return signals
+-    
+-    def _get_historical_data(self, instruments: List[str], trade_step: int) -> pd.DataFrame:
+-        """
+-        获取历史价格数据
+-        
+-        Args:
+-            instruments: 股票代码列表
+-            trade_step: 交易步骤
+-            
+-        Returns:
+-            历史价格数据
+-        """
+-        # 这里简化处理，实际应该从qlib数据源获取
+-        # 在实际应用中，您需要使用qlib的数据接口
+-        try:
+-            # 获取最近的数据用于计算均线
+-            # 这里使用模拟数据，实际应该从qlib获取
+-            dates = pd.date_range(end=pd.Timestamp.now(), periods=50, freq='D')
+-            data = pd.DataFrame(
+-                np.random.randn(len(dates), len(instruments)) * 0.02 + 1.0,
+-                index=dates,
+-                columns=instruments
+-            )
+-            return data
+-        except Exception as e:
+-            print(f"获取历史数据失败: {e}")
+-            return pd.DataFrame()
+-
+-
+-def create_ma_cross_strategy_config():
+-    """
+-    创建均线交叉策略配置
+-    """
+-    strategy_config = {
+-        "class": "MACrossStrategy",
+-        "module_path": "test.ma_cross_strategy",
+-        "kwargs": {
+-            "short_window": 5,
+-            "long_window": 20,
+-            "topk": 50,
+-            "n_drop": 5,
+-        }
+-    }
+-    
+-    return strategy_config
+-
+-
+-def run_backtest():
+-    """
+-    运行回测
+-    """
+-    # 初始化qlib
+-    qlib.init(provider_uri='~/.qlib/qlib_data/cn_data', region=REG_CN)
+-    
+-    # 策略配置
+-    strategy_config = create_ma_cross_strategy_config()
+-    
+-    # 回测配置
+-    backtest_config = {
+-        "start_time": "2020-01-01",
+-        "end_time": "2023-12-31",
+-        "benchmark": "SH000300",  # 沪深300作为基准
+-        "account": 100000000,     # 初始资金1亿
+-        "exchange_kwargs": {
+-            "freq": "day",
+-            "limit_threshold": 0.095,
+-            "deal_price": "close",
+-            "open_cost": 0.0005,
+-            "close_cost": 0.0015,
+-            "min_cost": 5,
+-        }
+-    }
+-    
+-    # 创建策略实例
+-    strategy = init_instance_by_config(strategy_config)
+-    
+-    # 运行回测
+-    with R.start(experiment_name="ma_cross_strategy"):
+-        # 记录信号
+-        sr = SignalRecord(model=strategy, dataset=None, recorder=R.get_recorder())
+-        sr.generate()
+-        
+-        # 记录投资组合分析
+-        par = PortAnaRecord(recorder=R.get_recorder(), config=backtest_config, strategy=strategy)
+-        par.generate()
+-        
+-        # 获取回测结果
+-        report_normal, positions_normal = backtest_daily(
+-            account=backtest_config["account"],
+-            benchmark=backtest_config["benchmark"],
+-            start_time=backtest_config["start_time"],
+-            end_time=backtest_config["end_time"],
+-            strategy=strategy,
+-            exchange_kwargs=backtest_config["exchange_kwargs"]
+-        )
+-        
+-        return report_normal, positions_normal
+-
+-
+-def analyze_results(report: pd.DataFrame, positions: pd.DataFrame):
+-    """
+-    分析回测结果
+-    
+-    Args:
+-        report: 回测报告
+-        positions: 持仓信息
+-    """
+-    print("=" * 50)
+-    print("均线交叉策略回测结果")
+-    print("=" * 50)
+-    
+-    # 基本统计信息
+-    print(f"总收益率: {report['return'].sum():.2%}")
+-    print(f"年化收益率: {report['return'].mean() * 252:.2%}")
+-    print(f"最大回撤: {report['drawdown'].min():.2%}")
+-    print(f"夏普比率: {report['sharpe'].iloc[-1]:.2f}")
+-    print(f"胜率: {(report['return'] > 0).mean():.2%}")
+-    
+-    # 风险指标
+-    volatility = report['return'].std() * np.sqrt(252)
+-    print(f"年化波动率: {volatility:.2%}")
+-    
+-    # 最大回撤期间
+-    max_drawdown_idx = report['drawdown'].idxmin()
+-    print(f"最大回撤发生时间: {max_drawdown_idx}")
+-    
+-    # 收益分布
+-    print("\n收益分布统计:")
+-    print(f"平均日收益: {report['return'].mean():.2%}")
+-    print(f"收益标准差: {report['return'].std():.2%}")
+-    print(f"最小日收益: {report['return'].min():.2%}")
+-    print(f"最大日收益: {report['return'].max():.2%}")
+-    
+-    # 交易统计
+-    if 'trade_count' in report.columns:
+-        print(f"\n总交易次数: {report['trade_count'].sum()}")
+-        print(f"平均每日交易次数: {report['trade_count'].mean():.1f}")
+-
+-
+-def main():
+-    """
+-    主函数
+-    """
+-    print("开始运行均线交叉策略回测...")
+-    
+-    try:
+-        # 运行回测
+-        report, positions = run_backtest()
+-        
+-        # 分析结果
+-        analyze_results(report, positions)
+-        
+-        # 保存结果
+-        report.to_csv("ma_cross_strategy_report.csv")
+-        positions.to_csv("ma_cross_strategy_positions.csv")
+-        
+-        print("\n回测完成！结果已保存到CSV文件。")
+-        
+-    except Exception as e:
+-        print(f"回测过程中出现错误: {e}")
+-        print("请确保已正确安装qlib并下载了相应的数据。")
+-
+-
+-if __name__ == "__main__":
+-    main() 
+\ No newline at end of file
+diff --git a/test/ma_cross_strategy_improved.py b/test/ma_cross_strategy_improved.py
+deleted file mode 100644
+index d166c68..0000000
+--- a/test/ma_cross_strategy_improved.py
++++ /dev/null
+@@ -1,443 +0,0 @@
+-"""
+-改进的均线交叉策略：金叉买入，死叉卖出
+-使用qlib框架实现，包含完整的数据获取和信号计算
+-"""
+-
+-import qlib
+-from qlib.constant import REG_CN
+-from qlib.utils import init_instance_by_config
+-from qlib.workflow import R
+-from qlib.workflow.record_temp import SignalRecord, PortAnaRecord
+-from qlib.contrib.evaluate import backtest_daily
+-from qlib.contrib.strategy import TopkDropoutStrategy
+-from qlib.data import D
+-from qlib.data.dataset import DatasetH
+-from qlib.data.dataset.handler import DataHandlerLP
+-import pandas as pd
+-import numpy as np
+-from typing import Dict, List, Tuple
+-import warnings
+-warnings.filterwarnings('ignore')
+-
+-
+-class MACrossStrategyImproved(TopkDropoutStrategy):
+-    """
+-    改进的均线交叉策略
+-    金叉（短期均线上穿长期均线）买入
+-    死叉（短期均线下穿长期均线）卖出
+-    """
+-    
+-    def __init__(self, 
+-                 short_window: int = 5,
+-                 long_window: int = 20,
+-                 topk: int = 50,
+-                 n_drop: int = 5,
+-                 universe: str = "csi300",
+-                 **kwargs):
+-        """
+-        初始化策略参数
+-        
+-        Args:
+-            short_window: 短期均线周期
+-            long_window: 长期均线周期
+-            topk: 选择前k只股票
+-            n_drop: 剔除前n只股票
+-            universe: 股票池
+-        """
+-        super().__init__(topk=topk, n_drop=n_drop, **kwargs)
+-        self.short_window = short_window
+-        self.long_window = long_window
+-        self.universe = universe
+-        self.instruments = None
+-        self.price_cache = {}
+-        
+-    def generate_trade_decision(self, score: pd.Series, trade_step: int) -> pd.Series:
+-        """
+-        生成交易决策
+-        
+-        Args:
+-            score: 股票评分
+-            trade_step: 交易步骤
+-            
+-        Returns:
+-            交易决策，1表示买入，-1表示卖出，0表示持有
+-        """
+-        # 获取当前持仓
+-        current_pos = self.get_current_position()
+-        
+-        # 计算均线信号
+-        signal = self._calculate_ma_signal(score.index.tolist(), trade_step)
+-        
+-        # 生成交易决策
+-        decision = pd.Series(0, index=score.index)
+-        
+-        # 金叉买入信号
+-        buy_signal = signal == 1
+-        decision[buy_signal] = 1
+-        
+-        # 死叉卖出信号
+-        sell_signal = signal == -1
+-        decision[sell_signal] = -1
+-        
+-        return decision
+-    
+-    def _calculate_ma_signal(self, instruments: List[str], trade_step: int) -> pd.Series:
+-        """
+-        计算均线交叉信号
+-        
+-        Args:
+-            instruments: 股票代码列表
+-            trade_step: 交易步骤
+-            
+-        Returns:
+-            信号序列：1表示金叉买入，-1表示死叉卖出，0表示无信号
+-        """
+-        signals = pd.Series(0, index=instruments)
+-        
+-        # 获取当前日期
+-        current_date = self._get_current_date(trade_step)
+-        
+-        for instrument in instruments:
+-            try:
+-                # 获取历史价格数据
+-                price_data = self._get_price_data(instrument, current_date)
+-                
+-                if price_data is not None and len(price_data) >= self.long_window:
+-                    # 计算短期和长期均线
+-                    short_ma = price_data['close'].rolling(window=self.short_window).mean()
+-                    long_ma = price_data['close'].rolling(window=self.long_window).mean()
+-                    
+-                    # 计算交叉信号
+-                    if len(short_ma) >= 2 and len(long_ma) >= 2:
+-                        # 当前和前一个时间点的均线差值
+-                        current_diff = short_ma.iloc[-1] - long_ma.iloc[-1]
+-                        prev_diff = short_ma.iloc[-2] - long_ma.iloc[-2]
+-                        
+-                        # 金叉：短期均线从下方穿越长期均线
+-                        if prev_diff < 0 and current_diff > 0:
+-                            signals[instrument] = 1
+-                        # 死叉：短期均线从上方穿越长期均线
+-                        elif prev_diff > 0 and current_diff < 0:
+-                            signals[instrument] = -1
+-                            
+-            except Exception as e:
+-                print(f"计算{instrument}均线信号时出错: {e}")
+-                continue
+-        
+-        return signals
+-    
+-    def _get_price_data(self, instrument: str, current_date: str) -> pd.DataFrame:
+-        """
+-        获取股票价格数据
+-        
+-        Args:
+-            instrument: 股票代码
+-            current_date: 当前日期
+-            
+-        Returns:
+-            价格数据DataFrame
+-        """
+-        try:
+-            # 计算开始日期（获取足够的历史数据来计算均线）
+-            start_date = pd.Timestamp(current_date) - pd.Timedelta(days=self.long_window * 2)
+-            
+-            # 从qlib获取数据
+-            data = D.features(
+-                instruments=[instrument],
+-                start_time=start_date.strftime('%Y-%m-%d'),
+-                end_time=current_date,
+-                freq='day',
+-                fields=['$close', '$open', '$high', '$low', '$volume']
+-            )
+-            
+-            if data is not None and not data.empty:
+-                # 重命名列
+-                data.columns = ['close', 'open', 'high', 'low', 'volume']
+-                return data
+-            else:
+-                return None
+-                
+-        except Exception as e:
+-            print(f"获取{instrument}价格数据失败: {e}")
+-            return None
+-    
+-    def _get_current_date(self, trade_step: int) -> str:
+-        """
+-        根据交易步骤获取当前日期
+-        
+-        Args:
+-            trade_step: 交易步骤
+-            
+-        Returns:
+-            当前日期字符串
+-        """
+-        # 这里简化处理，实际应该从qlib的日历获取
+-        # 假设从2020-01-01开始，每个trade_step代表一天
+-        start_date = pd.Timestamp('2020-01-01')
+-        current_date = start_date + pd.Timedelta(days=trade_step)
+-        return current_date.strftime('%Y-%m-%d')
+-
+-
+-def create_dataset_config():
+-    """
+-    创建数据集配置
+-    """
+-    dataset_config = {
+-        "class": "DatasetH",
+-        "module_path": "qlib.data.dataset",
+-        "kwargs": {
+-            "handler": {
+-                "class": "DataHandlerLP",
+-                "module_path": "qlib.data.dataset.handler",
+-                "kwargs": {
+-                    "start_time": "2020-01-01",
+-                    "end_time": "2023-12-31",
+-                    "fit_start_time": "2020-01-01",
+-                    "fit_end_time": "2023-12-31",
+-                    "instruments": "csi300",
+-                    "infer_processors": [
+-                        {
+-                            "class": "RobustZScoreNorm",
+-                            "module_path": "qlib.data.dataset.processor",
+-                            "kwargs": {
+-                                "fields_group": "feature",
+-                                "clip_outlier": True,
+-                            },
+-                        },
+-                        {
+-                            "class": "Fillna",
+-                            "module_path": "qlib.data.dataset.processor",
+-                            "kwargs": {
+-                                "fields_group": "feature",
+-                            },
+-                        },
+-                    ],
+-                    "learn_processors": [
+-                        {
+-                            "class": "DropnaLabel",
+-                            "module_path": "qlib.data.dataset.processor",
+-                        },
+-                        {
+-                            "class": "CSRankNorm",
+-                            "module_path": "qlib.data.dataset.processor",
+-                            "kwargs": {
+-                                "fields_group": "label",
+-                            },
+-                        },
+-                    ],
+-                    "instruments": "csi300",
+-                },
+-            },
+-            "segments": {
+-                "train": ("2020-01-01", "2022-12-31"),
+-                "valid": ("2023-01-01", "2023-06-30"),
+-                "test": ("2023-07-01", "2023-12-31"),
+-            },
+-        },
+-    }
+-    
+-    return dataset_config
+-
+-
+-def create_ma_cross_strategy_config():
+-    """
+-    创建均线交叉策略配置
+-    """
+-    strategy_config = {
+-        "class": "MACrossStrategyImproved",
+-        "module_path": "test.ma_cross_strategy_improved",
+-        "kwargs": {
+-            "short_window": 5,
+-            "long_window": 20,
+-            "topk": 50,
+-            "n_drop": 5,
+-            "universe": "csi300",
+-        }
+-    }
+-    
+-    return strategy_config
+-
+-
+-def run_backtest():
+-    """
+-    运行回测
+-    """
+-    # 初始化qlib
+-    qlib.init(provider_uri='~/.qlib/qlib_data/cn_data', region=REG_CN)
+-    
+-    # 策略配置
+-    strategy_config = create_ma_cross_strategy_config()
+-    
+-    # 回测配置
+-    backtest_config = {
+-        "start_time": "2020-01-01",
+-        "end_time": "2023-12-31",
+-        "benchmark": "SH000300",  # 沪深300作为基准
+-        "account": 100000000,     # 初始资金1亿
+-        "exchange_kwargs": {
+-            "freq": "day",
+-            "limit_threshold": 0.095,
+-            "deal_price": "close",
+-            "open_cost": 0.0005,
+-            "close_cost": 0.0015,
+-            "min_cost": 5,
+-        }
+-    }
+-    
+-    # 创建策略实例
+-    strategy = init_instance_by_config(strategy_config)
+-    
+-    # 运行回测
+-    with R.start(experiment_name="ma_cross_strategy_improved"):
+-        # 记录信号
+-        sr = SignalRecord(model=strategy, dataset=None, recorder=R.get_recorder())
+-        sr.generate()
+-        
+-        # 记录投资组合分析
+-        par = PortAnaRecord(recorder=R.get_recorder(), config=backtest_config, strategy=strategy)
+-        par.generate()
+-        
+-        # 获取回测结果
+-        report_normal, positions_normal = backtest_daily(
+-            account=backtest_config["account"],
+-            benchmark=backtest_config["benchmark"],
+-            start_time=backtest_config["start_time"],
+-            end_time=backtest_config["end_time"],
+-            strategy=strategy,
+-            exchange_kwargs=backtest_config["exchange_kwargs"]
+-        )
+-        
+-        return report_normal, positions_normal
+-
+-
+-def analyze_results(report: pd.DataFrame, positions: pd.DataFrame):
+-    """
+-    分析回测结果
+-    
+-    Args:
+-        report: 回测报告
+-        positions: 持仓信息
+-    """
+-    print("=" * 50)
+-    print("均线交叉策略回测结果")
+-    print("=" * 50)
+-    
+-    # 基本统计信息
+-    print(f"总收益率: {report['return'].sum():.2%}")
+-    print(f"年化收益率: {report['return'].mean() * 252:.2%}")
+-    print(f"最大回撤: {report['drawdown'].min():.2%}")
+-    
+-    if 'sharpe' in report.columns:
+-        print(f"夏普比率: {report['sharpe'].iloc[-1]:.2f}")
+-    
+-    print(f"胜率: {(report['return'] > 0).mean():.2%}")
+-    
+-    # 风险指标
+-    volatility = report['return'].std() * np.sqrt(252)
+-    print(f"年化波动率: {volatility:.2%}")
+-    
+-    # 最大回撤期间
+-    max_drawdown_idx = report['drawdown'].idxmin()
+-    print(f"最大回撤发生时间: {max_drawdown_idx}")
+-    
+-    # 收益分布
+-    print("\n收益分布统计:")
+-    print(f"平均日收益: {report['return'].mean():.2%}")
+-    print(f"收益标准差: {report['return'].std():.2%}")
+-    print(f"最小日收益: {report['return'].min():.2%}")
+-    print(f"最大日收益: {report['return'].max():.2%}")
+-    
+-    # 交易统计
+-    if 'trade_count' in report.columns:
+-        print(f"\n总交易次数: {report['trade_count'].sum()}")
+-        print(f"平均每日交易次数: {report['trade_count'].mean():.1f}")
+-
+-
+-def create_simple_backtest():
+-    """
+-    创建简化版回测，用于演示
+-    """
+-    print("创建简化版均线交叉策略回测...")
+-    
+-    # 初始化qlib
+-    qlib.init(provider_uri='~/.qlib/qlib_data/cn_data', region=REG_CN)
+-    
+-    # 获取股票列表
+-    instruments = D.list_instruments(instruments="csi300", start_time="2020-01-01", end_time="2023-12-31")
+-    
+-    print(f"获取到 {len(instruments)} 只股票")
+-    
+-    # 选择前10只股票进行演示
+-    demo_instruments = instruments[:10]
+-    
+-    # 获取价格数据
+-    data = D.features(
+-        instruments=demo_instruments,
+-        start_time="2020-01-01",
+-        end_time="2023-12-31",
+-        freq='day',
+-        fields=['$close']
+-    )
+-    
+-    print(f"获取到价格数据，形状: {data.shape}")
+-    
+-    # 计算均线
+-    short_ma = data.rolling(window=5).mean()
+-    long_ma = data.rolling(window=20).mean()
+-    
+-    # 计算交叉信号
+-    signals = pd.DataFrame(0, index=data.index, columns=data.columns)
+-    
+-    for col in data.columns:
+-        # 计算均线差值
+-        diff = short_ma[col] - long_ma[col]
+-        
+-        # 计算交叉信号
+-        for i in range(1, len(diff)):
+-            if diff.iloc[i-1] < 0 and diff.iloc[i] > 0:
+-                signals.iloc[i, signals.columns.get_loc(col)] = 1  # 金叉买入
+-            elif diff.iloc[i-1] > 0 and diff.iloc[i] < 0:
+-                signals.iloc[i, signals.columns.get_loc(col)] = -1  # 死叉卖出
+-    
+-    # 统计信号
+-    buy_signals = (signals == 1).sum().sum()
+-    sell_signals = (signals == -1).sum().sum()
+-    
+-    print(f"\n信号统计:")
+-    print(f"买入信号数量: {buy_signals}")
+-    print(f"卖出信号数量: {sell_signals}")
+-    
+-    # 计算简单收益（假设每次信号都产生1%的收益）
+-    returns = signals * 0.01
+-    cumulative_returns = returns.sum(axis=1).cumsum()
+-    
+-    print(f"\n累计收益: {cumulative_returns.iloc[-1]:.2%}")
+-    
+-    return signals, cumulative_returns
+-
+-
+-def main():
+-    """
+-    主函数
+-    """
+-    print("开始运行均线交叉策略回测...")
+-    
+-    try:
+-        # 运行简化版回测
+-        signals, cumulative_returns = create_simple_backtest()
+-        
+-        # 保存简化版结果
+-        signals.to_csv("ma_cross_signals.csv")
+-        cumulative_returns.to_csv("ma_cross_cumulative_returns.csv")
+-        
+-        print("\n简化版回测完成！")
+-        print("信号数据已保存到 ma_cross_signals.csv")
+-        print("累计收益已保存到 ma_cross_cumulative_returns.csv")
+-        
+-    except Exception as e:
+-        print(f"回测过程中出现错误: {e}")
+-        print("请确保已正确安装qlib并下载了相应的数据。")
+-
+-
+-if __name__ == "__main__":
+-    main() 
+\ No newline at end of file
+diff --git a/test/ma_strategy_demo.py b/test/ma_strategy_demo.py
+deleted file mode 100644
+index 1fa4fb4..0000000
+Binary files a/test/ma_strategy_demo.py and /dev/null differ
+diff --git a/test/simple_ma_strategy.py b/test/simple_ma_strategy.py
+deleted file mode 100644
+index 8d03f6b..0000000
+--- a/test/simple_ma_strategy.py
++++ /dev/null
+@@ -1,298 +0,0 @@
+-"""
+-简单实用的均线交叉策略
+-金叉买入，死叉卖出
+-"""
+-
+-import qlib
+-from qlib.constant import REG_CN
+-from qlib.data import D
+-import pandas as pd
+-import numpy as np
+-import matplotlib.pyplot as plt
+-from datetime import datetime, timedelta
+-
+-
+-def init_qlib():
+-    """初始化qlib"""
+-    try:
+-        qlib.init(provider_uri='~/.qlib/qlib_data/cn_data', region=REG_CN)
+-        print("qlib初始化成功")
+-        return True
+-    except Exception as e:
+-        print(f"qlib初始化失败: {e}")
+-        print("请确保已安装qlib并下载了数据")
+-        return False
+-
+-
+-def get_stock_data(instruments, start_date, end_date):
+-    """
+-    获取股票数据
+-    
+-    Args:
+-        instruments: 股票代码列表
+-        start_date: 开始日期
+-        end_date: 结束日期
+-    
+-    Returns:
+-        股票价格数据
+-    """
+-    try:
+-        data = D.features(
+-            instruments=instruments,
+-            start_time=start_date,
+-            end_time=end_date,
+-            freq='day',
+-            fields=['$close', '$open', '$high', '$low', '$volume']
+-        )
+-        
+-        if data is not None and not data.empty:
+-            # 重命名列
+-            data.columns = ['close', 'open', 'high', 'low', 'volume']
+-            return data
+-        else:
+-            print("未获取到数据")
+-            return None
+-            
+-    except Exception as e:
+-        print(f"获取数据失败: {e}")
+-        return None
+-
+-
+-def calculate_ma_signals(data, short_window=5, long_window=20):
+-    """
+-    计算均线交叉信号
+-    
+-    Args:
+-        data: 价格数据
+-        short_window: 短期均线周期
+-        long_window: 长期均线周期
+-    
+-    Returns:
+-        信号DataFrame，1表示买入，-1表示卖出，0表示无信号
+-    """
+-    signals = pd.DataFrame(0, index=data.index, columns=data.columns)
+-    
+-    for col in data.columns:
+-        if col == 'close':
+-            continue
+-            
+-        # 计算均线
+-        short_ma = data[col].rolling(window=short_window).mean()
+-        long_ma = data[col].rolling(window=long_window).mean()
+-        
+-        # 计算均线差值
+-        diff = short_ma - long_ma
+-        
+-        # 计算交叉信号
+-        for i in range(1, len(diff)):
+-            if pd.notna(diff.iloc[i-1]) and pd.notna(diff.iloc[i]):
+-                # 金叉：短期均线从下方穿越长期均线
+-                if diff.iloc[i-1] < 0 and diff.iloc[i] > 0:
+-                    signals.iloc[i, signals.columns.get_loc(col)] = 1
+-                # 死叉：短期均线从上方穿越长期均线
+-                elif diff.iloc[i-1] > 0 and diff.iloc[i] < 0:
+-                    signals.iloc[i, signals.columns.get_loc(col)] = -1
+-    
+-    return signals
+-
+-
+-def calculate_returns(data, signals, initial_capital=100000):
+-    """
+-    计算策略收益
+-    
+-    Args:
+-        data: 价格数据
+-        signals: 信号数据
+-        initial_capital: 初始资金
+-    
+-    Returns:
+-        收益数据
+-    """
+-    # 计算日收益率
+-    returns = data.pct_change()
+-    
+-    # 策略收益（假设每次信号产生1%的收益）
+-    strategy_returns = signals * 0.01
+-    
+-    # 累计收益
+-    cumulative_returns = strategy_returns.sum(axis=1).cumsum()
+-    
+-    # 资金曲线
+-    capital_curve = initial_capital * (1 + cumulative_returns)
+-    
+-    return {
+-        'strategy_returns': strategy_returns,
+-        'cumulative_returns': cumulative_returns,
+-        'capital_curve': capital_curve
+-    }
+-
+-
+-def analyze_strategy(signals, returns_data):
+-    """
+-    分析策略表现
+-    
+-    Args:
+-        signals: 信号数据
+-        returns_data: 收益数据
+-    """
+-    print("=" * 50)
+-    print("均线交叉策略分析结果")
+-    print("=" * 50)
+-    
+-    # 信号统计
+-    buy_signals = (signals == 1).sum().sum()
+-    sell_signals = (signals == -1).sum().sum()
+-    
+-    print(f"买入信号数量: {buy_signals}")
+-    print(f"卖出信号数量: {sell_signals}")
+-    print(f"总信号数量: {buy_signals + sell_signals}")
+-    
+-    # 收益统计
+-    cumulative_returns = returns_data['cumulative_returns']
+-    capital_curve = returns_data['capital_curve']
+-    
+-    total_return = cumulative_returns.iloc[-1]
+-    annual_return = total_return / (len(cumulative_returns) / 252)
+-    
+-    print(f"\n收益统计:")
+-    print(f"总收益率: {total_return:.2%}")
+-    print(f"年化收益率: {annual_return:.2%}")
+-    print(f"最终资金: {capital_curve.iloc[-1]:,.0f}")
+-    
+-    # 风险统计
+-    daily_returns = returns_data['strategy_returns'].sum(axis=1)
+-    volatility = daily_returns.std() * np.sqrt(252)
+-    sharpe_ratio = annual_return / volatility if volatility > 0 else 0
+-    
+-    print(f"\n风险统计:")
+-    print(f"年化波动率: {volatility:.2%}")
+-    print(f"夏普比率: {sharpe_ratio:.2f}")
+-    print(f"胜率: {(daily_returns > 0).mean():.2%}")
+-
+-
+-def plot_results(data, signals, returns_data, stock_code):
+-    """
+-    绘制结果图表
+-    
+-    Args:
+-        data: 价格数据
+-        signals: 信号数据
+-        returns_data: 收益数据
+-        stock_code: 股票代码
+-    """
+-    fig, axes = plt.subplots(3, 1, figsize=(12, 10))
+-    
+-    # 绘制价格和均线
+-    axes[0].plot(data.index, data[stock_code], label='收盘价', alpha=0.7)
+-    short_ma = data[stock_code].rolling(window=5).mean()
+-    long_ma = data[stock_code].rolling(window=20).mean()
+-    axes[0].plot(data.index, short_ma, label='5日均线', alpha=0.8)
+-    axes[0].plot(data.index, long_ma, label='20日均线', alpha=0.8)
+-    
+-    # 标记买卖信号
+-    buy_signals = signals[stock_code] == 1
+-    sell_signals = signals[stock_code] == -1
+-    
+-    axes[0].scatter(data.index[buy_signals], data.loc[buy_signals, stock_code], 
+-                   color='red', marker='^', s=100, label='买入信号', alpha=0.8)
+-    axes[0].scatter(data.index[sell_signals], data.loc[sell_signals, stock_code], 
+-                   color='green', marker='v', s=100, label='卖出信号', alpha=0.8)
+-    
+-    axes[0].set_title(f'{stock_code} 价格走势与均线交叉信号')
+-    axes[0].legend()
+-    axes[0].grid(True, alpha=0.3)
+-    
+-    # 绘制累计收益
+-    axes[1].plot(returns_data['cumulative_returns'].index, 
+-                returns_data['cumulative_returns'].values, 
+-                label='累计收益', color='blue')
+-    axes[1].set_title('策略累计收益')
+-    axes[1].legend()
+-    axes[1].grid(True, alpha=0.3)
+-    
+-    # 绘制资金曲线
+-    axes[2].plot(returns_data['capital_curve'].index, 
+-                returns_data['capital_curve'].values, 
+-                label='资金曲线', color='green')
+-    axes[2].set_title('资金曲线')
+-    axes[2].legend()
+-    axes[2].grid(True, alpha=0.3)
+-    
+-    plt.tight_layout()
+-    plt.savefig('ma_cross_strategy_results.png', dpi=300, bbox_inches='tight')
+-    plt.show()
+-
+-
+-def main():
+-    """
+-    主函数
+-    """
+-    print("开始运行均线交叉策略...")
+-    
+-    # 初始化qlib
+-    if not init_qlib():
+-        return
+-    
+-    # 策略参数
+-    start_date = "2020-01-01"
+-    end_date = "2023-12-31"
+-    short_window = 5
+-    long_window = 20
+-    initial_capital = 100000
+-    
+-    # 获取股票列表
+-    try:
+-        instruments = D.list_instruments(instruments="csi300", start_time=start_date, end_time=end_date)
+-        print(f"获取到 {len(instruments)} 只股票")
+-        
+-        # 选择前5只股票进行演示
+-        demo_instruments = instruments[:5]
+-        print(f"选择演示股票: {demo_instruments}")
+-        
+-    except Exception as e:
+-        print(f"获取股票列表失败: {e}")
+-        # 使用默认股票列表
+-        demo_instruments = ['000001.SZ', '000002.SZ', '000858.SZ', '002415.SZ', '600036.SH']
+-        print(f"使用默认股票列表: {demo_instruments}")
+-    
+-    # 获取价格数据
+-    data = get_stock_data(demo_instruments, start_date, end_date)
+-    
+-    if data is None:
+-        print("无法获取数据，程序退出")
+-        return
+-    
+-    print(f"获取到价格数据，形状: {data.shape}")
+-    
+-    # 计算均线信号
+-    signals = calculate_ma_signals(data, short_window, long_window)
+-    
+-    # 计算收益
+-    returns_data = calculate_returns(data, signals, initial_capital)
+-    
+-    # 分析策略
+-    analyze_strategy(signals, returns_data)
+-    
+-    # 保存结果
+-    signals.to_csv("ma_cross_signals.csv")
+-    returns_data['cumulative_returns'].to_csv("ma_cross_cumulative_returns.csv")
+-    returns_data['capital_curve'].to_csv("ma_cross_capital_curve.csv")
+-    
+-    print("\n结果已保存到CSV文件:")
+-    print("- ma_cross_signals.csv: 买卖信号")
+-    print("- ma_cross_cumulative_returns.csv: 累计收益")
+-    print("- ma_cross_capital_curve.csv: 资金曲线")
+-    
+-    # 绘制图表（选择第一只股票）
+-    if len(demo_instruments) > 0:
+-        try:
+-            plot_results(data, signals, returns_data, demo_instruments[0])
+-            print("图表已保存为 ma_cross_strategy_results.png")
+-        except Exception as e:
+-            print(f"绘制图表失败: {e}")
+-    
+-    print("\n策略回测完成！")
+-
+-
+-if __name__ == "__main__":
+-    main() 
+\ No newline at end of file
+diff --git a/test/two_ema_stragety.py b/test/two_ema_stragety.py
+index a72e7e8..a9890c7 100644
+--- a/test/two_ema_stragety.py
++++ b/test/two_ema_stragety.py
+@@ -1,2 +1,98 @@
+-from qlib.contrib.strategy import 
+-from qlib.backtest import backtest
+\ No newline at end of file
++import pandas as pd
++
++from abc import ABC
++from typing import Dict, List, Text, Tuple, Union
++from qlib.data.dataset import Dataset
++from qlib.model.base import BaseModel
++from qlib.backtest.signal import Signal, create_signal_from
++from qlib.strategy.base import BaseStrategy
++from qlib.backtest.decision import Order, OrderDir, OrderHelper, TradeDecisionWO
++# from qlib.strategy import 
++# from qlib.backtest import backtest
++
++class InnerStrategy(BaseStrategy):
++    """
++    Inner strategy for order execution:
++    - Buy: if price < 200, buy all cash; else buy 200,000 worth.
++    - Sell: if price > 200, sell all; else sell half.
++    """
++    STOCK_CODE = "000858.SZ"
++
++    def generate_trade_decision(self, execute_result: list = None, action: str = None, amount: float = None):
++        # action: 'buy' or 'sell', amount: suggested amount (shares) from outer
++        position = self.trade_position
++        trade_step = self.trade_calendar.get_trade_step()
++        trade_start_time, trade_end_time = self.trade_calendar.get_step_time(trade_step)
++        order_helper = self.trade_exchange.get_order_helper()
++        orders = []
++        price = self.trade_exchange.get_deal_price(self.STOCK_CODE, trade_start_time, trade_end_time)
++        if action == 'buy':
++            cash = position.get_cash()
++            if price <= 0:
++                return TradeDecisionWO([], self)
++            if price < 200:
++                buy_amount = cash // price
++            else:
++                buy_amount = min(cash // price, 200000 // price)
++            buy_amount = int(buy_amount)
++            if buy_amount > 0:
++                order = order_helper.create(
++                    code=self.STOCK_CODE,
++                    amount=buy_amount,
++                    direction=OrderDir.BUY,
++                    start_time=trade_start_time,
++                    end_time=trade_end_time,
++                )
++                orders.append(order)
++        elif action == 'sell':
++            held_amount = position.get_stock_amount(self.STOCK_CODE)
++            if held_amount <= 0 or price <= 0:
++                return TradeDecisionWO([], self)
++            if price > 200:
++                sell_amount = held_amount
++            else:
++                sell_amount = held_amount // 2
++            sell_amount = int(sell_amount)
++            if sell_amount > 0:
++                order = order_helper.create(
++                    code=self.STOCK_CODE,
++                    amount=sell_amount,
++                    direction=OrderDir.SELL,
++                    start_time=trade_start_time,
++                    end_time=trade_end_time,
++                )
++                orders.append(order)
++        return TradeDecisionWO(orders, self)
++
++class OuterStrategy(BaseStrategy):
++    """
++    Outer strategy:
++    - If not holding Wuliangye, issues a buy order via inner strategy.
++    - If holding, checks if held for 25 days, if so, issues a sell order via inner strategy.
++    - Otherwise, holds.
++    """
++    STOCK_CODE = "000858.SZ"
++    HOLD_DAYS = 25
++    BAR = "day"
++
++    def __init__(self, *args, **kwargs):
++        super().__init__(*args, **kwargs)
++        self.inner_strategy = InnerStrategy()
++
++    def generate_trade_decision(self, execute_result: list = None):
++        position = self.trade_position
++        stock_list = position.get_stock_list()
++        trade_step = self.trade_calendar.get_trade_step()
++        trade_start_time, trade_end_time = self.trade_calendar.get_step_time(trade_step)
++        # Pass infra to inner strategy
++        self.inner_strategy.reset(level_infra=self.level_infra, common_infra=self.common_infra)
++        if self.STOCK_CODE in stock_list:
++            hold_days = position.get_stock_count(self.STOCK_CODE, self.BAR)
++            if hold_days >= self.HOLD_DAYS:
++                # Sell via inner strategy
++                return self.inner_strategy.generate_trade_decision(action='sell')
++        else:
++            # Buy via inner strategy
++            return self.inner_strategy.generate_trade_decision(action='buy')
++        # Otherwise, hold
++        return TradeDecisionWO([], self)
+\ No newline at end of file
diff --git a/mlruns/812028854715931404/ca4ee27d93794592827cc16b8355e682/artifacts/code_status.txt b/mlruns/812028854715931404/ca4ee27d93794592827cc16b8355e682/artifacts/code_status.txt
new file mode 100644
index 0000000..d9b6458
--- /dev/null
+++ b/mlruns/812028854715931404/ca4ee27d93794592827cc16b8355e682/artifacts/code_status.txt
@@ -0,0 +1,25 @@
+On branch main
+Your branch is up to date with 'origin/main'.
+
+Changes not staged for commit:
+  (use "git add/rm <file>..." to update what will be committed)
+  (use "git restore <file>..." to discard changes in working directory)
+	modified:   github/examples/benchmarks/LightGBM/workflow_config_lightgbm_Alpha1582.yaml
+	deleted:    test/README_MA_Strategy.md
+	modified:   test/damo1.py
+	modified:   test/demo2.ipynb
+	deleted:    test/ma_cross_strategy.py
+	deleted:    test/ma_cross_strategy_improved.py
+	deleted:    test/ma_strategy_demo.py
+	deleted:    test/simple_ma_strategy.py
+	modified:   test/two_ema_stragety.py
+
+Untracked files:
+  (use "git add <file>..." to include in what will be committed)
+	github/examples/mlruns/881301994755452456/157579a2201241aaafcff94e93d7da0e/
+	mlruns/
+	test/__pycache__/
+	test/buy_and_hold.py
+	test/workflow_by_code.py
+
+no changes added to commit (use "git add" and/or "git commit -a")
diff --git a/mlruns/812028854715931404/ca4ee27d93794592827cc16b8355e682/meta.yaml b/mlruns/812028854715931404/ca4ee27d93794592827cc16b8355e682/meta.yaml
new file mode 100644
index 0000000..7dbe193
--- /dev/null
+++ b/mlruns/812028854715931404/ca4ee27d93794592827cc16b8355e682/meta.yaml
@@ -0,0 +1,14 @@
+artifact_uri: file:D:\project\python\tradenote\mlruns/812028854715931404/ca4ee27d93794592827cc16b8355e682/artifacts
+end_time: 1750321004230
+entry_point_name: ''
+experiment_id: '812028854715931404'
+lifecycle_stage: active
+run_id: ca4ee27d93794592827cc16b8355e682
+run_name: mlflow_recorder
+source_name: ''
+source_type: 4
+source_version: ''
+start_time: 1750321004026
+status: 3
+tags: []
+user_id: abulimity
diff --git a/mlruns/812028854715931404/ca4ee27d93794592827cc16b8355e682/params/cmd-sys.argv b/mlruns/812028854715931404/ca4ee27d93794592827cc16b8355e682/params/cmd-sys.argv
new file mode 100644
index 0000000..db800eb
--- /dev/null
+++ b/mlruns/812028854715931404/ca4ee27d93794592827cc16b8355e682/params/cmd-sys.argv
@@ -0,0 +1 @@
+D:\project\python\tradenote\test\workflow_by_code.py
\ No newline at end of file
diff --git a/mlruns/812028854715931404/ca4ee27d93794592827cc16b8355e682/tags/mlflow.runName b/mlruns/812028854715931404/ca4ee27d93794592827cc16b8355e682/tags/mlflow.runName
new file mode 100644
index 0000000..25487e4
--- /dev/null
+++ b/mlruns/812028854715931404/ca4ee27d93794592827cc16b8355e682/tags/mlflow.runName
@@ -0,0 +1 @@
+mlflow_recorder
\ No newline at end of file
diff --git a/mlruns/812028854715931404/ca4ee27d93794592827cc16b8355e682/tags/mlflow.source.git.commit b/mlruns/812028854715931404/ca4ee27d93794592827cc16b8355e682/tags/mlflow.source.git.commit
new file mode 100644
index 0000000..288ce21
--- /dev/null
+++ b/mlruns/812028854715931404/ca4ee27d93794592827cc16b8355e682/tags/mlflow.source.git.commit
@@ -0,0 +1 @@
+0daea9b5bbb40120a1bc07c702d171abc1f219c7
\ No newline at end of file
diff --git a/mlruns/812028854715931404/ca4ee27d93794592827cc16b8355e682/tags/mlflow.source.name b/mlruns/812028854715931404/ca4ee27d93794592827cc16b8355e682/tags/mlflow.source.name
new file mode 100644
index 0000000..db800eb
--- /dev/null
+++ b/mlruns/812028854715931404/ca4ee27d93794592827cc16b8355e682/tags/mlflow.source.name
@@ -0,0 +1 @@
+D:\project\python\tradenote\test\workflow_by_code.py
\ No newline at end of file
diff --git a/mlruns/812028854715931404/ca4ee27d93794592827cc16b8355e682/tags/mlflow.source.type b/mlruns/812028854715931404/ca4ee27d93794592827cc16b8355e682/tags/mlflow.source.type
new file mode 100644
index 0000000..0c2c1fe
--- /dev/null
+++ b/mlruns/812028854715931404/ca4ee27d93794592827cc16b8355e682/tags/mlflow.source.type
@@ -0,0 +1 @@
+LOCAL
\ No newline at end of file
diff --git a/mlruns/812028854715931404/ca4ee27d93794592827cc16b8355e682/tags/mlflow.user b/mlruns/812028854715931404/ca4ee27d93794592827cc16b8355e682/tags/mlflow.user
new file mode 100644
index 0000000..b9cec6f
--- /dev/null
+++ b/mlruns/812028854715931404/ca4ee27d93794592827cc16b8355e682/tags/mlflow.user
@@ -0,0 +1 @@
+abulimity
\ No newline at end of file
diff --git a/mlruns/812028854715931404/e8a9b9f4f26e4fddb95d91dbd3e60311/artifacts/code_cached.txt b/mlruns/812028854715931404/e8a9b9f4f26e4fddb95d91dbd3e60311/artifacts/code_cached.txt
new file mode 100644
index 0000000..e69de29
diff --git a/mlruns/812028854715931404/e8a9b9f4f26e4fddb95d91dbd3e60311/artifacts/code_diff.txt b/mlruns/812028854715931404/e8a9b9f4f26e4fddb95d91dbd3e60311/artifacts/code_diff.txt
new file mode 100644
index 0000000..067487e
--- /dev/null
+++ b/mlruns/812028854715931404/e8a9b9f4f26e4fddb95d91dbd3e60311/artifacts/code_diff.txt
@@ -0,0 +1,1508 @@
+diff --git a/github/examples/benchmarks/LightGBM/workflow_config_lightgbm_Alpha1582.yaml b/github/examples/benchmarks/LightGBM/workflow_config_lightgbm_Alpha1582.yaml
+index 8b4e7bf..7a5eee7 100644
+--- a/github/examples/benchmarks/LightGBM/workflow_config_lightgbm_Alpha1582.yaml
++++ b/github/examples/benchmarks/LightGBM/workflow_config_lightgbm_Alpha1582.yaml
+@@ -1,5 +1,5 @@
+ qlib_init:
+-    provider_uri: "D:/project/tradenote/qlib_data/cn_data"
++    provider_uri: "D:/sync/qlib/qlib_data/cn_data"
+     region: cn
+ market: &market csi300
+ benchmark: &benchmark SH000300
+diff --git a/test/README_MA_Strategy.md b/test/README_MA_Strategy.md
+deleted file mode 100644
+index 5facaf7..0000000
+--- a/test/README_MA_Strategy.md
++++ /dev/null
+@@ -1,197 +0,0 @@
+-# 均线交叉策略 (Moving Average Crossover Strategy)
+-
+-## 策略概述
+-
+-这是一个基于qlib框架实现的均线交叉策略，核心逻辑是：
+-- **金叉买入**：短期均线上穿长期均线时买入
+-- **死叉卖出**：短期均线下穿长期均线时卖出
+-
+-## 文件说明
+-
+-### 1. `ma_cross_strategy.py`
+-完整的策略实现，包含：
+-- `MACrossStrategy` 类：继承自qlib的TopkDropoutStrategy
+-- 完整的回测框架
+-- 结果分析和保存
+-
+-### 2. `ma_cross_strategy_improved.py`
+-改进版本，包含：
+-- 更完善的数据获取逻辑
+-- 错误处理机制
+-- 简化版回测功能
+-
+-### 3. `simple_ma_strategy.py` ⭐ **推荐使用**
+-简单实用的版本，包含：
+-- 清晰的数据获取和处理
+-- 均线信号计算
+-- 收益计算和分析
+-- 可视化图表生成
+-- 结果保存功能
+-
+-## 使用方法
+-
+-### 环境准备
+-
+-1. 确保已安装qlib：
+-```bash
+-pip install pyqlib
+-```
+-
+-2. 下载qlib数据（如果还没有）：
+-```bash
+-# 下载中国股票数据
+-python -m qlib.data.dump_bin --csv_path ~/.qlib/qlib_data/cn_data --include_fields close,open,high,low,volume
+-```
+-
+-### 运行策略
+-
+-#### 方法1：运行简单版本（推荐）
+-```bash
+-cd test
+-python simple_ma_strategy.py
+-```
+-
+-#### 方法2：运行完整版本
+-```bash
+-cd test
+-python ma_cross_strategy.py
+-```
+-
+-#### 方法3：运行改进版本
+-```bash
+-cd test
+-python ma_cross_strategy_improved.py
+-```
+-
+-## 策略参数
+-
+-可以在代码中修改以下参数：
+-
+-```python
+-# 均线周期
+-short_window = 5    # 短期均线周期
+-long_window = 20    # 长期均线周期
+-
+-# 回测时间
+-start_date = "2020-01-01"
+-end_date = "2023-12-31"
+-
+-# 初始资金
+-initial_capital = 100000
+-
+-# 股票池
+-instruments = "csi300"  # 沪深300成分股
+-```
+-
+-## 输出结果
+-
+-运行策略后会生成以下文件：
+-
+-1. **CSV文件**：
+-   - `ma_cross_signals.csv`：买卖信号数据
+-   - `ma_cross_cumulative_returns.csv`：累计收益数据
+-   - `ma_cross_capital_curve.csv`：资金曲线数据
+-
+-2. **图表文件**：
+-   - `ma_cross_strategy_results.png`：策略结果可视化图表
+-
+-3. **控制台输出**：
+-   - 策略分析结果
+-   - 收益统计
+-   - 风险指标
+-
+-## 策略分析指标
+-
+-### 收益指标
+-- 总收益率
+-- 年化收益率
+-- 最终资金
+-
+-### 风险指标
+-- 年化波动率
+-- 夏普比率
+-- 胜率
+-- 最大回撤
+-
+-### 交易统计
+-- 买入信号数量
+-- 卖出信号数量
+-- 总交易次数
+-
+-## 策略逻辑详解
+-
+-### 1. 均线计算
+-```python
+-# 计算短期和长期均线
+-short_ma = price_data.rolling(window=short_window).mean()
+-long_ma = price_data.rolling(window=long_window).mean()
+-```
+-
+-### 2. 交叉信号判断
+-```python
+-# 计算均线差值
+-diff = short_ma - long_ma
+-
+-# 金叉：短期均线从下方穿越长期均线
+-if diff.iloc[i-1] < 0 and diff.iloc[i] > 0:
+-    signal = 1  # 买入信号
+-
+-# 死叉：短期均线从上方穿越长期均线
+-elif diff.iloc[i-1] > 0 and diff.iloc[i] < 0:
+-    signal = -1  # 卖出信号
+-```
+-
+-### 3. 收益计算
+-```python
+-# 策略收益（简化处理）
+-strategy_returns = signals * 0.01
+-
+-# 累计收益
+-cumulative_returns = strategy_returns.sum(axis=1).cumsum()
+-```
+-
+-## 注意事项
+-
+-1. **数据依赖**：确保qlib数据已正确下载和配置
+-2. **参数调优**：可以根据不同市场环境调整均线周期
+-3. **风险控制**：实际交易中需要加入止损和仓位管理
+-4. **交易成本**：当前版本未考虑交易费用，实际应用需要考虑
+-
+-## 扩展功能
+-
+-可以基于此策略进行以下扩展：
+-
+-1. **多均线策略**：使用多条均线进行更复杂的信号判断
+-2. **量价配合**：结合成交量指标优化信号
+-3. **止损机制**：添加动态止损策略
+-4. **仓位管理**：根据信号强度调整仓位大小
+-5. **多股票组合**：构建股票组合分散风险
+-
+-## 常见问题
+-
+-### Q: 如何修改股票池？
+-A: 在代码中修改 `instruments` 参数，例如：
+-```python
+-instruments = "csi500"  # 中证500
+-instruments = ["000001.SZ", "000002.SZ"]  # 指定股票列表
+-```
+-
+-### Q: 如何调整均线周期？
+-A: 修改 `short_window` 和 `long_window` 参数：
+-```python
+-short_window = 10  # 10日均线
+-long_window = 30   # 30日均线
+-```
+-
+-### Q: 如何查看详细的交易记录？
+-A: 查看生成的 `ma_cross_signals.csv` 文件，其中包含每日的买卖信号。
+-
+-## 联系方式
+-
+-如有问题或建议，请通过以下方式联系：
+-- 提交Issue到项目仓库
+-- 发送邮件到项目维护者
+-
+----
+-
+-**免责声明**：本策略仅供学习和研究使用，不构成投资建议。实际投资请谨慎决策，并承担相应风险。 
+\ No newline at end of file
+diff --git a/test/damo1.py b/test/damo1.py
+index 03102e1..afa2886 100644
+--- a/test/damo1.py
++++ b/test/damo1.py
+@@ -1,9 +1,35 @@
+-# python scripts/get_data.py qlib_data --target_dir ../qlib_data/cn_data --region cn
+-
+ import qlib
+-# region in [REG_CN, REG_US]
+-from qlib.constant import REG_CN
+-provider_uri = "D:/project/tradenote/qlib_data/cn_data"  # target_dir
+-qlib.init(provider_uri=provider_uri, region=REG_CN)
++from qlib.data import D
++
++# 初始化 Qlib
++qlib.init(provider_uri="D:/sync/qlib/qlib_data/cn_data", region="cn")
++
++# 检查目标股票和基准
++stock_code = "SZ000858"  # 你的BuyHold策略用的股票代码
++benchmark = "SH000300"
++
++print("--- 检查可用股票列表（前10只） ---")
++print(list(D.instruments(market="all"))[:10])
++
++print("--- 检查交易日（2017-01-01 ~ 2020-08-01，前10天） ---")
++print(D.calendar(start_time="2017-01-01", end_time="2020-08-01")[:10])
++
++print(f"--- 检查目标股票 {stock_code} 是否在股票池 ---")
++print(stock_code in D.instruments(market="all"))
++
++print(f"--- 检查基准 {benchmark} 是否在股票池 ---")
++print(benchmark in D.instruments(market="all"))
++
++print(f"--- 检查目标股票 {stock_code} 的行情数据（前5行） ---")
++try:
++    df = D.features([stock_code], ["$close", "$open", "$high", "$low", "$volume"], start_time="2017-01-01", end_time="2020-08-01")
++    print(df.head())
++except Exception as e:
++    print(f"获取行情数据失败: {e}")
+ 
+-# qrun benchmarks/LightGBM/workflow_config_lightgbm_Alpha1582.yaml
++print(f"--- 检查基准 {benchmark} 的行情数据（前5行） ---")
++try:
++    df_bench = D.features([benchmark], ["$close"], start_time="2017-01-01", end_time="2020-08-01")
++    print(df_bench.head())
++except Exception as e:
++    print(f"获取基准行情数据失败: {e}")
+diff --git a/test/demo2.ipynb b/test/demo2.ipynb
+index 66a0215..ad02df5 100644
+--- a/test/demo2.ipynb
++++ b/test/demo2.ipynb
+@@ -2,7 +2,7 @@
+  "cells": [
+   {
+    "cell_type": "code",
+-   "execution_count": 4,
++   "execution_count": 12,
+    "id": "6acb4a77",
+    "metadata": {},
+    "outputs": [
+@@ -10,39 +10,75 @@
+      "name": "stderr",
+      "output_type": "stream",
+      "text": [
+-      "[5344:MainThread](2025-06-18 14:41:03,895) INFO - qlib.Initialization - [config.py:420] - default_conf: client.\n",
+-      "[5344:MainThread](2025-06-18 14:41:03,900) INFO - qlib.Initialization - [__init__.py:74] - qlib successfully initialized based on client settings.\n",
+-      "[5344:MainThread](2025-06-18 14:41:03,903) INFO - qlib.Initialization - [__init__.py:76] - data_path={'__DEFAULT_FREQ': WindowsPath('D:/sync/qlib/qlib_data/cn_data')}\n"
++      "[13736:MainThread](2025-06-19 15:30:19,504) INFO - qlib.Initialization - [config.py:420] - default_conf: client.\n",
++      "[13736:MainThread](2025-06-19 15:30:19,506) INFO - qlib.Initialization - [__init__.py:74] - qlib successfully initialized based on client settings.\n",
++      "[13736:MainThread](2025-06-19 15:30:19,508) INFO - qlib.Initialization - [__init__.py:76] - data_path={'__DEFAULT_FREQ': WindowsPath('D:/sync/qlib/qlib_data/cn_data')}\n"
+      ]
+     }
+    ],
+    "source": [
+     "import qlib\n",
+-    "qlib.init(provider_uri=\"D:/sync/qlib/qlib_data/cn_data\", region=\"cn\")"
++    "qlib.init(provider_uri=r\"D:\\sync\\qlib\\qlib_data\\cn_data\", region=\"cn\")"
+    ]
+   },
+   {
+    "cell_type": "code",
+-   "execution_count": 12,
++   "execution_count": 14,
+    "id": "295df9af",
+    "metadata": {},
+    "outputs": [
+     {
+      "data": {
+       "text/plain": [
+-       "array([Timestamp('2020-09-21 00:00:00'), Timestamp('2020-09-22 00:00:00'),\n",
+-       "       Timestamp('2020-09-23 00:00:00'), Timestamp('2020-09-24 00:00:00'),\n",
+-       "       Timestamp('2020-09-25 00:00:00')], dtype=object)"
++       "array([Timestamp('2017-01-03 00:00:00'), Timestamp('2017-01-04 00:00:00'),\n",
++       "       Timestamp('2017-01-05 00:00:00'), Timestamp('2017-01-06 00:00:00'),\n",
++       "       Timestamp('2017-01-09 00:00:00')], dtype=object)"
+       ]
+      },
+-     "execution_count": 12,
++     "execution_count": 14,
+      "metadata": {},
+      "output_type": "execute_result"
+     }
+    ],
+    "source": [
+     "from qlib.data import D\n",
+-    "D.calendar(start_time='2020-09-21', end_time='2020-10-30', freq='day')"
++    "D.calendar(start_time=\"2017-01-01\", end_time=\"2020-08-01\",freq=\"day\")[:5]"
++   ]
++  },
++  {
++   "cell_type": "code",
++   "execution_count": 21,
++   "id": "da009afa",
++   "metadata": {},
++   "outputs": [
++    {
++     "ename": "error",
++     "evalue": "nothing to repeat at position 0",
++     "output_type": "error",
++     "traceback": [
++      "\u001b[31m---------------------------------------------------------------------------\u001b[39m",
++      "\u001b[31merror\u001b[39m                                     Traceback (most recent call last)",
++      "\u001b[36mCell\u001b[39m\u001b[36m \u001b[39m\u001b[32mIn[21]\u001b[39m\u001b[32m, line 4\u001b[39m\n\u001b[32m      2\u001b[39m nameDFilter = NameDFilter(name_rule_re=\u001b[33m'\u001b[39m\u001b[33m*000858\u001b[39m\u001b[33m'\u001b[39m)\n\u001b[32m      3\u001b[39m instruments = D.instruments(market=\u001b[33m'\u001b[39m\u001b[33mall\u001b[39m\u001b[33m'\u001b[39m,filter_pipe=[nameDFilter])\n\u001b[32m----> \u001b[39m\u001b[32m4\u001b[39m \u001b[43mD\u001b[49m\u001b[43m.\u001b[49m\u001b[43mlist_instruments\u001b[49m\u001b[43m(\u001b[49m\u001b[43minstruments\u001b[49m\u001b[43m=\u001b[49m\u001b[43minstruments\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mstart_time\u001b[49m\u001b[43m=\u001b[49m\u001b[33;43m'\u001b[39;49m\u001b[33;43m2015-01-01\u001b[39;49m\u001b[33;43m'\u001b[39;49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mend_time\u001b[49m\u001b[43m=\u001b[49m\u001b[33;43m'\u001b[39;49m\u001b[33;43m2016-02-15\u001b[39;49m\u001b[33;43m'\u001b[39;49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mas_list\u001b[49m\u001b[43m=\u001b[49m\u001b[38;5;28;43;01mTrue\u001b[39;49;00m\u001b[43m)\u001b[49m\n",
++      "\u001b[36mFile \u001b[39m\u001b[32md:\\project\\python\\tradenote\\.venv\\Lib\\site-packages\\qlib\\data\\data.py:1160\u001b[39m, in \u001b[36mBaseProvider.list_instruments\u001b[39m\u001b[34m(self, instruments, start_time, end_time, freq, as_list)\u001b[39m\n\u001b[32m   1159\u001b[39m \u001b[38;5;28;01mdef\u001b[39;00m\u001b[38;5;250m \u001b[39m\u001b[34mlist_instruments\u001b[39m(\u001b[38;5;28mself\u001b[39m, instruments, start_time=\u001b[38;5;28;01mNone\u001b[39;00m, end_time=\u001b[38;5;28;01mNone\u001b[39;00m, freq=\u001b[33m\"\u001b[39m\u001b[33mday\u001b[39m\u001b[33m\"\u001b[39m, as_list=\u001b[38;5;28;01mFalse\u001b[39;00m):\n\u001b[32m-> \u001b[39m\u001b[32m1160\u001b[39m     \u001b[38;5;28;01mreturn\u001b[39;00m \u001b[43mInst\u001b[49m\u001b[43m.\u001b[49m\u001b[43mlist_instruments\u001b[49m\u001b[43m(\u001b[49m\u001b[43minstruments\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mstart_time\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mend_time\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mfreq\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mas_list\u001b[49m\u001b[43m)\u001b[49m\n",
++      "\u001b[36mFile \u001b[39m\u001b[32md:\\project\\python\\tradenote\\.venv\\Lib\\site-packages\\qlib\\data\\data.py:719\u001b[39m, in \u001b[36mLocalInstrumentProvider.list_instruments\u001b[39m\u001b[34m(self, instruments, start_time, end_time, freq, as_list)\u001b[39m\n\u001b[32m    716\u001b[39m     \u001b[38;5;28;01mfrom\u001b[39;00m\u001b[38;5;250m \u001b[39m\u001b[34;01m.\u001b[39;00m\u001b[38;5;250m \u001b[39m\u001b[38;5;28;01mimport\u001b[39;00m \u001b[38;5;28mfilter\u001b[39m \u001b[38;5;28;01mas\u001b[39;00m F  \u001b[38;5;66;03m# pylint: disable=C0415\u001b[39;00m\n\u001b[32m    718\u001b[39m     filter_t = \u001b[38;5;28mgetattr\u001b[39m(F, filter_config[\u001b[33m\"\u001b[39m\u001b[33mfilter_type\u001b[39m\u001b[33m\"\u001b[39m]).from_config(filter_config)\n\u001b[32m--> \u001b[39m\u001b[32m719\u001b[39m     _instruments_filtered = \u001b[43mfilter_t\u001b[49m\u001b[43m(\u001b[49m\u001b[43m_instruments_filtered\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mstart_time\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mend_time\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mfreq\u001b[49m\u001b[43m)\u001b[49m\n\u001b[32m    720\u001b[39m \u001b[38;5;66;03m# as list\u001b[39;00m\n\u001b[32m    721\u001b[39m \u001b[38;5;28;01mif\u001b[39;00m as_list:\n",
++      "\u001b[36mFile \u001b[39m\u001b[32md:\\project\\python\\tradenote\\.venv\\Lib\\site-packages\\qlib\\data\\filter.py:192\u001b[39m, in \u001b[36mSeriesDFilter.__call__\u001b[39m\u001b[34m(self, instruments, start_time, end_time, freq)\u001b[39m\n\u001b[32m    190\u001b[39m \u001b[38;5;250m\u001b[39m\u001b[33;03m\"\"\"Call this filter to get filtered instruments list\"\"\"\u001b[39;00m\n\u001b[32m    191\u001b[39m \u001b[38;5;28mself\u001b[39m.filter_freq = freq\n\u001b[32m--> \u001b[39m\u001b[32m192\u001b[39m \u001b[38;5;28;01mreturn\u001b[39;00m \u001b[38;5;28;43mself\u001b[39;49m\u001b[43m.\u001b[49m\u001b[43mfilter_main\u001b[49m\u001b[43m(\u001b[49m\u001b[43minstruments\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mstart_time\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mend_time\u001b[49m\u001b[43m)\u001b[49m\n",
++      "\u001b[36mFile \u001b[39m\u001b[32md:\\project\\python\\tradenote\\.venv\\Lib\\site-packages\\qlib\\data\\filter.py:243\u001b[39m, in \u001b[36mSeriesDFilter.filter_main\u001b[39m\u001b[34m(self, instruments, start_time, end_time)\u001b[39m\n\u001b[32m    237\u001b[39m _all_calendar = Cal.calendar(start_time=start_time, end_time=end_time, freq=\u001b[38;5;28mself\u001b[39m.filter_freq)\n\u001b[32m    238\u001b[39m _filter_calendar = Cal.calendar(\n\u001b[32m    239\u001b[39m     start_time=\u001b[38;5;28mself\u001b[39m.filter_start_time \u001b[38;5;129;01mand\u001b[39;00m \u001b[38;5;28mmax\u001b[39m(\u001b[38;5;28mself\u001b[39m.filter_start_time, _all_calendar[\u001b[32m0\u001b[39m]) \u001b[38;5;129;01mor\u001b[39;00m _all_calendar[\u001b[32m0\u001b[39m],\n\u001b[32m    240\u001b[39m     end_time=\u001b[38;5;28mself\u001b[39m.filter_end_time \u001b[38;5;129;01mand\u001b[39;00m \u001b[38;5;28mmin\u001b[39m(\u001b[38;5;28mself\u001b[39m.filter_end_time, _all_calendar[-\u001b[32m1\u001b[39m]) \u001b[38;5;129;01mor\u001b[39;00m _all_calendar[-\u001b[32m1\u001b[39m],\n\u001b[32m    241\u001b[39m     freq=\u001b[38;5;28mself\u001b[39m.filter_freq,\n\u001b[32m    242\u001b[39m )\n\u001b[32m--> \u001b[39m\u001b[32m243\u001b[39m _all_filter_series = \u001b[38;5;28;43mself\u001b[39;49m\u001b[43m.\u001b[49m\u001b[43m_getFilterSeries\u001b[49m\u001b[43m(\u001b[49m\u001b[43minstruments\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43m_filter_calendar\u001b[49m\u001b[43m[\u001b[49m\u001b[32;43m0\u001b[39;49m\u001b[43m]\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43m_filter_calendar\u001b[49m\u001b[43m[\u001b[49m\u001b[43m-\u001b[49m\u001b[32;43m1\u001b[39;49m\u001b[43m]\u001b[49m\u001b[43m)\u001b[49m\n\u001b[32m    244\u001b[39m \u001b[38;5;28;01mfor\u001b[39;00m inst, timestamp \u001b[38;5;129;01min\u001b[39;00m instruments.items():\n\u001b[32m    245\u001b[39m     \u001b[38;5;66;03m# Construct a whole map of date\u001b[39;00m\n\u001b[32m    246\u001b[39m     _timestamp_series = \u001b[38;5;28mself\u001b[39m._toSeries(_all_calendar, timestamp)\n",
++      "\u001b[36mFile \u001b[39m\u001b[32md:\\project\\python\\tradenote\\.venv\\Lib\\site-packages\\qlib\\data\\filter.py:288\u001b[39m, in \u001b[36mNameDFilter._getFilterSeries\u001b[39m\u001b[34m(self, instruments, fstart, fend)\u001b[39m\n\u001b[32m    286\u001b[39m filter_calendar = Cal.calendar(start_time=fstart, end_time=fend, freq=\u001b[38;5;28mself\u001b[39m.filter_freq)\n\u001b[32m    287\u001b[39m \u001b[38;5;28;01mfor\u001b[39;00m inst, timestamp \u001b[38;5;129;01min\u001b[39;00m instruments.items():\n\u001b[32m--> \u001b[39m\u001b[32m288\u001b[39m     \u001b[38;5;28;01mif\u001b[39;00m \u001b[43mre\u001b[49m\u001b[43m.\u001b[49m\u001b[43mmatch\u001b[49m\u001b[43m(\u001b[49m\u001b[38;5;28;43mself\u001b[39;49m\u001b[43m.\u001b[49m\u001b[43mname_rule_re\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43minst\u001b[49m\u001b[43m)\u001b[49m:\n\u001b[32m    289\u001b[39m         _filter_series = pd.Series({timestamp: \u001b[38;5;28;01mTrue\u001b[39;00m \u001b[38;5;28;01mfor\u001b[39;00m timestamp \u001b[38;5;129;01min\u001b[39;00m filter_calendar})\n\u001b[32m    290\u001b[39m     \u001b[38;5;28;01melse\u001b[39;00m:\n",
++      "\u001b[36mFile \u001b[39m\u001b[32m~\\AppData\\Roaming\\uv\\python\\cpython-3.12.11-windows-x86_64-none\\Lib\\re\\__init__.py:167\u001b[39m, in \u001b[36mmatch\u001b[39m\u001b[34m(pattern, string, flags)\u001b[39m\n\u001b[32m    164\u001b[39m \u001b[38;5;28;01mdef\u001b[39;00m\u001b[38;5;250m \u001b[39m\u001b[34mmatch\u001b[39m(pattern, string, flags=\u001b[32m0\u001b[39m):\n\u001b[32m    165\u001b[39m \u001b[38;5;250m    \u001b[39m\u001b[33;03m\"\"\"Try to apply the pattern at the start of the string, returning\u001b[39;00m\n\u001b[32m    166\u001b[39m \u001b[33;03m    a Match object, or None if no match was found.\"\"\"\u001b[39;00m\n\u001b[32m--> \u001b[39m\u001b[32m167\u001b[39m     \u001b[38;5;28;01mreturn\u001b[39;00m \u001b[43m_compile\u001b[49m\u001b[43m(\u001b[49m\u001b[43mpattern\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mflags\u001b[49m\u001b[43m)\u001b[49m.match(string)\n",
++      "\u001b[36mFile \u001b[39m\u001b[32m~\\AppData\\Roaming\\uv\\python\\cpython-3.12.11-windows-x86_64-none\\Lib\\re\\__init__.py:307\u001b[39m, in \u001b[36m_compile\u001b[39m\u001b[34m(pattern, flags)\u001b[39m\n\u001b[32m    301\u001b[39m     \u001b[38;5;28;01mimport\u001b[39;00m\u001b[38;5;250m \u001b[39m\u001b[34;01mwarnings\u001b[39;00m\n\u001b[32m    302\u001b[39m     warnings.warn(\u001b[33m\"\u001b[39m\u001b[33mThe re.TEMPLATE/re.T flag is deprecated \u001b[39m\u001b[33m\"\u001b[39m\n\u001b[32m    303\u001b[39m             \u001b[33m\"\u001b[39m\u001b[33mas it is an undocumented flag \u001b[39m\u001b[33m\"\u001b[39m\n\u001b[32m    304\u001b[39m             \u001b[33m\"\u001b[39m\u001b[33mwithout an obvious purpose. \u001b[39m\u001b[33m\"\u001b[39m\n\u001b[32m    305\u001b[39m             \u001b[33m\"\u001b[39m\u001b[33mDon\u001b[39m\u001b[33m'\u001b[39m\u001b[33mt use it.\u001b[39m\u001b[33m\"\u001b[39m,\n\u001b[32m    306\u001b[39m             \u001b[38;5;167;01mDeprecationWarning\u001b[39;00m)\n\u001b[32m--> \u001b[39m\u001b[32m307\u001b[39m p = \u001b[43m_compiler\u001b[49m\u001b[43m.\u001b[49m\u001b[43mcompile\u001b[49m\u001b[43m(\u001b[49m\u001b[43mpattern\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mflags\u001b[49m\u001b[43m)\u001b[49m\n\u001b[32m    308\u001b[39m \u001b[38;5;28;01mif\u001b[39;00m flags & DEBUG:\n\u001b[32m    309\u001b[39m     \u001b[38;5;28;01mreturn\u001b[39;00m p\n",
++      "\u001b[36mFile \u001b[39m\u001b[32m~\\AppData\\Roaming\\uv\\python\\cpython-3.12.11-windows-x86_64-none\\Lib\\re\\_compiler.py:750\u001b[39m, in \u001b[36mcompile\u001b[39m\u001b[34m(p, flags)\u001b[39m\n\u001b[32m    748\u001b[39m \u001b[38;5;28;01mif\u001b[39;00m isstring(p):\n\u001b[32m    749\u001b[39m     pattern = p\n\u001b[32m--> \u001b[39m\u001b[32m750\u001b[39m     p = \u001b[43m_parser\u001b[49m\u001b[43m.\u001b[49m\u001b[43mparse\u001b[49m\u001b[43m(\u001b[49m\u001b[43mp\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mflags\u001b[49m\u001b[43m)\u001b[49m\n\u001b[32m    751\u001b[39m \u001b[38;5;28;01melse\u001b[39;00m:\n\u001b[32m    752\u001b[39m     pattern = \u001b[38;5;28;01mNone\u001b[39;00m\n",
++      "\u001b[36mFile \u001b[39m\u001b[32m~\\AppData\\Roaming\\uv\\python\\cpython-3.12.11-windows-x86_64-none\\Lib\\re\\_parser.py:979\u001b[39m, in \u001b[36mparse\u001b[39m\u001b[34m(str, flags, state)\u001b[39m\n\u001b[32m    976\u001b[39m state.flags = flags\n\u001b[32m    977\u001b[39m state.str = \u001b[38;5;28mstr\u001b[39m\n\u001b[32m--> \u001b[39m\u001b[32m979\u001b[39m p = \u001b[43m_parse_sub\u001b[49m\u001b[43m(\u001b[49m\u001b[43msource\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mstate\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mflags\u001b[49m\u001b[43m \u001b[49m\u001b[43m&\u001b[49m\u001b[43m \u001b[49m\u001b[43mSRE_FLAG_VERBOSE\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[32;43m0\u001b[39;49m\u001b[43m)\u001b[49m\n\u001b[32m    980\u001b[39m p.state.flags = fix_flags(\u001b[38;5;28mstr\u001b[39m, p.state.flags)\n\u001b[32m    982\u001b[39m \u001b[38;5;28;01mif\u001b[39;00m source.next \u001b[38;5;129;01mis\u001b[39;00m \u001b[38;5;129;01mnot\u001b[39;00m \u001b[38;5;28;01mNone\u001b[39;00m:\n",
++      "\u001b[36mFile \u001b[39m\u001b[32m~\\AppData\\Roaming\\uv\\python\\cpython-3.12.11-windows-x86_64-none\\Lib\\re\\_parser.py:460\u001b[39m, in \u001b[36m_parse_sub\u001b[39m\u001b[34m(source, state, verbose, nested)\u001b[39m\n\u001b[32m    458\u001b[39m start = source.tell()\n\u001b[32m    459\u001b[39m \u001b[38;5;28;01mwhile\u001b[39;00m \u001b[38;5;28;01mTrue\u001b[39;00m:\n\u001b[32m--> \u001b[39m\u001b[32m460\u001b[39m     itemsappend(\u001b[43m_parse\u001b[49m\u001b[43m(\u001b[49m\u001b[43msource\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mstate\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mverbose\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mnested\u001b[49m\u001b[43m \u001b[49m\u001b[43m+\u001b[49m\u001b[43m \u001b[49m\u001b[32;43m1\u001b[39;49m\u001b[43m,\u001b[49m\n\u001b[32m    461\u001b[39m \u001b[43m                       \u001b[49m\u001b[38;5;129;43;01mnot\u001b[39;49;00m\u001b[43m \u001b[49m\u001b[43mnested\u001b[49m\u001b[43m \u001b[49m\u001b[38;5;129;43;01mand\u001b[39;49;00m\u001b[43m \u001b[49m\u001b[38;5;129;43;01mnot\u001b[39;49;00m\u001b[43m \u001b[49m\u001b[43mitems\u001b[49m\u001b[43m)\u001b[49m)\n\u001b[32m    462\u001b[39m     \u001b[38;5;28;01mif\u001b[39;00m \u001b[38;5;129;01mnot\u001b[39;00m sourcematch(\u001b[33m\"\u001b[39m\u001b[33m|\u001b[39m\u001b[33m\"\u001b[39m):\n\u001b[32m    463\u001b[39m         \u001b[38;5;28;01mbreak\u001b[39;00m\n",
++      "\u001b[36mFile \u001b[39m\u001b[32m~\\AppData\\Roaming\\uv\\python\\cpython-3.12.11-windows-x86_64-none\\Lib\\re\\_parser.py:687\u001b[39m, in \u001b[36m_parse\u001b[39m\u001b[34m(source, state, verbose, nested, first)\u001b[39m\n\u001b[32m    685\u001b[39m     item = \u001b[38;5;28;01mNone\u001b[39;00m\n\u001b[32m    686\u001b[39m \u001b[38;5;28;01mif\u001b[39;00m \u001b[38;5;129;01mnot\u001b[39;00m item \u001b[38;5;129;01mor\u001b[39;00m item[\u001b[32m0\u001b[39m][\u001b[32m0\u001b[39m] \u001b[38;5;129;01mis\u001b[39;00m AT:\n\u001b[32m--> \u001b[39m\u001b[32m687\u001b[39m     \u001b[38;5;28;01mraise\u001b[39;00m source.error(\u001b[33m\"\u001b[39m\u001b[33mnothing to repeat\u001b[39m\u001b[33m\"\u001b[39m,\n\u001b[32m    688\u001b[39m                        source.tell() - here + \u001b[38;5;28mlen\u001b[39m(this))\n\u001b[32m    689\u001b[39m \u001b[38;5;28;01mif\u001b[39;00m item[\u001b[32m0\u001b[39m][\u001b[32m0\u001b[39m] \u001b[38;5;129;01min\u001b[39;00m _REPEATCODES:\n\u001b[32m    690\u001b[39m     \u001b[38;5;28;01mraise\u001b[39;00m source.error(\u001b[33m\"\u001b[39m\u001b[33mmultiple repeat\u001b[39m\u001b[33m\"\u001b[39m,\n\u001b[32m    691\u001b[39m                        source.tell() - here + \u001b[38;5;28mlen\u001b[39m(this))\n",
++      "\u001b[31merror\u001b[39m: nothing to repeat at position 0"
++     ]
++    }
++   ],
++   "source": [
++    "from qlib.data.filter import NameDFilter\n",
++    "nameDFilter = NameDFilter(name_rule_re='*000858')\n",
++    "instruments = D.instruments(market='all',filter_pipe=[nameDFilter])\n",
++    "D.list_instruments(instruments=instruments, start_time='2015-01-01', end_time='2016-02-15', as_list=True)\n"
+    ]
+   }
+  ],
+diff --git a/test/ma_cross_strategy.py b/test/ma_cross_strategy.py
+deleted file mode 100644
+index 719d849..0000000
+--- a/test/ma_cross_strategy.py
++++ /dev/null
+@@ -1,274 +0,0 @@
+-"""
+-均线交叉策略：金叉买入，死叉卖出
+-使用qlib框架实现
+-"""
+-
+-import qlib
+-from qlib.constant import REG_CN
+-from qlib.utils import init_instance_by_config
+-from qlib.workflow import R
+-from qlib.workflow.record_temp import SignalRecord, PortAnaRecord
+-from qlib.contrib.evaluate import backtest_daily
+-from qlib.contrib.strategy import TopkDropoutStrategy
+-import pandas as pd
+-import numpy as np
+-from typing import Dict, List, Tuple
+-
+-
+-class MACrossStrategy(TopkDropoutStrategy):
+-    """
+-    均线交叉策略
+-    金叉（短期均线上穿长期均线）买入
+-    死叉（短期均线下穿长期均线）卖出
+-    """
+-    
+-    def __init__(self, 
+-                 short_window: int = 5,
+-                 long_window: int = 20,
+-                 topk: int = 50,
+-                 n_drop: int = 5,
+-                 **kwargs):
+-        """
+-        初始化策略参数
+-        
+-        Args:
+-            short_window: 短期均线周期
+-            long_window: 长期均线周期
+-            topk: 选择前k只股票
+-            n_drop: 剔除前n只股票
+-        """
+-        super().__init__(topk=topk, n_drop=n_drop, **kwargs)
+-        self.short_window = short_window
+-        self.long_window = long_window
+-        
+-    def generate_trade_decision(self, score: pd.Series, trade_step: int) -> pd.Series:
+-        """
+-        生成交易决策
+-        
+-        Args:
+-            score: 股票评分
+-            trade_step: 交易步骤
+-            
+-        Returns:
+-            交易决策，1表示买入，-1表示卖出，0表示持有
+-        """
+-        # 获取当前持仓
+-        current_pos = self.get_current_position()
+-        
+-        # 计算均线信号
+-        signal = self._calculate_ma_signal(score.index.tolist(), trade_step)
+-        
+-        # 生成交易决策
+-        decision = pd.Series(0, index=score.index)
+-        
+-        # 金叉买入信号
+-        buy_signal = signal == 1
+-        decision[buy_signal] = 1
+-        
+-        # 死叉卖出信号
+-        sell_signal = signal == -1
+-        decision[sell_signal] = -1
+-        
+-        return decision
+-    
+-    def _calculate_ma_signal(self, instruments: List[str], trade_step: int) -> pd.Series:
+-        """
+-        计算均线交叉信号
+-        
+-        Args:
+-            instruments: 股票代码列表
+-            trade_step: 交易步骤
+-            
+-        Returns:
+-            信号序列：1表示金叉买入，-1表示死叉卖出，0表示无信号
+-        """
+-        # 获取历史数据
+-        data = self._get_historical_data(instruments, trade_step)
+-        
+-        signals = pd.Series(0, index=instruments)
+-        
+-        for instrument in instruments:
+-            if instrument in data.index:
+-                # 计算短期和长期均线
+-                short_ma = data.loc[instrument].rolling(window=self.short_window).mean()
+-                long_ma = data.loc[instrument].rolling(window=self.long_window).mean()
+-                
+-                # 计算交叉信号
+-                if len(short_ma) >= 2 and len(long_ma) >= 2:
+-                    # 当前和前一个时间点的均线差值
+-                    current_diff = short_ma.iloc[-1] - long_ma.iloc[-1]
+-                    prev_diff = short_ma.iloc[-2] - long_ma.iloc[-2]
+-                    
+-                    # 金叉：短期均线从下方穿越长期均线
+-                    if prev_diff < 0 and current_diff > 0:
+-                        signals[instrument] = 1
+-                    # 死叉：短期均线从上方穿越长期均线
+-                    elif prev_diff > 0 and current_diff < 0:
+-                        signals[instrument] = -1
+-        
+-        return signals
+-    
+-    def _get_historical_data(self, instruments: List[str], trade_step: int) -> pd.DataFrame:
+-        """
+-        获取历史价格数据
+-        
+-        Args:
+-            instruments: 股票代码列表
+-            trade_step: 交易步骤
+-            
+-        Returns:
+-            历史价格数据
+-        """
+-        # 这里简化处理，实际应该从qlib数据源获取
+-        # 在实际应用中，您需要使用qlib的数据接口
+-        try:
+-            # 获取最近的数据用于计算均线
+-            # 这里使用模拟数据，实际应该从qlib获取
+-            dates = pd.date_range(end=pd.Timestamp.now(), periods=50, freq='D')
+-            data = pd.DataFrame(
+-                np.random.randn(len(dates), len(instruments)) * 0.02 + 1.0,
+-                index=dates,
+-                columns=instruments
+-            )
+-            return data
+-        except Exception as e:
+-            print(f"获取历史数据失败: {e}")
+-            return pd.DataFrame()
+-
+-
+-def create_ma_cross_strategy_config():
+-    """
+-    创建均线交叉策略配置
+-    """
+-    strategy_config = {
+-        "class": "MACrossStrategy",
+-        "module_path": "test.ma_cross_strategy",
+-        "kwargs": {
+-            "short_window": 5,
+-            "long_window": 20,
+-            "topk": 50,
+-            "n_drop": 5,
+-        }
+-    }
+-    
+-    return strategy_config
+-
+-
+-def run_backtest():
+-    """
+-    运行回测
+-    """
+-    # 初始化qlib
+-    qlib.init(provider_uri='~/.qlib/qlib_data/cn_data', region=REG_CN)
+-    
+-    # 策略配置
+-    strategy_config = create_ma_cross_strategy_config()
+-    
+-    # 回测配置
+-    backtest_config = {
+-        "start_time": "2020-01-01",
+-        "end_time": "2023-12-31",
+-        "benchmark": "SH000300",  # 沪深300作为基准
+-        "account": 100000000,     # 初始资金1亿
+-        "exchange_kwargs": {
+-            "freq": "day",
+-            "limit_threshold": 0.095,
+-            "deal_price": "close",
+-            "open_cost": 0.0005,
+-            "close_cost": 0.0015,
+-            "min_cost": 5,
+-        }
+-    }
+-    
+-    # 创建策略实例
+-    strategy = init_instance_by_config(strategy_config)
+-    
+-    # 运行回测
+-    with R.start(experiment_name="ma_cross_strategy"):
+-        # 记录信号
+-        sr = SignalRecord(model=strategy, dataset=None, recorder=R.get_recorder())
+-        sr.generate()
+-        
+-        # 记录投资组合分析
+-        par = PortAnaRecord(recorder=R.get_recorder(), config=backtest_config, strategy=strategy)
+-        par.generate()
+-        
+-        # 获取回测结果
+-        report_normal, positions_normal = backtest_daily(
+-            account=backtest_config["account"],
+-            benchmark=backtest_config["benchmark"],
+-            start_time=backtest_config["start_time"],
+-            end_time=backtest_config["end_time"],
+-            strategy=strategy,
+-            exchange_kwargs=backtest_config["exchange_kwargs"]
+-        )
+-        
+-        return report_normal, positions_normal
+-
+-
+-def analyze_results(report: pd.DataFrame, positions: pd.DataFrame):
+-    """
+-    分析回测结果
+-    
+-    Args:
+-        report: 回测报告
+-        positions: 持仓信息
+-    """
+-    print("=" * 50)
+-    print("均线交叉策略回测结果")
+-    print("=" * 50)
+-    
+-    # 基本统计信息
+-    print(f"总收益率: {report['return'].sum():.2%}")
+-    print(f"年化收益率: {report['return'].mean() * 252:.2%}")
+-    print(f"最大回撤: {report['drawdown'].min():.2%}")
+-    print(f"夏普比率: {report['sharpe'].iloc[-1]:.2f}")
+-    print(f"胜率: {(report['return'] > 0).mean():.2%}")
+-    
+-    # 风险指标
+-    volatility = report['return'].std() * np.sqrt(252)
+-    print(f"年化波动率: {volatility:.2%}")
+-    
+-    # 最大回撤期间
+-    max_drawdown_idx = report['drawdown'].idxmin()
+-    print(f"最大回撤发生时间: {max_drawdown_idx}")
+-    
+-    # 收益分布
+-    print("\n收益分布统计:")
+-    print(f"平均日收益: {report['return'].mean():.2%}")
+-    print(f"收益标准差: {report['return'].std():.2%}")
+-    print(f"最小日收益: {report['return'].min():.2%}")
+-    print(f"最大日收益: {report['return'].max():.2%}")
+-    
+-    # 交易统计
+-    if 'trade_count' in report.columns:
+-        print(f"\n总交易次数: {report['trade_count'].sum()}")
+-        print(f"平均每日交易次数: {report['trade_count'].mean():.1f}")
+-
+-
+-def main():
+-    """
+-    主函数
+-    """
+-    print("开始运行均线交叉策略回测...")
+-    
+-    try:
+-        # 运行回测
+-        report, positions = run_backtest()
+-        
+-        # 分析结果
+-        analyze_results(report, positions)
+-        
+-        # 保存结果
+-        report.to_csv("ma_cross_strategy_report.csv")
+-        positions.to_csv("ma_cross_strategy_positions.csv")
+-        
+-        print("\n回测完成！结果已保存到CSV文件。")
+-        
+-    except Exception as e:
+-        print(f"回测过程中出现错误: {e}")
+-        print("请确保已正确安装qlib并下载了相应的数据。")
+-
+-
+-if __name__ == "__main__":
+-    main() 
+\ No newline at end of file
+diff --git a/test/ma_cross_strategy_improved.py b/test/ma_cross_strategy_improved.py
+deleted file mode 100644
+index d166c68..0000000
+--- a/test/ma_cross_strategy_improved.py
++++ /dev/null
+@@ -1,443 +0,0 @@
+-"""
+-改进的均线交叉策略：金叉买入，死叉卖出
+-使用qlib框架实现，包含完整的数据获取和信号计算
+-"""
+-
+-import qlib
+-from qlib.constant import REG_CN
+-from qlib.utils import init_instance_by_config
+-from qlib.workflow import R
+-from qlib.workflow.record_temp import SignalRecord, PortAnaRecord
+-from qlib.contrib.evaluate import backtest_daily
+-from qlib.contrib.strategy import TopkDropoutStrategy
+-from qlib.data import D
+-from qlib.data.dataset import DatasetH
+-from qlib.data.dataset.handler import DataHandlerLP
+-import pandas as pd
+-import numpy as np
+-from typing import Dict, List, Tuple
+-import warnings
+-warnings.filterwarnings('ignore')
+-
+-
+-class MACrossStrategyImproved(TopkDropoutStrategy):
+-    """
+-    改进的均线交叉策略
+-    金叉（短期均线上穿长期均线）买入
+-    死叉（短期均线下穿长期均线）卖出
+-    """
+-    
+-    def __init__(self, 
+-                 short_window: int = 5,
+-                 long_window: int = 20,
+-                 topk: int = 50,
+-                 n_drop: int = 5,
+-                 universe: str = "csi300",
+-                 **kwargs):
+-        """
+-        初始化策略参数
+-        
+-        Args:
+-            short_window: 短期均线周期
+-            long_window: 长期均线周期
+-            topk: 选择前k只股票
+-            n_drop: 剔除前n只股票
+-            universe: 股票池
+-        """
+-        super().__init__(topk=topk, n_drop=n_drop, **kwargs)
+-        self.short_window = short_window
+-        self.long_window = long_window
+-        self.universe = universe
+-        self.instruments = None
+-        self.price_cache = {}
+-        
+-    def generate_trade_decision(self, score: pd.Series, trade_step: int) -> pd.Series:
+-        """
+-        生成交易决策
+-        
+-        Args:
+-            score: 股票评分
+-            trade_step: 交易步骤
+-            
+-        Returns:
+-            交易决策，1表示买入，-1表示卖出，0表示持有
+-        """
+-        # 获取当前持仓
+-        current_pos = self.get_current_position()
+-        
+-        # 计算均线信号
+-        signal = self._calculate_ma_signal(score.index.tolist(), trade_step)
+-        
+-        # 生成交易决策
+-        decision = pd.Series(0, index=score.index)
+-        
+-        # 金叉买入信号
+-        buy_signal = signal == 1
+-        decision[buy_signal] = 1
+-        
+-        # 死叉卖出信号
+-        sell_signal = signal == -1
+-        decision[sell_signal] = -1
+-        
+-        return decision
+-    
+-    def _calculate_ma_signal(self, instruments: List[str], trade_step: int) -> pd.Series:
+-        """
+-        计算均线交叉信号
+-        
+-        Args:
+-            instruments: 股票代码列表
+-            trade_step: 交易步骤
+-            
+-        Returns:
+-            信号序列：1表示金叉买入，-1表示死叉卖出，0表示无信号
+-        """
+-        signals = pd.Series(0, index=instruments)
+-        
+-        # 获取当前日期
+-        current_date = self._get_current_date(trade_step)
+-        
+-        for instrument in instruments:
+-            try:
+-                # 获取历史价格数据
+-                price_data = self._get_price_data(instrument, current_date)
+-                
+-                if price_data is not None and len(price_data) >= self.long_window:
+-                    # 计算短期和长期均线
+-                    short_ma = price_data['close'].rolling(window=self.short_window).mean()
+-                    long_ma = price_data['close'].rolling(window=self.long_window).mean()
+-                    
+-                    # 计算交叉信号
+-                    if len(short_ma) >= 2 and len(long_ma) >= 2:
+-                        # 当前和前一个时间点的均线差值
+-                        current_diff = short_ma.iloc[-1] - long_ma.iloc[-1]
+-                        prev_diff = short_ma.iloc[-2] - long_ma.iloc[-2]
+-                        
+-                        # 金叉：短期均线从下方穿越长期均线
+-                        if prev_diff < 0 and current_diff > 0:
+-                            signals[instrument] = 1
+-                        # 死叉：短期均线从上方穿越长期均线
+-                        elif prev_diff > 0 and current_diff < 0:
+-                            signals[instrument] = -1
+-                            
+-            except Exception as e:
+-                print(f"计算{instrument}均线信号时出错: {e}")
+-                continue
+-        
+-        return signals
+-    
+-    def _get_price_data(self, instrument: str, current_date: str) -> pd.DataFrame:
+-        """
+-        获取股票价格数据
+-        
+-        Args:
+-            instrument: 股票代码
+-            current_date: 当前日期
+-            
+-        Returns:
+-            价格数据DataFrame
+-        """
+-        try:
+-            # 计算开始日期（获取足够的历史数据来计算均线）
+-            start_date = pd.Timestamp(current_date) - pd.Timedelta(days=self.long_window * 2)
+-            
+-            # 从qlib获取数据
+-            data = D.features(
+-                instruments=[instrument],
+-                start_time=start_date.strftime('%Y-%m-%d'),
+-                end_time=current_date,
+-                freq='day',
+-                fields=['$close', '$open', '$high', '$low', '$volume']
+-            )
+-            
+-            if data is not None and not data.empty:
+-                # 重命名列
+-                data.columns = ['close', 'open', 'high', 'low', 'volume']
+-                return data
+-            else:
+-                return None
+-                
+-        except Exception as e:
+-            print(f"获取{instrument}价格数据失败: {e}")
+-            return None
+-    
+-    def _get_current_date(self, trade_step: int) -> str:
+-        """
+-        根据交易步骤获取当前日期
+-        
+-        Args:
+-            trade_step: 交易步骤
+-            
+-        Returns:
+-            当前日期字符串
+-        """
+-        # 这里简化处理，实际应该从qlib的日历获取
+-        # 假设从2020-01-01开始，每个trade_step代表一天
+-        start_date = pd.Timestamp('2020-01-01')
+-        current_date = start_date + pd.Timedelta(days=trade_step)
+-        return current_date.strftime('%Y-%m-%d')
+-
+-
+-def create_dataset_config():
+-    """
+-    创建数据集配置
+-    """
+-    dataset_config = {
+-        "class": "DatasetH",
+-        "module_path": "qlib.data.dataset",
+-        "kwargs": {
+-            "handler": {
+-                "class": "DataHandlerLP",
+-                "module_path": "qlib.data.dataset.handler",
+-                "kwargs": {
+-                    "start_time": "2020-01-01",
+-                    "end_time": "2023-12-31",
+-                    "fit_start_time": "2020-01-01",
+-                    "fit_end_time": "2023-12-31",
+-                    "instruments": "csi300",
+-                    "infer_processors": [
+-                        {
+-                            "class": "RobustZScoreNorm",
+-                            "module_path": "qlib.data.dataset.processor",
+-                            "kwargs": {
+-                                "fields_group": "feature",
+-                                "clip_outlier": True,
+-                            },
+-                        },
+-                        {
+-                            "class": "Fillna",
+-                            "module_path": "qlib.data.dataset.processor",
+-                            "kwargs": {
+-                                "fields_group": "feature",
+-                            },
+-                        },
+-                    ],
+-                    "learn_processors": [
+-                        {
+-                            "class": "DropnaLabel",
+-                            "module_path": "qlib.data.dataset.processor",
+-                        },
+-                        {
+-                            "class": "CSRankNorm",
+-                            "module_path": "qlib.data.dataset.processor",
+-                            "kwargs": {
+-                                "fields_group": "label",
+-                            },
+-                        },
+-                    ],
+-                    "instruments": "csi300",
+-                },
+-            },
+-            "segments": {
+-                "train": ("2020-01-01", "2022-12-31"),
+-                "valid": ("2023-01-01", "2023-06-30"),
+-                "test": ("2023-07-01", "2023-12-31"),
+-            },
+-        },
+-    }
+-    
+-    return dataset_config
+-
+-
+-def create_ma_cross_strategy_config():
+-    """
+-    创建均线交叉策略配置
+-    """
+-    strategy_config = {
+-        "class": "MACrossStrategyImproved",
+-        "module_path": "test.ma_cross_strategy_improved",
+-        "kwargs": {
+-            "short_window": 5,
+-            "long_window": 20,
+-            "topk": 50,
+-            "n_drop": 5,
+-            "universe": "csi300",
+-        }
+-    }
+-    
+-    return strategy_config
+-
+-
+-def run_backtest():
+-    """
+-    运行回测
+-    """
+-    # 初始化qlib
+-    qlib.init(provider_uri='~/.qlib/qlib_data/cn_data', region=REG_CN)
+-    
+-    # 策略配置
+-    strategy_config = create_ma_cross_strategy_config()
+-    
+-    # 回测配置
+-    backtest_config = {
+-        "start_time": "2020-01-01",
+-        "end_time": "2023-12-31",
+-        "benchmark": "SH000300",  # 沪深300作为基准
+-        "account": 100000000,     # 初始资金1亿
+-        "exchange_kwargs": {
+-            "freq": "day",
+-            "limit_threshold": 0.095,
+-            "deal_price": "close",
+-            "open_cost": 0.0005,
+-            "close_cost": 0.0015,
+-            "min_cost": 5,
+-        }
+-    }
+-    
+-    # 创建策略实例
+-    strategy = init_instance_by_config(strategy_config)
+-    
+-    # 运行回测
+-    with R.start(experiment_name="ma_cross_strategy_improved"):
+-        # 记录信号
+-        sr = SignalRecord(model=strategy, dataset=None, recorder=R.get_recorder())
+-        sr.generate()
+-        
+-        # 记录投资组合分析
+-        par = PortAnaRecord(recorder=R.get_recorder(), config=backtest_config, strategy=strategy)
+-        par.generate()
+-        
+-        # 获取回测结果
+-        report_normal, positions_normal = backtest_daily(
+-            account=backtest_config["account"],
+-            benchmark=backtest_config["benchmark"],
+-            start_time=backtest_config["start_time"],
+-            end_time=backtest_config["end_time"],
+-            strategy=strategy,
+-            exchange_kwargs=backtest_config["exchange_kwargs"]
+-        )
+-        
+-        return report_normal, positions_normal
+-
+-
+-def analyze_results(report: pd.DataFrame, positions: pd.DataFrame):
+-    """
+-    分析回测结果
+-    
+-    Args:
+-        report: 回测报告
+-        positions: 持仓信息
+-    """
+-    print("=" * 50)
+-    print("均线交叉策略回测结果")
+-    print("=" * 50)
+-    
+-    # 基本统计信息
+-    print(f"总收益率: {report['return'].sum():.2%}")
+-    print(f"年化收益率: {report['return'].mean() * 252:.2%}")
+-    print(f"最大回撤: {report['drawdown'].min():.2%}")
+-    
+-    if 'sharpe' in report.columns:
+-        print(f"夏普比率: {report['sharpe'].iloc[-1]:.2f}")
+-    
+-    print(f"胜率: {(report['return'] > 0).mean():.2%}")
+-    
+-    # 风险指标
+-    volatility = report['return'].std() * np.sqrt(252)
+-    print(f"年化波动率: {volatility:.2%}")
+-    
+-    # 最大回撤期间
+-    max_drawdown_idx = report['drawdown'].idxmin()
+-    print(f"最大回撤发生时间: {max_drawdown_idx}")
+-    
+-    # 收益分布
+-    print("\n收益分布统计:")
+-    print(f"平均日收益: {report['return'].mean():.2%}")
+-    print(f"收益标准差: {report['return'].std():.2%}")
+-    print(f"最小日收益: {report['return'].min():.2%}")
+-    print(f"最大日收益: {report['return'].max():.2%}")
+-    
+-    # 交易统计
+-    if 'trade_count' in report.columns:
+-        print(f"\n总交易次数: {report['trade_count'].sum()}")
+-        print(f"平均每日交易次数: {report['trade_count'].mean():.1f}")
+-
+-
+-def create_simple_backtest():
+-    """
+-    创建简化版回测，用于演示
+-    """
+-    print("创建简化版均线交叉策略回测...")
+-    
+-    # 初始化qlib
+-    qlib.init(provider_uri='~/.qlib/qlib_data/cn_data', region=REG_CN)
+-    
+-    # 获取股票列表
+-    instruments = D.list_instruments(instruments="csi300", start_time="2020-01-01", end_time="2023-12-31")
+-    
+-    print(f"获取到 {len(instruments)} 只股票")
+-    
+-    # 选择前10只股票进行演示
+-    demo_instruments = instruments[:10]
+-    
+-    # 获取价格数据
+-    data = D.features(
+-        instruments=demo_instruments,
+-        start_time="2020-01-01",
+-        end_time="2023-12-31",
+-        freq='day',
+-        fields=['$close']
+-    )
+-    
+-    print(f"获取到价格数据，形状: {data.shape}")
+-    
+-    # 计算均线
+-    short_ma = data.rolling(window=5).mean()
+-    long_ma = data.rolling(window=20).mean()
+-    
+-    # 计算交叉信号
+-    signals = pd.DataFrame(0, index=data.index, columns=data.columns)
+-    
+-    for col in data.columns:
+-        # 计算均线差值
+-        diff = short_ma[col] - long_ma[col]
+-        
+-        # 计算交叉信号
+-        for i in range(1, len(diff)):
+-            if diff.iloc[i-1] < 0 and diff.iloc[i] > 0:
+-                signals.iloc[i, signals.columns.get_loc(col)] = 1  # 金叉买入
+-            elif diff.iloc[i-1] > 0 and diff.iloc[i] < 0:
+-                signals.iloc[i, signals.columns.get_loc(col)] = -1  # 死叉卖出
+-    
+-    # 统计信号
+-    buy_signals = (signals == 1).sum().sum()
+-    sell_signals = (signals == -1).sum().sum()
+-    
+-    print(f"\n信号统计:")
+-    print(f"买入信号数量: {buy_signals}")
+-    print(f"卖出信号数量: {sell_signals}")
+-    
+-    # 计算简单收益（假设每次信号都产生1%的收益）
+-    returns = signals * 0.01
+-    cumulative_returns = returns.sum(axis=1).cumsum()
+-    
+-    print(f"\n累计收益: {cumulative_returns.iloc[-1]:.2%}")
+-    
+-    return signals, cumulative_returns
+-
+-
+-def main():
+-    """
+-    主函数
+-    """
+-    print("开始运行均线交叉策略回测...")
+-    
+-    try:
+-        # 运行简化版回测
+-        signals, cumulative_returns = create_simple_backtest()
+-        
+-        # 保存简化版结果
+-        signals.to_csv("ma_cross_signals.csv")
+-        cumulative_returns.to_csv("ma_cross_cumulative_returns.csv")
+-        
+-        print("\n简化版回测完成！")
+-        print("信号数据已保存到 ma_cross_signals.csv")
+-        print("累计收益已保存到 ma_cross_cumulative_returns.csv")
+-        
+-    except Exception as e:
+-        print(f"回测过程中出现错误: {e}")
+-        print("请确保已正确安装qlib并下载了相应的数据。")
+-
+-
+-if __name__ == "__main__":
+-    main() 
+\ No newline at end of file
+diff --git a/test/ma_strategy_demo.py b/test/ma_strategy_demo.py
+deleted file mode 100644
+index 1fa4fb4..0000000
+Binary files a/test/ma_strategy_demo.py and /dev/null differ
+diff --git a/test/simple_ma_strategy.py b/test/simple_ma_strategy.py
+deleted file mode 100644
+index 8d03f6b..0000000
+--- a/test/simple_ma_strategy.py
++++ /dev/null
+@@ -1,298 +0,0 @@
+-"""
+-简单实用的均线交叉策略
+-金叉买入，死叉卖出
+-"""
+-
+-import qlib
+-from qlib.constant import REG_CN
+-from qlib.data import D
+-import pandas as pd
+-import numpy as np
+-import matplotlib.pyplot as plt
+-from datetime import datetime, timedelta
+-
+-
+-def init_qlib():
+-    """初始化qlib"""
+-    try:
+-        qlib.init(provider_uri='~/.qlib/qlib_data/cn_data', region=REG_CN)
+-        print("qlib初始化成功")
+-        return True
+-    except Exception as e:
+-        print(f"qlib初始化失败: {e}")
+-        print("请确保已安装qlib并下载了数据")
+-        return False
+-
+-
+-def get_stock_data(instruments, start_date, end_date):
+-    """
+-    获取股票数据
+-    
+-    Args:
+-        instruments: 股票代码列表
+-        start_date: 开始日期
+-        end_date: 结束日期
+-    
+-    Returns:
+-        股票价格数据
+-    """
+-    try:
+-        data = D.features(
+-            instruments=instruments,
+-            start_time=start_date,
+-            end_time=end_date,
+-            freq='day',
+-            fields=['$close', '$open', '$high', '$low', '$volume']
+-        )
+-        
+-        if data is not None and not data.empty:
+-            # 重命名列
+-            data.columns = ['close', 'open', 'high', 'low', 'volume']
+-            return data
+-        else:
+-            print("未获取到数据")
+-            return None
+-            
+-    except Exception as e:
+-        print(f"获取数据失败: {e}")
+-        return None
+-
+-
+-def calculate_ma_signals(data, short_window=5, long_window=20):
+-    """
+-    计算均线交叉信号
+-    
+-    Args:
+-        data: 价格数据
+-        short_window: 短期均线周期
+-        long_window: 长期均线周期
+-    
+-    Returns:
+-        信号DataFrame，1表示买入，-1表示卖出，0表示无信号
+-    """
+-    signals = pd.DataFrame(0, index=data.index, columns=data.columns)
+-    
+-    for col in data.columns:
+-        if col == 'close':
+-            continue
+-            
+-        # 计算均线
+-        short_ma = data[col].rolling(window=short_window).mean()
+-        long_ma = data[col].rolling(window=long_window).mean()
+-        
+-        # 计算均线差值
+-        diff = short_ma - long_ma
+-        
+-        # 计算交叉信号
+-        for i in range(1, len(diff)):
+-            if pd.notna(diff.iloc[i-1]) and pd.notna(diff.iloc[i]):
+-                # 金叉：短期均线从下方穿越长期均线
+-                if diff.iloc[i-1] < 0 and diff.iloc[i] > 0:
+-                    signals.iloc[i, signals.columns.get_loc(col)] = 1
+-                # 死叉：短期均线从上方穿越长期均线
+-                elif diff.iloc[i-1] > 0 and diff.iloc[i] < 0:
+-                    signals.iloc[i, signals.columns.get_loc(col)] = -1
+-    
+-    return signals
+-
+-
+-def calculate_returns(data, signals, initial_capital=100000):
+-    """
+-    计算策略收益
+-    
+-    Args:
+-        data: 价格数据
+-        signals: 信号数据
+-        initial_capital: 初始资金
+-    
+-    Returns:
+-        收益数据
+-    """
+-    # 计算日收益率
+-    returns = data.pct_change()
+-    
+-    # 策略收益（假设每次信号产生1%的收益）
+-    strategy_returns = signals * 0.01
+-    
+-    # 累计收益
+-    cumulative_returns = strategy_returns.sum(axis=1).cumsum()
+-    
+-    # 资金曲线
+-    capital_curve = initial_capital * (1 + cumulative_returns)
+-    
+-    return {
+-        'strategy_returns': strategy_returns,
+-        'cumulative_returns': cumulative_returns,
+-        'capital_curve': capital_curve
+-    }
+-
+-
+-def analyze_strategy(signals, returns_data):
+-    """
+-    分析策略表现
+-    
+-    Args:
+-        signals: 信号数据
+-        returns_data: 收益数据
+-    """
+-    print("=" * 50)
+-    print("均线交叉策略分析结果")
+-    print("=" * 50)
+-    
+-    # 信号统计
+-    buy_signals = (signals == 1).sum().sum()
+-    sell_signals = (signals == -1).sum().sum()
+-    
+-    print(f"买入信号数量: {buy_signals}")
+-    print(f"卖出信号数量: {sell_signals}")
+-    print(f"总信号数量: {buy_signals + sell_signals}")
+-    
+-    # 收益统计
+-    cumulative_returns = returns_data['cumulative_returns']
+-    capital_curve = returns_data['capital_curve']
+-    
+-    total_return = cumulative_returns.iloc[-1]
+-    annual_return = total_return / (len(cumulative_returns) / 252)
+-    
+-    print(f"\n收益统计:")
+-    print(f"总收益率: {total_return:.2%}")
+-    print(f"年化收益率: {annual_return:.2%}")
+-    print(f"最终资金: {capital_curve.iloc[-1]:,.0f}")
+-    
+-    # 风险统计
+-    daily_returns = returns_data['strategy_returns'].sum(axis=1)
+-    volatility = daily_returns.std() * np.sqrt(252)
+-    sharpe_ratio = annual_return / volatility if volatility > 0 else 0
+-    
+-    print(f"\n风险统计:")
+-    print(f"年化波动率: {volatility:.2%}")
+-    print(f"夏普比率: {sharpe_ratio:.2f}")
+-    print(f"胜率: {(daily_returns > 0).mean():.2%}")
+-
+-
+-def plot_results(data, signals, returns_data, stock_code):
+-    """
+-    绘制结果图表
+-    
+-    Args:
+-        data: 价格数据
+-        signals: 信号数据
+-        returns_data: 收益数据
+-        stock_code: 股票代码
+-    """
+-    fig, axes = plt.subplots(3, 1, figsize=(12, 10))
+-    
+-    # 绘制价格和均线
+-    axes[0].plot(data.index, data[stock_code], label='收盘价', alpha=0.7)
+-    short_ma = data[stock_code].rolling(window=5).mean()
+-    long_ma = data[stock_code].rolling(window=20).mean()
+-    axes[0].plot(data.index, short_ma, label='5日均线', alpha=0.8)
+-    axes[0].plot(data.index, long_ma, label='20日均线', alpha=0.8)
+-    
+-    # 标记买卖信号
+-    buy_signals = signals[stock_code] == 1
+-    sell_signals = signals[stock_code] == -1
+-    
+-    axes[0].scatter(data.index[buy_signals], data.loc[buy_signals, stock_code], 
+-                   color='red', marker='^', s=100, label='买入信号', alpha=0.8)
+-    axes[0].scatter(data.index[sell_signals], data.loc[sell_signals, stock_code], 
+-                   color='green', marker='v', s=100, label='卖出信号', alpha=0.8)
+-    
+-    axes[0].set_title(f'{stock_code} 价格走势与均线交叉信号')
+-    axes[0].legend()
+-    axes[0].grid(True, alpha=0.3)
+-    
+-    # 绘制累计收益
+-    axes[1].plot(returns_data['cumulative_returns'].index, 
+-                returns_data['cumulative_returns'].values, 
+-                label='累计收益', color='blue')
+-    axes[1].set_title('策略累计收益')
+-    axes[1].legend()
+-    axes[1].grid(True, alpha=0.3)
+-    
+-    # 绘制资金曲线
+-    axes[2].plot(returns_data['capital_curve'].index, 
+-                returns_data['capital_curve'].values, 
+-                label='资金曲线', color='green')
+-    axes[2].set_title('资金曲线')
+-    axes[2].legend()
+-    axes[2].grid(True, alpha=0.3)
+-    
+-    plt.tight_layout()
+-    plt.savefig('ma_cross_strategy_results.png', dpi=300, bbox_inches='tight')
+-    plt.show()
+-
+-
+-def main():
+-    """
+-    主函数
+-    """
+-    print("开始运行均线交叉策略...")
+-    
+-    # 初始化qlib
+-    if not init_qlib():
+-        return
+-    
+-    # 策略参数
+-    start_date = "2020-01-01"
+-    end_date = "2023-12-31"
+-    short_window = 5
+-    long_window = 20
+-    initial_capital = 100000
+-    
+-    # 获取股票列表
+-    try:
+-        instruments = D.list_instruments(instruments="csi300", start_time=start_date, end_time=end_date)
+-        print(f"获取到 {len(instruments)} 只股票")
+-        
+-        # 选择前5只股票进行演示
+-        demo_instruments = instruments[:5]
+-        print(f"选择演示股票: {demo_instruments}")
+-        
+-    except Exception as e:
+-        print(f"获取股票列表失败: {e}")
+-        # 使用默认股票列表
+-        demo_instruments = ['000001.SZ', '000002.SZ', '000858.SZ', '002415.SZ', '600036.SH']
+-        print(f"使用默认股票列表: {demo_instruments}")
+-    
+-    # 获取价格数据
+-    data = get_stock_data(demo_instruments, start_date, end_date)
+-    
+-    if data is None:
+-        print("无法获取数据，程序退出")
+-        return
+-    
+-    print(f"获取到价格数据，形状: {data.shape}")
+-    
+-    # 计算均线信号
+-    signals = calculate_ma_signals(data, short_window, long_window)
+-    
+-    # 计算收益
+-    returns_data = calculate_returns(data, signals, initial_capital)
+-    
+-    # 分析策略
+-    analyze_strategy(signals, returns_data)
+-    
+-    # 保存结果
+-    signals.to_csv("ma_cross_signals.csv")
+-    returns_data['cumulative_returns'].to_csv("ma_cross_cumulative_returns.csv")
+-    returns_data['capital_curve'].to_csv("ma_cross_capital_curve.csv")
+-    
+-    print("\n结果已保存到CSV文件:")
+-    print("- ma_cross_signals.csv: 买卖信号")
+-    print("- ma_cross_cumulative_returns.csv: 累计收益")
+-    print("- ma_cross_capital_curve.csv: 资金曲线")
+-    
+-    # 绘制图表（选择第一只股票）
+-    if len(demo_instruments) > 0:
+-        try:
+-            plot_results(data, signals, returns_data, demo_instruments[0])
+-            print("图表已保存为 ma_cross_strategy_results.png")
+-        except Exception as e:
+-            print(f"绘制图表失败: {e}")
+-    
+-    print("\n策略回测完成！")
+-
+-
+-if __name__ == "__main__":
+-    main() 
+\ No newline at end of file
+diff --git a/test/two_ema_stragety.py b/test/two_ema_stragety.py
+index a72e7e8..a9890c7 100644
+--- a/test/two_ema_stragety.py
++++ b/test/two_ema_stragety.py
+@@ -1,2 +1,98 @@
+-from qlib.contrib.strategy import 
+-from qlib.backtest import backtest
+\ No newline at end of file
++import pandas as pd
++
++from abc import ABC
++from typing import Dict, List, Text, Tuple, Union
++from qlib.data.dataset import Dataset
++from qlib.model.base import BaseModel
++from qlib.backtest.signal import Signal, create_signal_from
++from qlib.strategy.base import BaseStrategy
++from qlib.backtest.decision import Order, OrderDir, OrderHelper, TradeDecisionWO
++# from qlib.strategy import 
++# from qlib.backtest import backtest
++
++class InnerStrategy(BaseStrategy):
++    """
++    Inner strategy for order execution:
++    - Buy: if price < 200, buy all cash; else buy 200,000 worth.
++    - Sell: if price > 200, sell all; else sell half.
++    """
++    STOCK_CODE = "000858.SZ"
++
++    def generate_trade_decision(self, execute_result: list = None, action: str = None, amount: float = None):
++        # action: 'buy' or 'sell', amount: suggested amount (shares) from outer
++        position = self.trade_position
++        trade_step = self.trade_calendar.get_trade_step()
++        trade_start_time, trade_end_time = self.trade_calendar.get_step_time(trade_step)
++        order_helper = self.trade_exchange.get_order_helper()
++        orders = []
++        price = self.trade_exchange.get_deal_price(self.STOCK_CODE, trade_start_time, trade_end_time)
++        if action == 'buy':
++            cash = position.get_cash()
++            if price <= 0:
++                return TradeDecisionWO([], self)
++            if price < 200:
++                buy_amount = cash // price
++            else:
++                buy_amount = min(cash // price, 200000 // price)
++            buy_amount = int(buy_amount)
++            if buy_amount > 0:
++                order = order_helper.create(
++                    code=self.STOCK_CODE,
++                    amount=buy_amount,
++                    direction=OrderDir.BUY,
++                    start_time=trade_start_time,
++                    end_time=trade_end_time,
++                )
++                orders.append(order)
++        elif action == 'sell':
++            held_amount = position.get_stock_amount(self.STOCK_CODE)
++            if held_amount <= 0 or price <= 0:
++                return TradeDecisionWO([], self)
++            if price > 200:
++                sell_amount = held_amount
++            else:
++                sell_amount = held_amount // 2
++            sell_amount = int(sell_amount)
++            if sell_amount > 0:
++                order = order_helper.create(
++                    code=self.STOCK_CODE,
++                    amount=sell_amount,
++                    direction=OrderDir.SELL,
++                    start_time=trade_start_time,
++                    end_time=trade_end_time,
++                )
++                orders.append(order)
++        return TradeDecisionWO(orders, self)
++
++class OuterStrategy(BaseStrategy):
++    """
++    Outer strategy:
++    - If not holding Wuliangye, issues a buy order via inner strategy.
++    - If holding, checks if held for 25 days, if so, issues a sell order via inner strategy.
++    - Otherwise, holds.
++    """
++    STOCK_CODE = "000858.SZ"
++    HOLD_DAYS = 25
++    BAR = "day"
++
++    def __init__(self, *args, **kwargs):
++        super().__init__(*args, **kwargs)
++        self.inner_strategy = InnerStrategy()
++
++    def generate_trade_decision(self, execute_result: list = None):
++        position = self.trade_position
++        stock_list = position.get_stock_list()
++        trade_step = self.trade_calendar.get_trade_step()
++        trade_start_time, trade_end_time = self.trade_calendar.get_step_time(trade_step)
++        # Pass infra to inner strategy
++        self.inner_strategy.reset(level_infra=self.level_infra, common_infra=self.common_infra)
++        if self.STOCK_CODE in stock_list:
++            hold_days = position.get_stock_count(self.STOCK_CODE, self.BAR)
++            if hold_days >= self.HOLD_DAYS:
++                # Sell via inner strategy
++                return self.inner_strategy.generate_trade_decision(action='sell')
++        else:
++            # Buy via inner strategy
++            return self.inner_strategy.generate_trade_decision(action='buy')
++        # Otherwise, hold
++        return TradeDecisionWO([], self)
+\ No newline at end of file
diff --git a/mlruns/812028854715931404/e8a9b9f4f26e4fddb95d91dbd3e60311/artifacts/code_status.txt b/mlruns/812028854715931404/e8a9b9f4f26e4fddb95d91dbd3e60311/artifacts/code_status.txt
new file mode 100644
index 0000000..d9b6458
--- /dev/null
+++ b/mlruns/812028854715931404/e8a9b9f4f26e4fddb95d91dbd3e60311/artifacts/code_status.txt
@@ -0,0 +1,25 @@
+On branch main
+Your branch is up to date with 'origin/main'.
+
+Changes not staged for commit:
+  (use "git add/rm <file>..." to update what will be committed)
+  (use "git restore <file>..." to discard changes in working directory)
+	modified:   github/examples/benchmarks/LightGBM/workflow_config_lightgbm_Alpha1582.yaml
+	deleted:    test/README_MA_Strategy.md
+	modified:   test/damo1.py
+	modified:   test/demo2.ipynb
+	deleted:    test/ma_cross_strategy.py
+	deleted:    test/ma_cross_strategy_improved.py
+	deleted:    test/ma_strategy_demo.py
+	deleted:    test/simple_ma_strategy.py
+	modified:   test/two_ema_stragety.py
+
+Untracked files:
+  (use "git add <file>..." to include in what will be committed)
+	github/examples/mlruns/881301994755452456/157579a2201241aaafcff94e93d7da0e/
+	mlruns/
+	test/__pycache__/
+	test/buy_and_hold.py
+	test/workflow_by_code.py
+
+no changes added to commit (use "git add" and/or "git commit -a")
diff --git a/mlruns/812028854715931404/e8a9b9f4f26e4fddb95d91dbd3e60311/meta.yaml b/mlruns/812028854715931404/e8a9b9f4f26e4fddb95d91dbd3e60311/meta.yaml
new file mode 100644
index 0000000..ecbf45f
--- /dev/null
+++ b/mlruns/812028854715931404/e8a9b9f4f26e4fddb95d91dbd3e60311/meta.yaml
@@ -0,0 +1,14 @@
+artifact_uri: file:D:\project\python\tradenote\mlruns/812028854715931404/e8a9b9f4f26e4fddb95d91dbd3e60311/artifacts
+end_time: 1750319831510
+entry_point_name: ''
+experiment_id: '812028854715931404'
+lifecycle_stage: active
+run_id: e8a9b9f4f26e4fddb95d91dbd3e60311
+run_name: mlflow_recorder
+source_name: ''
+source_type: 4
+source_version: ''
+start_time: 1750319831292
+status: 3
+tags: []
+user_id: abulimity
diff --git a/mlruns/812028854715931404/e8a9b9f4f26e4fddb95d91dbd3e60311/params/cmd-sys.argv b/mlruns/812028854715931404/e8a9b9f4f26e4fddb95d91dbd3e60311/params/cmd-sys.argv
new file mode 100644
index 0000000..db800eb
--- /dev/null
+++ b/mlruns/812028854715931404/e8a9b9f4f26e4fddb95d91dbd3e60311/params/cmd-sys.argv
@@ -0,0 +1 @@
+D:\project\python\tradenote\test\workflow_by_code.py
\ No newline at end of file
diff --git a/mlruns/812028854715931404/e8a9b9f4f26e4fddb95d91dbd3e60311/tags/mlflow.runName b/mlruns/812028854715931404/e8a9b9f4f26e4fddb95d91dbd3e60311/tags/mlflow.runName
new file mode 100644
index 0000000..25487e4
--- /dev/null
+++ b/mlruns/812028854715931404/e8a9b9f4f26e4fddb95d91dbd3e60311/tags/mlflow.runName
@@ -0,0 +1 @@
+mlflow_recorder
\ No newline at end of file
diff --git a/mlruns/812028854715931404/e8a9b9f4f26e4fddb95d91dbd3e60311/tags/mlflow.source.git.commit b/mlruns/812028854715931404/e8a9b9f4f26e4fddb95d91dbd3e60311/tags/mlflow.source.git.commit
new file mode 100644
index 0000000..288ce21
--- /dev/null
+++ b/mlruns/812028854715931404/e8a9b9f4f26e4fddb95d91dbd3e60311/tags/mlflow.source.git.commit
@@ -0,0 +1 @@
+0daea9b5bbb40120a1bc07c702d171abc1f219c7
\ No newline at end of file
diff --git a/mlruns/812028854715931404/e8a9b9f4f26e4fddb95d91dbd3e60311/tags/mlflow.source.name b/mlruns/812028854715931404/e8a9b9f4f26e4fddb95d91dbd3e60311/tags/mlflow.source.name
new file mode 100644
index 0000000..db800eb
--- /dev/null
+++ b/mlruns/812028854715931404/e8a9b9f4f26e4fddb95d91dbd3e60311/tags/mlflow.source.name
@@ -0,0 +1 @@
+D:\project\python\tradenote\test\workflow_by_code.py
\ No newline at end of file
diff --git a/mlruns/812028854715931404/e8a9b9f4f26e4fddb95d91dbd3e60311/tags/mlflow.source.type b/mlruns/812028854715931404/e8a9b9f4f26e4fddb95d91dbd3e60311/tags/mlflow.source.type
new file mode 100644
index 0000000..0c2c1fe
--- /dev/null
+++ b/mlruns/812028854715931404/e8a9b9f4f26e4fddb95d91dbd3e60311/tags/mlflow.source.type
@@ -0,0 +1 @@
+LOCAL
\ No newline at end of file
diff --git a/mlruns/812028854715931404/e8a9b9f4f26e4fddb95d91dbd3e60311/tags/mlflow.user b/mlruns/812028854715931404/e8a9b9f4f26e4fddb95d91dbd3e60311/tags/mlflow.user
new file mode 100644
index 0000000..b9cec6f
--- /dev/null
+++ b/mlruns/812028854715931404/e8a9b9f4f26e4fddb95d91dbd3e60311/tags/mlflow.user
@@ -0,0 +1 @@
+abulimity
\ No newline at end of file
diff --git a/mlruns/812028854715931404/e8bfc974f0864ad6bdaccc2b9156e975/artifacts/code_cached.txt b/mlruns/812028854715931404/e8bfc974f0864ad6bdaccc2b9156e975/artifacts/code_cached.txt
new file mode 100644
index 0000000..e69de29
diff --git a/mlruns/812028854715931404/e8bfc974f0864ad6bdaccc2b9156e975/artifacts/code_diff.txt b/mlruns/812028854715931404/e8bfc974f0864ad6bdaccc2b9156e975/artifacts/code_diff.txt
new file mode 100644
index 0000000..37c25d9
--- /dev/null
+++ b/mlruns/812028854715931404/e8bfc974f0864ad6bdaccc2b9156e975/artifacts/code_diff.txt
@@ -0,0 +1,1640 @@
+diff --git a/github/examples/benchmarks/LightGBM/workflow_config_lightgbm_Alpha1582.yaml b/github/examples/benchmarks/LightGBM/workflow_config_lightgbm_Alpha1582.yaml
+index 8b4e7bf..7a5eee7 100644
+--- a/github/examples/benchmarks/LightGBM/workflow_config_lightgbm_Alpha1582.yaml
++++ b/github/examples/benchmarks/LightGBM/workflow_config_lightgbm_Alpha1582.yaml
+@@ -1,5 +1,5 @@
+ qlib_init:
+-    provider_uri: "D:/project/tradenote/qlib_data/cn_data"
++    provider_uri: "D:/sync/qlib/qlib_data/cn_data"
+     region: cn
+ market: &market csi300
+ benchmark: &benchmark SH000300
+diff --git a/test/README_MA_Strategy.md b/test/README_MA_Strategy.md
+deleted file mode 100644
+index 5facaf7..0000000
+--- a/test/README_MA_Strategy.md
++++ /dev/null
+@@ -1,197 +0,0 @@
+-# 均线交叉策略 (Moving Average Crossover Strategy)
+-
+-## 策略概述
+-
+-这是一个基于qlib框架实现的均线交叉策略，核心逻辑是：
+-- **金叉买入**：短期均线上穿长期均线时买入
+-- **死叉卖出**：短期均线下穿长期均线时卖出
+-
+-## 文件说明
+-
+-### 1. `ma_cross_strategy.py`
+-完整的策略实现，包含：
+-- `MACrossStrategy` 类：继承自qlib的TopkDropoutStrategy
+-- 完整的回测框架
+-- 结果分析和保存
+-
+-### 2. `ma_cross_strategy_improved.py`
+-改进版本，包含：
+-- 更完善的数据获取逻辑
+-- 错误处理机制
+-- 简化版回测功能
+-
+-### 3. `simple_ma_strategy.py` ⭐ **推荐使用**
+-简单实用的版本，包含：
+-- 清晰的数据获取和处理
+-- 均线信号计算
+-- 收益计算和分析
+-- 可视化图表生成
+-- 结果保存功能
+-
+-## 使用方法
+-
+-### 环境准备
+-
+-1. 确保已安装qlib：
+-```bash
+-pip install pyqlib
+-```
+-
+-2. 下载qlib数据（如果还没有）：
+-```bash
+-# 下载中国股票数据
+-python -m qlib.data.dump_bin --csv_path ~/.qlib/qlib_data/cn_data --include_fields close,open,high,low,volume
+-```
+-
+-### 运行策略
+-
+-#### 方法1：运行简单版本（推荐）
+-```bash
+-cd test
+-python simple_ma_strategy.py
+-```
+-
+-#### 方法2：运行完整版本
+-```bash
+-cd test
+-python ma_cross_strategy.py
+-```
+-
+-#### 方法3：运行改进版本
+-```bash
+-cd test
+-python ma_cross_strategy_improved.py
+-```
+-
+-## 策略参数
+-
+-可以在代码中修改以下参数：
+-
+-```python
+-# 均线周期
+-short_window = 5    # 短期均线周期
+-long_window = 20    # 长期均线周期
+-
+-# 回测时间
+-start_date = "2020-01-01"
+-end_date = "2023-12-31"
+-
+-# 初始资金
+-initial_capital = 100000
+-
+-# 股票池
+-instruments = "csi300"  # 沪深300成分股
+-```
+-
+-## 输出结果
+-
+-运行策略后会生成以下文件：
+-
+-1. **CSV文件**：
+-   - `ma_cross_signals.csv`：买卖信号数据
+-   - `ma_cross_cumulative_returns.csv`：累计收益数据
+-   - `ma_cross_capital_curve.csv`：资金曲线数据
+-
+-2. **图表文件**：
+-   - `ma_cross_strategy_results.png`：策略结果可视化图表
+-
+-3. **控制台输出**：
+-   - 策略分析结果
+-   - 收益统计
+-   - 风险指标
+-
+-## 策略分析指标
+-
+-### 收益指标
+-- 总收益率
+-- 年化收益率
+-- 最终资金
+-
+-### 风险指标
+-- 年化波动率
+-- 夏普比率
+-- 胜率
+-- 最大回撤
+-
+-### 交易统计
+-- 买入信号数量
+-- 卖出信号数量
+-- 总交易次数
+-
+-## 策略逻辑详解
+-
+-### 1. 均线计算
+-```python
+-# 计算短期和长期均线
+-short_ma = price_data.rolling(window=short_window).mean()
+-long_ma = price_data.rolling(window=long_window).mean()
+-```
+-
+-### 2. 交叉信号判断
+-```python
+-# 计算均线差值
+-diff = short_ma - long_ma
+-
+-# 金叉：短期均线从下方穿越长期均线
+-if diff.iloc[i-1] < 0 and diff.iloc[i] > 0:
+-    signal = 1  # 买入信号
+-
+-# 死叉：短期均线从上方穿越长期均线
+-elif diff.iloc[i-1] > 0 and diff.iloc[i] < 0:
+-    signal = -1  # 卖出信号
+-```
+-
+-### 3. 收益计算
+-```python
+-# 策略收益（简化处理）
+-strategy_returns = signals * 0.01
+-
+-# 累计收益
+-cumulative_returns = strategy_returns.sum(axis=1).cumsum()
+-```
+-
+-## 注意事项
+-
+-1. **数据依赖**：确保qlib数据已正确下载和配置
+-2. **参数调优**：可以根据不同市场环境调整均线周期
+-3. **风险控制**：实际交易中需要加入止损和仓位管理
+-4. **交易成本**：当前版本未考虑交易费用，实际应用需要考虑
+-
+-## 扩展功能
+-
+-可以基于此策略进行以下扩展：
+-
+-1. **多均线策略**：使用多条均线进行更复杂的信号判断
+-2. **量价配合**：结合成交量指标优化信号
+-3. **止损机制**：添加动态止损策略
+-4. **仓位管理**：根据信号强度调整仓位大小
+-5. **多股票组合**：构建股票组合分散风险
+-
+-## 常见问题
+-
+-### Q: 如何修改股票池？
+-A: 在代码中修改 `instruments` 参数，例如：
+-```python
+-instruments = "csi500"  # 中证500
+-instruments = ["000001.SZ", "000002.SZ"]  # 指定股票列表
+-```
+-
+-### Q: 如何调整均线周期？
+-A: 修改 `short_window` 和 `long_window` 参数：
+-```python
+-short_window = 10  # 10日均线
+-long_window = 30   # 30日均线
+-```
+-
+-### Q: 如何查看详细的交易记录？
+-A: 查看生成的 `ma_cross_signals.csv` 文件，其中包含每日的买卖信号。
+-
+-## 联系方式
+-
+-如有问题或建议，请通过以下方式联系：
+-- 提交Issue到项目仓库
+-- 发送邮件到项目维护者
+-
+----
+-
+-**免责声明**：本策略仅供学习和研究使用，不构成投资建议。实际投资请谨慎决策，并承担相应风险。 
+\ No newline at end of file
+diff --git a/test/damo1.py b/test/damo1.py
+index 03102e1..8dadef5 100644
+--- a/test/damo1.py
++++ b/test/damo1.py
+@@ -1,9 +1,36 @@
+-# python scripts/get_data.py qlib_data --target_dir ../qlib_data/cn_data --region cn
+-
+ import qlib
+-# region in [REG_CN, REG_US]
+-from qlib.constant import REG_CN
+-provider_uri = "D:/project/tradenote/qlib_data/cn_data"  # target_dir
+-qlib.init(provider_uri=provider_uri, region=REG_CN)
++from qlib.data import D
++
++# 初始化 Qlib
++qlib.init(provider_uri="D:/project/python/tradenote/qlibz/qlib_data/cn_data", region="cn")
++
++# 检查目标股票和基准
++stock_code = "SZ000858"  # 你的BuyHold策略用的股票代码
++benchmark = "SH000300"
++
++print("--- 检查可用股票列表（前10只） ---")
++print("全部股票：", list(D.instruments(market="all")))
++
++print("--- 检查交易日（2017-01-01 ~ 2020-08-01，前10天） ---")
++print(D.calendar(start_time="2017-01-01", end_time="2020-08-01")[:10])
++
++print(f"--- 检查目标股票 {stock_code} 是否在股票池 ---")
++print(stock_code in D.instruments(market="all"))
++
++print(f"--- 检查基准 {benchmark} 是否在股票池 ---")
++print(benchmark in D.instruments(market="all"))
++
++print(f"--- 检查目标股票 {stock_code} 的行情数据（前5行） ---")
++try:
++    df = D.features([stock_code], ["$close", "$open", "$high", "$low", "$volume"], start_time="2017-01-01", end_time="2020-08-01")
++    print(df.head())
++except Exception as e:
++    print(f"获取行情数据失败: {e}")
+ 
+-# qrun benchmarks/LightGBM/workflow_config_lightgbm_Alpha1582.yaml
++print(f"--- 检查基准 {benchmark} 的行情数据（前5行） ---")
++try:
++    df_bench = D.features([benchmark], ["$close"], start_time="2017-01-01", end_time="2020-08-01")
++    print(df_bench.head())
++except Exception as e:
++    print(f"获取基准行情数据失败: {e}")
++# python scripts/get_data.py qlib_data --target_dir D:/project/python/tradenote/qlibz/qlib_data/cn_data --region cn
+\ No newline at end of file
+diff --git a/test/demo2.ipynb b/test/demo2.ipynb
+index 66a0215..842a49e 100644
+--- a/test/demo2.ipynb
++++ b/test/demo2.ipynb
+@@ -2,7 +2,7 @@
+  "cells": [
+   {
+    "cell_type": "code",
+-   "execution_count": 4,
++   "execution_count": 12,
+    "id": "6acb4a77",
+    "metadata": {},
+    "outputs": [
+@@ -10,39 +10,205 @@
+      "name": "stderr",
+      "output_type": "stream",
+      "text": [
+-      "[5344:MainThread](2025-06-18 14:41:03,895) INFO - qlib.Initialization - [config.py:420] - default_conf: client.\n",
+-      "[5344:MainThread](2025-06-18 14:41:03,900) INFO - qlib.Initialization - [__init__.py:74] - qlib successfully initialized based on client settings.\n",
+-      "[5344:MainThread](2025-06-18 14:41:03,903) INFO - qlib.Initialization - [__init__.py:76] - data_path={'__DEFAULT_FREQ': WindowsPath('D:/sync/qlib/qlib_data/cn_data')}\n"
++      "[13736:MainThread](2025-06-19 15:30:19,504) INFO - qlib.Initialization - [config.py:420] - default_conf: client.\n",
++      "[13736:MainThread](2025-06-19 15:30:19,506) INFO - qlib.Initialization - [__init__.py:74] - qlib successfully initialized based on client settings.\n",
++      "[13736:MainThread](2025-06-19 15:30:19,508) INFO - qlib.Initialization - [__init__.py:76] - data_path={'__DEFAULT_FREQ': WindowsPath('D:/sync/qlib/qlib_data/cn_data')}\n"
+      ]
+     }
+    ],
+    "source": [
+     "import qlib\n",
+-    "qlib.init(provider_uri=\"D:/sync/qlib/qlib_data/cn_data\", region=\"cn\")"
++    "qlib.init(provider_uri=r\"D:\\sync\\qlib\\qlib_data\\cn_data\", region=\"cn\")"
+    ]
+   },
+   {
+    "cell_type": "code",
+-   "execution_count": 12,
++   "execution_count": 14,
+    "id": "295df9af",
+    "metadata": {},
+    "outputs": [
+     {
+      "data": {
+       "text/plain": [
+-       "array([Timestamp('2020-09-21 00:00:00'), Timestamp('2020-09-22 00:00:00'),\n",
+-       "       Timestamp('2020-09-23 00:00:00'), Timestamp('2020-09-24 00:00:00'),\n",
+-       "       Timestamp('2020-09-25 00:00:00')], dtype=object)"
++       "array([Timestamp('2017-01-03 00:00:00'), Timestamp('2017-01-04 00:00:00'),\n",
++       "       Timestamp('2017-01-05 00:00:00'), Timestamp('2017-01-06 00:00:00'),\n",
++       "       Timestamp('2017-01-09 00:00:00')], dtype=object)"
+       ]
+      },
+-     "execution_count": 12,
++     "execution_count": 14,
+      "metadata": {},
+      "output_type": "execute_result"
+     }
+    ],
+    "source": [
+     "from qlib.data import D\n",
+-    "D.calendar(start_time='2020-09-21', end_time='2020-10-30', freq='day')"
++    "D.calendar(start_time=\"2017-01-01\", end_time=\"2020-08-01\",freq=\"day\")[:5]"
++   ]
++  },
++  {
++   "cell_type": "code",
++   "execution_count": 24,
++   "id": "da009afa",
++   "metadata": {},
++   "outputs": [
++    {
++     "data": {
++      "text/html": [
++       "<div>\n",
++       "<style scoped>\n",
++       "    .dataframe tbody tr th:only-of-type {\n",
++       "        vertical-align: middle;\n",
++       "    }\n",
++       "\n",
++       "    .dataframe tbody tr th {\n",
++       "        vertical-align: top;\n",
++       "    }\n",
++       "\n",
++       "    .dataframe thead th {\n",
++       "        text-align: right;\n",
++       "    }\n",
++       "</style>\n",
++       "<table border=\"1\" class=\"dataframe\">\n",
++       "  <thead>\n",
++       "    <tr style=\"text-align: right;\">\n",
++       "      <th></th>\n",
++       "      <th></th>\n",
++       "      <th>$close</th>\n",
++       "      <th>$open</th>\n",
++       "      <th>$high</th>\n",
++       "      <th>$low</th>\n",
++       "      <th>$volume</th>\n",
++       "    </tr>\n",
++       "    <tr>\n",
++       "      <th>instrument</th>\n",
++       "      <th>datetime</th>\n",
++       "      <th></th>\n",
++       "      <th></th>\n",
++       "      <th></th>\n",
++       "      <th></th>\n",
++       "      <th></th>\n",
++       "    </tr>\n",
++       "  </thead>\n",
++       "  <tbody>\n",
++       "    <tr>\n",
++       "      <th rowspan=\"11\" valign=\"top\">SZ000858</th>\n",
++       "      <th>2017-01-03</th>\n",
++       "      <td>11.301954</td>\n",
++       "      <td>11.243259</td>\n",
++       "      <td>11.373693</td>\n",
++       "      <td>11.184565</td>\n",
++       "      <td>47640796.0</td>\n",
++       "    </tr>\n",
++       "    <tr>\n",
++       "      <th>2017-01-04</th>\n",
++       "      <td>11.706295</td>\n",
++       "      <td>11.301954</td>\n",
++       "      <td>11.722599</td>\n",
++       "      <td>11.266086</td>\n",
++       "      <td>141233984.0</td>\n",
++       "    </tr>\n",
++       "    <tr>\n",
++       "      <th>2017-01-05</th>\n",
++       "      <td>11.716078</td>\n",
++       "      <td>11.748685</td>\n",
++       "      <td>11.817163</td>\n",
++       "      <td>11.641079</td>\n",
++       "      <td>79170360.0</td>\n",
++       "    </tr>\n",
++       "    <tr>\n",
++       "      <th>2017-01-06</th>\n",
++       "      <td>11.771510</td>\n",
++       "      <td>11.716077</td>\n",
++       "      <td>11.934550</td>\n",
++       "      <td>11.660643</td>\n",
++       "      <td>103201592.0</td>\n",
++       "    </tr>\n",
++       "    <tr>\n",
++       "      <th>2017-01-09</th>\n",
++       "      <td>11.885638</td>\n",
++       "      <td>11.738902</td>\n",
++       "      <td>11.999766</td>\n",
++       "      <td>11.716077</td>\n",
++       "      <td>81857808.0</td>\n",
++       "    </tr>\n",
++       "    <tr>\n",
++       "      <th>...</th>\n",
++       "      <td>...</td>\n",
++       "      <td>...</td>\n",
++       "      <td>...</td>\n",
++       "      <td>...</td>\n",
++       "      <td>...</td>\n",
++       "    </tr>\n",
++       "    <tr>\n",
++       "      <th>2020-07-27</th>\n",
++       "      <td>71.358727</td>\n",
++       "      <td>71.110489</td>\n",
++       "      <td>72.302719</td>\n",
++       "      <td>70.418228</td>\n",
++       "      <td>69948368.0</td>\n",
++       "    </tr>\n",
++       "    <tr>\n",
++       "      <th>2020-07-28</th>\n",
++       "      <td>74.816528</td>\n",
++       "      <td>71.984558</td>\n",
++       "      <td>75.847931</td>\n",
++       "      <td>71.558014</td>\n",
++       "      <td>108913296.0</td>\n",
++       "    </tr>\n",
++       "    <tr>\n",
++       "      <th>2020-07-29</th>\n",
++       "      <td>75.173149</td>\n",
++       "      <td>74.942398</td>\n",
++       "      <td>75.337471</td>\n",
++       "      <td>73.075386</td>\n",
++       "      <td>85012816.0</td>\n",
++       "    </tr>\n",
++       "    <tr>\n",
++       "      <th>2020-07-30</th>\n",
++       "      <td>75.704582</td>\n",
++       "      <td>74.820023</td>\n",
++       "      <td>76.236015</td>\n",
++       "      <td>74.470398</td>\n",
++       "      <td>71618128.0</td>\n",
++       "    </tr>\n",
++       "    <tr>\n",
++       "      <th>2020-07-31</th>\n",
++       "      <td>76.054207</td>\n",
++       "      <td>75.697586</td>\n",
++       "      <td>77.270905</td>\n",
++       "      <td>74.917923</td>\n",
++       "      <td>74252152.0</td>\n",
++       "    </tr>\n",
++       "  </tbody>\n",
++       "</table>\n",
++       "<p>871 rows × 5 columns</p>\n",
++       "</div>"
++      ],
++      "text/plain": [
++       "                          $close      $open      $high       $low      $volume\n",
++       "instrument datetime                                                           \n",
++       "SZ000858   2017-01-03  11.301954  11.243259  11.373693  11.184565   47640796.0\n",
++       "           2017-01-04  11.706295  11.301954  11.722599  11.266086  141233984.0\n",
++       "           2017-01-05  11.716078  11.748685  11.817163  11.641079   79170360.0\n",
++       "           2017-01-06  11.771510  11.716077  11.934550  11.660643  103201592.0\n",
++       "           2017-01-09  11.885638  11.738902  11.999766  11.716077   81857808.0\n",
++       "...                          ...        ...        ...        ...          ...\n",
++       "           2020-07-27  71.358727  71.110489  72.302719  70.418228   69948368.0\n",
++       "           2020-07-28  74.816528  71.984558  75.847931  71.558014  108913296.0\n",
++       "           2020-07-29  75.173149  74.942398  75.337471  73.075386   85012816.0\n",
++       "           2020-07-30  75.704582  74.820023  76.236015  74.470398   71618128.0\n",
++       "           2020-07-31  76.054207  75.697586  77.270905  74.917923   74252152.0\n",
++       "\n",
++       "[871 rows x 5 columns]"
++      ]
++     },
++     "execution_count": 24,
++     "metadata": {},
++     "output_type": "execute_result"
++    }
++   ],
++   "source": [
++    "D.features([\"SZ000858\"], [\"$close\", \"$open\", \"$high\", \"$low\", \"$volume\"], start_time=\"2017-01-01\", end_time=\"2020-08-01\")"
+    ]
+   }
+  ],
+diff --git a/test/ma_cross_strategy.py b/test/ma_cross_strategy.py
+deleted file mode 100644
+index 719d849..0000000
+--- a/test/ma_cross_strategy.py
++++ /dev/null
+@@ -1,274 +0,0 @@
+-"""
+-均线交叉策略：金叉买入，死叉卖出
+-使用qlib框架实现
+-"""
+-
+-import qlib
+-from qlib.constant import REG_CN
+-from qlib.utils import init_instance_by_config
+-from qlib.workflow import R
+-from qlib.workflow.record_temp import SignalRecord, PortAnaRecord
+-from qlib.contrib.evaluate import backtest_daily
+-from qlib.contrib.strategy import TopkDropoutStrategy
+-import pandas as pd
+-import numpy as np
+-from typing import Dict, List, Tuple
+-
+-
+-class MACrossStrategy(TopkDropoutStrategy):
+-    """
+-    均线交叉策略
+-    金叉（短期均线上穿长期均线）买入
+-    死叉（短期均线下穿长期均线）卖出
+-    """
+-    
+-    def __init__(self, 
+-                 short_window: int = 5,
+-                 long_window: int = 20,
+-                 topk: int = 50,
+-                 n_drop: int = 5,
+-                 **kwargs):
+-        """
+-        初始化策略参数
+-        
+-        Args:
+-            short_window: 短期均线周期
+-            long_window: 长期均线周期
+-            topk: 选择前k只股票
+-            n_drop: 剔除前n只股票
+-        """
+-        super().__init__(topk=topk, n_drop=n_drop, **kwargs)
+-        self.short_window = short_window
+-        self.long_window = long_window
+-        
+-    def generate_trade_decision(self, score: pd.Series, trade_step: int) -> pd.Series:
+-        """
+-        生成交易决策
+-        
+-        Args:
+-            score: 股票评分
+-            trade_step: 交易步骤
+-            
+-        Returns:
+-            交易决策，1表示买入，-1表示卖出，0表示持有
+-        """
+-        # 获取当前持仓
+-        current_pos = self.get_current_position()
+-        
+-        # 计算均线信号
+-        signal = self._calculate_ma_signal(score.index.tolist(), trade_step)
+-        
+-        # 生成交易决策
+-        decision = pd.Series(0, index=score.index)
+-        
+-        # 金叉买入信号
+-        buy_signal = signal == 1
+-        decision[buy_signal] = 1
+-        
+-        # 死叉卖出信号
+-        sell_signal = signal == -1
+-        decision[sell_signal] = -1
+-        
+-        return decision
+-    
+-    def _calculate_ma_signal(self, instruments: List[str], trade_step: int) -> pd.Series:
+-        """
+-        计算均线交叉信号
+-        
+-        Args:
+-            instruments: 股票代码列表
+-            trade_step: 交易步骤
+-            
+-        Returns:
+-            信号序列：1表示金叉买入，-1表示死叉卖出，0表示无信号
+-        """
+-        # 获取历史数据
+-        data = self._get_historical_data(instruments, trade_step)
+-        
+-        signals = pd.Series(0, index=instruments)
+-        
+-        for instrument in instruments:
+-            if instrument in data.index:
+-                # 计算短期和长期均线
+-                short_ma = data.loc[instrument].rolling(window=self.short_window).mean()
+-                long_ma = data.loc[instrument].rolling(window=self.long_window).mean()
+-                
+-                # 计算交叉信号
+-                if len(short_ma) >= 2 and len(long_ma) >= 2:
+-                    # 当前和前一个时间点的均线差值
+-                    current_diff = short_ma.iloc[-1] - long_ma.iloc[-1]
+-                    prev_diff = short_ma.iloc[-2] - long_ma.iloc[-2]
+-                    
+-                    # 金叉：短期均线从下方穿越长期均线
+-                    if prev_diff < 0 and current_diff > 0:
+-                        signals[instrument] = 1
+-                    # 死叉：短期均线从上方穿越长期均线
+-                    elif prev_diff > 0 and current_diff < 0:
+-                        signals[instrument] = -1
+-        
+-        return signals
+-    
+-    def _get_historical_data(self, instruments: List[str], trade_step: int) -> pd.DataFrame:
+-        """
+-        获取历史价格数据
+-        
+-        Args:
+-            instruments: 股票代码列表
+-            trade_step: 交易步骤
+-            
+-        Returns:
+-            历史价格数据
+-        """
+-        # 这里简化处理，实际应该从qlib数据源获取
+-        # 在实际应用中，您需要使用qlib的数据接口
+-        try:
+-            # 获取最近的数据用于计算均线
+-            # 这里使用模拟数据，实际应该从qlib获取
+-            dates = pd.date_range(end=pd.Timestamp.now(), periods=50, freq='D')
+-            data = pd.DataFrame(
+-                np.random.randn(len(dates), len(instruments)) * 0.02 + 1.0,
+-                index=dates,
+-                columns=instruments
+-            )
+-            return data
+-        except Exception as e:
+-            print(f"获取历史数据失败: {e}")
+-            return pd.DataFrame()
+-
+-
+-def create_ma_cross_strategy_config():
+-    """
+-    创建均线交叉策略配置
+-    """
+-    strategy_config = {
+-        "class": "MACrossStrategy",
+-        "module_path": "test.ma_cross_strategy",
+-        "kwargs": {
+-            "short_window": 5,
+-            "long_window": 20,
+-            "topk": 50,
+-            "n_drop": 5,
+-        }
+-    }
+-    
+-    return strategy_config
+-
+-
+-def run_backtest():
+-    """
+-    运行回测
+-    """
+-    # 初始化qlib
+-    qlib.init(provider_uri='~/.qlib/qlib_data/cn_data', region=REG_CN)
+-    
+-    # 策略配置
+-    strategy_config = create_ma_cross_strategy_config()
+-    
+-    # 回测配置
+-    backtest_config = {
+-        "start_time": "2020-01-01",
+-        "end_time": "2023-12-31",
+-        "benchmark": "SH000300",  # 沪深300作为基准
+-        "account": 100000000,     # 初始资金1亿
+-        "exchange_kwargs": {
+-            "freq": "day",
+-            "limit_threshold": 0.095,
+-            "deal_price": "close",
+-            "open_cost": 0.0005,
+-            "close_cost": 0.0015,
+-            "min_cost": 5,
+-        }
+-    }
+-    
+-    # 创建策略实例
+-    strategy = init_instance_by_config(strategy_config)
+-    
+-    # 运行回测
+-    with R.start(experiment_name="ma_cross_strategy"):
+-        # 记录信号
+-        sr = SignalRecord(model=strategy, dataset=None, recorder=R.get_recorder())
+-        sr.generate()
+-        
+-        # 记录投资组合分析
+-        par = PortAnaRecord(recorder=R.get_recorder(), config=backtest_config, strategy=strategy)
+-        par.generate()
+-        
+-        # 获取回测结果
+-        report_normal, positions_normal = backtest_daily(
+-            account=backtest_config["account"],
+-            benchmark=backtest_config["benchmark"],
+-            start_time=backtest_config["start_time"],
+-            end_time=backtest_config["end_time"],
+-            strategy=strategy,
+-            exchange_kwargs=backtest_config["exchange_kwargs"]
+-        )
+-        
+-        return report_normal, positions_normal
+-
+-
+-def analyze_results(report: pd.DataFrame, positions: pd.DataFrame):
+-    """
+-    分析回测结果
+-    
+-    Args:
+-        report: 回测报告
+-        positions: 持仓信息
+-    """
+-    print("=" * 50)
+-    print("均线交叉策略回测结果")
+-    print("=" * 50)
+-    
+-    # 基本统计信息
+-    print(f"总收益率: {report['return'].sum():.2%}")
+-    print(f"年化收益率: {report['return'].mean() * 252:.2%}")
+-    print(f"最大回撤: {report['drawdown'].min():.2%}")
+-    print(f"夏普比率: {report['sharpe'].iloc[-1]:.2f}")
+-    print(f"胜率: {(report['return'] > 0).mean():.2%}")
+-    
+-    # 风险指标
+-    volatility = report['return'].std() * np.sqrt(252)
+-    print(f"年化波动率: {volatility:.2%}")
+-    
+-    # 最大回撤期间
+-    max_drawdown_idx = report['drawdown'].idxmin()
+-    print(f"最大回撤发生时间: {max_drawdown_idx}")
+-    
+-    # 收益分布
+-    print("\n收益分布统计:")
+-    print(f"平均日收益: {report['return'].mean():.2%}")
+-    print(f"收益标准差: {report['return'].std():.2%}")
+-    print(f"最小日收益: {report['return'].min():.2%}")
+-    print(f"最大日收益: {report['return'].max():.2%}")
+-    
+-    # 交易统计
+-    if 'trade_count' in report.columns:
+-        print(f"\n总交易次数: {report['trade_count'].sum()}")
+-        print(f"平均每日交易次数: {report['trade_count'].mean():.1f}")
+-
+-
+-def main():
+-    """
+-    主函数
+-    """
+-    print("开始运行均线交叉策略回测...")
+-    
+-    try:
+-        # 运行回测
+-        report, positions = run_backtest()
+-        
+-        # 分析结果
+-        analyze_results(report, positions)
+-        
+-        # 保存结果
+-        report.to_csv("ma_cross_strategy_report.csv")
+-        positions.to_csv("ma_cross_strategy_positions.csv")
+-        
+-        print("\n回测完成！结果已保存到CSV文件。")
+-        
+-    except Exception as e:
+-        print(f"回测过程中出现错误: {e}")
+-        print("请确保已正确安装qlib并下载了相应的数据。")
+-
+-
+-if __name__ == "__main__":
+-    main() 
+\ No newline at end of file
+diff --git a/test/ma_cross_strategy_improved.py b/test/ma_cross_strategy_improved.py
+deleted file mode 100644
+index d166c68..0000000
+--- a/test/ma_cross_strategy_improved.py
++++ /dev/null
+@@ -1,443 +0,0 @@
+-"""
+-改进的均线交叉策略：金叉买入，死叉卖出
+-使用qlib框架实现，包含完整的数据获取和信号计算
+-"""
+-
+-import qlib
+-from qlib.constant import REG_CN
+-from qlib.utils import init_instance_by_config
+-from qlib.workflow import R
+-from qlib.workflow.record_temp import SignalRecord, PortAnaRecord
+-from qlib.contrib.evaluate import backtest_daily
+-from qlib.contrib.strategy import TopkDropoutStrategy
+-from qlib.data import D
+-from qlib.data.dataset import DatasetH
+-from qlib.data.dataset.handler import DataHandlerLP
+-import pandas as pd
+-import numpy as np
+-from typing import Dict, List, Tuple
+-import warnings
+-warnings.filterwarnings('ignore')
+-
+-
+-class MACrossStrategyImproved(TopkDropoutStrategy):
+-    """
+-    改进的均线交叉策略
+-    金叉（短期均线上穿长期均线）买入
+-    死叉（短期均线下穿长期均线）卖出
+-    """
+-    
+-    def __init__(self, 
+-                 short_window: int = 5,
+-                 long_window: int = 20,
+-                 topk: int = 50,
+-                 n_drop: int = 5,
+-                 universe: str = "csi300",
+-                 **kwargs):
+-        """
+-        初始化策略参数
+-        
+-        Args:
+-            short_window: 短期均线周期
+-            long_window: 长期均线周期
+-            topk: 选择前k只股票
+-            n_drop: 剔除前n只股票
+-            universe: 股票池
+-        """
+-        super().__init__(topk=topk, n_drop=n_drop, **kwargs)
+-        self.short_window = short_window
+-        self.long_window = long_window
+-        self.universe = universe
+-        self.instruments = None
+-        self.price_cache = {}
+-        
+-    def generate_trade_decision(self, score: pd.Series, trade_step: int) -> pd.Series:
+-        """
+-        生成交易决策
+-        
+-        Args:
+-            score: 股票评分
+-            trade_step: 交易步骤
+-            
+-        Returns:
+-            交易决策，1表示买入，-1表示卖出，0表示持有
+-        """
+-        # 获取当前持仓
+-        current_pos = self.get_current_position()
+-        
+-        # 计算均线信号
+-        signal = self._calculate_ma_signal(score.index.tolist(), trade_step)
+-        
+-        # 生成交易决策
+-        decision = pd.Series(0, index=score.index)
+-        
+-        # 金叉买入信号
+-        buy_signal = signal == 1
+-        decision[buy_signal] = 1
+-        
+-        # 死叉卖出信号
+-        sell_signal = signal == -1
+-        decision[sell_signal] = -1
+-        
+-        return decision
+-    
+-    def _calculate_ma_signal(self, instruments: List[str], trade_step: int) -> pd.Series:
+-        """
+-        计算均线交叉信号
+-        
+-        Args:
+-            instruments: 股票代码列表
+-            trade_step: 交易步骤
+-            
+-        Returns:
+-            信号序列：1表示金叉买入，-1表示死叉卖出，0表示无信号
+-        """
+-        signals = pd.Series(0, index=instruments)
+-        
+-        # 获取当前日期
+-        current_date = self._get_current_date(trade_step)
+-        
+-        for instrument in instruments:
+-            try:
+-                # 获取历史价格数据
+-                price_data = self._get_price_data(instrument, current_date)
+-                
+-                if price_data is not None and len(price_data) >= self.long_window:
+-                    # 计算短期和长期均线
+-                    short_ma = price_data['close'].rolling(window=self.short_window).mean()
+-                    long_ma = price_data['close'].rolling(window=self.long_window).mean()
+-                    
+-                    # 计算交叉信号
+-                    if len(short_ma) >= 2 and len(long_ma) >= 2:
+-                        # 当前和前一个时间点的均线差值
+-                        current_diff = short_ma.iloc[-1] - long_ma.iloc[-1]
+-                        prev_diff = short_ma.iloc[-2] - long_ma.iloc[-2]
+-                        
+-                        # 金叉：短期均线从下方穿越长期均线
+-                        if prev_diff < 0 and current_diff > 0:
+-                            signals[instrument] = 1
+-                        # 死叉：短期均线从上方穿越长期均线
+-                        elif prev_diff > 0 and current_diff < 0:
+-                            signals[instrument] = -1
+-                            
+-            except Exception as e:
+-                print(f"计算{instrument}均线信号时出错: {e}")
+-                continue
+-        
+-        return signals
+-    
+-    def _get_price_data(self, instrument: str, current_date: str) -> pd.DataFrame:
+-        """
+-        获取股票价格数据
+-        
+-        Args:
+-            instrument: 股票代码
+-            current_date: 当前日期
+-            
+-        Returns:
+-            价格数据DataFrame
+-        """
+-        try:
+-            # 计算开始日期（获取足够的历史数据来计算均线）
+-            start_date = pd.Timestamp(current_date) - pd.Timedelta(days=self.long_window * 2)
+-            
+-            # 从qlib获取数据
+-            data = D.features(
+-                instruments=[instrument],
+-                start_time=start_date.strftime('%Y-%m-%d'),
+-                end_time=current_date,
+-                freq='day',
+-                fields=['$close', '$open', '$high', '$low', '$volume']
+-            )
+-            
+-            if data is not None and not data.empty:
+-                # 重命名列
+-                data.columns = ['close', 'open', 'high', 'low', 'volume']
+-                return data
+-            else:
+-                return None
+-                
+-        except Exception as e:
+-            print(f"获取{instrument}价格数据失败: {e}")
+-            return None
+-    
+-    def _get_current_date(self, trade_step: int) -> str:
+-        """
+-        根据交易步骤获取当前日期
+-        
+-        Args:
+-            trade_step: 交易步骤
+-            
+-        Returns:
+-            当前日期字符串
+-        """
+-        # 这里简化处理，实际应该从qlib的日历获取
+-        # 假设从2020-01-01开始，每个trade_step代表一天
+-        start_date = pd.Timestamp('2020-01-01')
+-        current_date = start_date + pd.Timedelta(days=trade_step)
+-        return current_date.strftime('%Y-%m-%d')
+-
+-
+-def create_dataset_config():
+-    """
+-    创建数据集配置
+-    """
+-    dataset_config = {
+-        "class": "DatasetH",
+-        "module_path": "qlib.data.dataset",
+-        "kwargs": {
+-            "handler": {
+-                "class": "DataHandlerLP",
+-                "module_path": "qlib.data.dataset.handler",
+-                "kwargs": {
+-                    "start_time": "2020-01-01",
+-                    "end_time": "2023-12-31",
+-                    "fit_start_time": "2020-01-01",
+-                    "fit_end_time": "2023-12-31",
+-                    "instruments": "csi300",
+-                    "infer_processors": [
+-                        {
+-                            "class": "RobustZScoreNorm",
+-                            "module_path": "qlib.data.dataset.processor",
+-                            "kwargs": {
+-                                "fields_group": "feature",
+-                                "clip_outlier": True,
+-                            },
+-                        },
+-                        {
+-                            "class": "Fillna",
+-                            "module_path": "qlib.data.dataset.processor",
+-                            "kwargs": {
+-                                "fields_group": "feature",
+-                            },
+-                        },
+-                    ],
+-                    "learn_processors": [
+-                        {
+-                            "class": "DropnaLabel",
+-                            "module_path": "qlib.data.dataset.processor",
+-                        },
+-                        {
+-                            "class": "CSRankNorm",
+-                            "module_path": "qlib.data.dataset.processor",
+-                            "kwargs": {
+-                                "fields_group": "label",
+-                            },
+-                        },
+-                    ],
+-                    "instruments": "csi300",
+-                },
+-            },
+-            "segments": {
+-                "train": ("2020-01-01", "2022-12-31"),
+-                "valid": ("2023-01-01", "2023-06-30"),
+-                "test": ("2023-07-01", "2023-12-31"),
+-            },
+-        },
+-    }
+-    
+-    return dataset_config
+-
+-
+-def create_ma_cross_strategy_config():
+-    """
+-    创建均线交叉策略配置
+-    """
+-    strategy_config = {
+-        "class": "MACrossStrategyImproved",
+-        "module_path": "test.ma_cross_strategy_improved",
+-        "kwargs": {
+-            "short_window": 5,
+-            "long_window": 20,
+-            "topk": 50,
+-            "n_drop": 5,
+-            "universe": "csi300",
+-        }
+-    }
+-    
+-    return strategy_config
+-
+-
+-def run_backtest():
+-    """
+-    运行回测
+-    """
+-    # 初始化qlib
+-    qlib.init(provider_uri='~/.qlib/qlib_data/cn_data', region=REG_CN)
+-    
+-    # 策略配置
+-    strategy_config = create_ma_cross_strategy_config()
+-    
+-    # 回测配置
+-    backtest_config = {
+-        "start_time": "2020-01-01",
+-        "end_time": "2023-12-31",
+-        "benchmark": "SH000300",  # 沪深300作为基准
+-        "account": 100000000,     # 初始资金1亿
+-        "exchange_kwargs": {
+-            "freq": "day",
+-            "limit_threshold": 0.095,
+-            "deal_price": "close",
+-            "open_cost": 0.0005,
+-            "close_cost": 0.0015,
+-            "min_cost": 5,
+-        }
+-    }
+-    
+-    # 创建策略实例
+-    strategy = init_instance_by_config(strategy_config)
+-    
+-    # 运行回测
+-    with R.start(experiment_name="ma_cross_strategy_improved"):
+-        # 记录信号
+-        sr = SignalRecord(model=strategy, dataset=None, recorder=R.get_recorder())
+-        sr.generate()
+-        
+-        # 记录投资组合分析
+-        par = PortAnaRecord(recorder=R.get_recorder(), config=backtest_config, strategy=strategy)
+-        par.generate()
+-        
+-        # 获取回测结果
+-        report_normal, positions_normal = backtest_daily(
+-            account=backtest_config["account"],
+-            benchmark=backtest_config["benchmark"],
+-            start_time=backtest_config["start_time"],
+-            end_time=backtest_config["end_time"],
+-            strategy=strategy,
+-            exchange_kwargs=backtest_config["exchange_kwargs"]
+-        )
+-        
+-        return report_normal, positions_normal
+-
+-
+-def analyze_results(report: pd.DataFrame, positions: pd.DataFrame):
+-    """
+-    分析回测结果
+-    
+-    Args:
+-        report: 回测报告
+-        positions: 持仓信息
+-    """
+-    print("=" * 50)
+-    print("均线交叉策略回测结果")
+-    print("=" * 50)
+-    
+-    # 基本统计信息
+-    print(f"总收益率: {report['return'].sum():.2%}")
+-    print(f"年化收益率: {report['return'].mean() * 252:.2%}")
+-    print(f"最大回撤: {report['drawdown'].min():.2%}")
+-    
+-    if 'sharpe' in report.columns:
+-        print(f"夏普比率: {report['sharpe'].iloc[-1]:.2f}")
+-    
+-    print(f"胜率: {(report['return'] > 0).mean():.2%}")
+-    
+-    # 风险指标
+-    volatility = report['return'].std() * np.sqrt(252)
+-    print(f"年化波动率: {volatility:.2%}")
+-    
+-    # 最大回撤期间
+-    max_drawdown_idx = report['drawdown'].idxmin()
+-    print(f"最大回撤发生时间: {max_drawdown_idx}")
+-    
+-    # 收益分布
+-    print("\n收益分布统计:")
+-    print(f"平均日收益: {report['return'].mean():.2%}")
+-    print(f"收益标准差: {report['return'].std():.2%}")
+-    print(f"最小日收益: {report['return'].min():.2%}")
+-    print(f"最大日收益: {report['return'].max():.2%}")
+-    
+-    # 交易统计
+-    if 'trade_count' in report.columns:
+-        print(f"\n总交易次数: {report['trade_count'].sum()}")
+-        print(f"平均每日交易次数: {report['trade_count'].mean():.1f}")
+-
+-
+-def create_simple_backtest():
+-    """
+-    创建简化版回测，用于演示
+-    """
+-    print("创建简化版均线交叉策略回测...")
+-    
+-    # 初始化qlib
+-    qlib.init(provider_uri='~/.qlib/qlib_data/cn_data', region=REG_CN)
+-    
+-    # 获取股票列表
+-    instruments = D.list_instruments(instruments="csi300", start_time="2020-01-01", end_time="2023-12-31")
+-    
+-    print(f"获取到 {len(instruments)} 只股票")
+-    
+-    # 选择前10只股票进行演示
+-    demo_instruments = instruments[:10]
+-    
+-    # 获取价格数据
+-    data = D.features(
+-        instruments=demo_instruments,
+-        start_time="2020-01-01",
+-        end_time="2023-12-31",
+-        freq='day',
+-        fields=['$close']
+-    )
+-    
+-    print(f"获取到价格数据，形状: {data.shape}")
+-    
+-    # 计算均线
+-    short_ma = data.rolling(window=5).mean()
+-    long_ma = data.rolling(window=20).mean()
+-    
+-    # 计算交叉信号
+-    signals = pd.DataFrame(0, index=data.index, columns=data.columns)
+-    
+-    for col in data.columns:
+-        # 计算均线差值
+-        diff = short_ma[col] - long_ma[col]
+-        
+-        # 计算交叉信号
+-        for i in range(1, len(diff)):
+-            if diff.iloc[i-1] < 0 and diff.iloc[i] > 0:
+-                signals.iloc[i, signals.columns.get_loc(col)] = 1  # 金叉买入
+-            elif diff.iloc[i-1] > 0 and diff.iloc[i] < 0:
+-                signals.iloc[i, signals.columns.get_loc(col)] = -1  # 死叉卖出
+-    
+-    # 统计信号
+-    buy_signals = (signals == 1).sum().sum()
+-    sell_signals = (signals == -1).sum().sum()
+-    
+-    print(f"\n信号统计:")
+-    print(f"买入信号数量: {buy_signals}")
+-    print(f"卖出信号数量: {sell_signals}")
+-    
+-    # 计算简单收益（假设每次信号都产生1%的收益）
+-    returns = signals * 0.01
+-    cumulative_returns = returns.sum(axis=1).cumsum()
+-    
+-    print(f"\n累计收益: {cumulative_returns.iloc[-1]:.2%}")
+-    
+-    return signals, cumulative_returns
+-
+-
+-def main():
+-    """
+-    主函数
+-    """
+-    print("开始运行均线交叉策略回测...")
+-    
+-    try:
+-        # 运行简化版回测
+-        signals, cumulative_returns = create_simple_backtest()
+-        
+-        # 保存简化版结果
+-        signals.to_csv("ma_cross_signals.csv")
+-        cumulative_returns.to_csv("ma_cross_cumulative_returns.csv")
+-        
+-        print("\n简化版回测完成！")
+-        print("信号数据已保存到 ma_cross_signals.csv")
+-        print("累计收益已保存到 ma_cross_cumulative_returns.csv")
+-        
+-    except Exception as e:
+-        print(f"回测过程中出现错误: {e}")
+-        print("请确保已正确安装qlib并下载了相应的数据。")
+-
+-
+-if __name__ == "__main__":
+-    main() 
+\ No newline at end of file
+diff --git a/test/ma_strategy_demo.py b/test/ma_strategy_demo.py
+deleted file mode 100644
+index 1fa4fb4..0000000
+Binary files a/test/ma_strategy_demo.py and /dev/null differ
+diff --git a/test/simple_ma_strategy.py b/test/simple_ma_strategy.py
+deleted file mode 100644
+index 8d03f6b..0000000
+--- a/test/simple_ma_strategy.py
++++ /dev/null
+@@ -1,298 +0,0 @@
+-"""
+-简单实用的均线交叉策略
+-金叉买入，死叉卖出
+-"""
+-
+-import qlib
+-from qlib.constant import REG_CN
+-from qlib.data import D
+-import pandas as pd
+-import numpy as np
+-import matplotlib.pyplot as plt
+-from datetime import datetime, timedelta
+-
+-
+-def init_qlib():
+-    """初始化qlib"""
+-    try:
+-        qlib.init(provider_uri='~/.qlib/qlib_data/cn_data', region=REG_CN)
+-        print("qlib初始化成功")
+-        return True
+-    except Exception as e:
+-        print(f"qlib初始化失败: {e}")
+-        print("请确保已安装qlib并下载了数据")
+-        return False
+-
+-
+-def get_stock_data(instruments, start_date, end_date):
+-    """
+-    获取股票数据
+-    
+-    Args:
+-        instruments: 股票代码列表
+-        start_date: 开始日期
+-        end_date: 结束日期
+-    
+-    Returns:
+-        股票价格数据
+-    """
+-    try:
+-        data = D.features(
+-            instruments=instruments,
+-            start_time=start_date,
+-            end_time=end_date,
+-            freq='day',
+-            fields=['$close', '$open', '$high', '$low', '$volume']
+-        )
+-        
+-        if data is not None and not data.empty:
+-            # 重命名列
+-            data.columns = ['close', 'open', 'high', 'low', 'volume']
+-            return data
+-        else:
+-            print("未获取到数据")
+-            return None
+-            
+-    except Exception as e:
+-        print(f"获取数据失败: {e}")
+-        return None
+-
+-
+-def calculate_ma_signals(data, short_window=5, long_window=20):
+-    """
+-    计算均线交叉信号
+-    
+-    Args:
+-        data: 价格数据
+-        short_window: 短期均线周期
+-        long_window: 长期均线周期
+-    
+-    Returns:
+-        信号DataFrame，1表示买入，-1表示卖出，0表示无信号
+-    """
+-    signals = pd.DataFrame(0, index=data.index, columns=data.columns)
+-    
+-    for col in data.columns:
+-        if col == 'close':
+-            continue
+-            
+-        # 计算均线
+-        short_ma = data[col].rolling(window=short_window).mean()
+-        long_ma = data[col].rolling(window=long_window).mean()
+-        
+-        # 计算均线差值
+-        diff = short_ma - long_ma
+-        
+-        # 计算交叉信号
+-        for i in range(1, len(diff)):
+-            if pd.notna(diff.iloc[i-1]) and pd.notna(diff.iloc[i]):
+-                # 金叉：短期均线从下方穿越长期均线
+-                if diff.iloc[i-1] < 0 and diff.iloc[i] > 0:
+-                    signals.iloc[i, signals.columns.get_loc(col)] = 1
+-                # 死叉：短期均线从上方穿越长期均线
+-                elif diff.iloc[i-1] > 0 and diff.iloc[i] < 0:
+-                    signals.iloc[i, signals.columns.get_loc(col)] = -1
+-    
+-    return signals
+-
+-
+-def calculate_returns(data, signals, initial_capital=100000):
+-    """
+-    计算策略收益
+-    
+-    Args:
+-        data: 价格数据
+-        signals: 信号数据
+-        initial_capital: 初始资金
+-    
+-    Returns:
+-        收益数据
+-    """
+-    # 计算日收益率
+-    returns = data.pct_change()
+-    
+-    # 策略收益（假设每次信号产生1%的收益）
+-    strategy_returns = signals * 0.01
+-    
+-    # 累计收益
+-    cumulative_returns = strategy_returns.sum(axis=1).cumsum()
+-    
+-    # 资金曲线
+-    capital_curve = initial_capital * (1 + cumulative_returns)
+-    
+-    return {
+-        'strategy_returns': strategy_returns,
+-        'cumulative_returns': cumulative_returns,
+-        'capital_curve': capital_curve
+-    }
+-
+-
+-def analyze_strategy(signals, returns_data):
+-    """
+-    分析策略表现
+-    
+-    Args:
+-        signals: 信号数据
+-        returns_data: 收益数据
+-    """
+-    print("=" * 50)
+-    print("均线交叉策略分析结果")
+-    print("=" * 50)
+-    
+-    # 信号统计
+-    buy_signals = (signals == 1).sum().sum()
+-    sell_signals = (signals == -1).sum().sum()
+-    
+-    print(f"买入信号数量: {buy_signals}")
+-    print(f"卖出信号数量: {sell_signals}")
+-    print(f"总信号数量: {buy_signals + sell_signals}")
+-    
+-    # 收益统计
+-    cumulative_returns = returns_data['cumulative_returns']
+-    capital_curve = returns_data['capital_curve']
+-    
+-    total_return = cumulative_returns.iloc[-1]
+-    annual_return = total_return / (len(cumulative_returns) / 252)
+-    
+-    print(f"\n收益统计:")
+-    print(f"总收益率: {total_return:.2%}")
+-    print(f"年化收益率: {annual_return:.2%}")
+-    print(f"最终资金: {capital_curve.iloc[-1]:,.0f}")
+-    
+-    # 风险统计
+-    daily_returns = returns_data['strategy_returns'].sum(axis=1)
+-    volatility = daily_returns.std() * np.sqrt(252)
+-    sharpe_ratio = annual_return / volatility if volatility > 0 else 0
+-    
+-    print(f"\n风险统计:")
+-    print(f"年化波动率: {volatility:.2%}")
+-    print(f"夏普比率: {sharpe_ratio:.2f}")
+-    print(f"胜率: {(daily_returns > 0).mean():.2%}")
+-
+-
+-def plot_results(data, signals, returns_data, stock_code):
+-    """
+-    绘制结果图表
+-    
+-    Args:
+-        data: 价格数据
+-        signals: 信号数据
+-        returns_data: 收益数据
+-        stock_code: 股票代码
+-    """
+-    fig, axes = plt.subplots(3, 1, figsize=(12, 10))
+-    
+-    # 绘制价格和均线
+-    axes[0].plot(data.index, data[stock_code], label='收盘价', alpha=0.7)
+-    short_ma = data[stock_code].rolling(window=5).mean()
+-    long_ma = data[stock_code].rolling(window=20).mean()
+-    axes[0].plot(data.index, short_ma, label='5日均线', alpha=0.8)
+-    axes[0].plot(data.index, long_ma, label='20日均线', alpha=0.8)
+-    
+-    # 标记买卖信号
+-    buy_signals = signals[stock_code] == 1
+-    sell_signals = signals[stock_code] == -1
+-    
+-    axes[0].scatter(data.index[buy_signals], data.loc[buy_signals, stock_code], 
+-                   color='red', marker='^', s=100, label='买入信号', alpha=0.8)
+-    axes[0].scatter(data.index[sell_signals], data.loc[sell_signals, stock_code], 
+-                   color='green', marker='v', s=100, label='卖出信号', alpha=0.8)
+-    
+-    axes[0].set_title(f'{stock_code} 价格走势与均线交叉信号')
+-    axes[0].legend()
+-    axes[0].grid(True, alpha=0.3)
+-    
+-    # 绘制累计收益
+-    axes[1].plot(returns_data['cumulative_returns'].index, 
+-                returns_data['cumulative_returns'].values, 
+-                label='累计收益', color='blue')
+-    axes[1].set_title('策略累计收益')
+-    axes[1].legend()
+-    axes[1].grid(True, alpha=0.3)
+-    
+-    # 绘制资金曲线
+-    axes[2].plot(returns_data['capital_curve'].index, 
+-                returns_data['capital_curve'].values, 
+-                label='资金曲线', color='green')
+-    axes[2].set_title('资金曲线')
+-    axes[2].legend()
+-    axes[2].grid(True, alpha=0.3)
+-    
+-    plt.tight_layout()
+-    plt.savefig('ma_cross_strategy_results.png', dpi=300, bbox_inches='tight')
+-    plt.show()
+-
+-
+-def main():
+-    """
+-    主函数
+-    """
+-    print("开始运行均线交叉策略...")
+-    
+-    # 初始化qlib
+-    if not init_qlib():
+-        return
+-    
+-    # 策略参数
+-    start_date = "2020-01-01"
+-    end_date = "2023-12-31"
+-    short_window = 5
+-    long_window = 20
+-    initial_capital = 100000
+-    
+-    # 获取股票列表
+-    try:
+-        instruments = D.list_instruments(instruments="csi300", start_time=start_date, end_time=end_date)
+-        print(f"获取到 {len(instruments)} 只股票")
+-        
+-        # 选择前5只股票进行演示
+-        demo_instruments = instruments[:5]
+-        print(f"选择演示股票: {demo_instruments}")
+-        
+-    except Exception as e:
+-        print(f"获取股票列表失败: {e}")
+-        # 使用默认股票列表
+-        demo_instruments = ['000001.SZ', '000002.SZ', '000858.SZ', '002415.SZ', '600036.SH']
+-        print(f"使用默认股票列表: {demo_instruments}")
+-    
+-    # 获取价格数据
+-    data = get_stock_data(demo_instruments, start_date, end_date)
+-    
+-    if data is None:
+-        print("无法获取数据，程序退出")
+-        return
+-    
+-    print(f"获取到价格数据，形状: {data.shape}")
+-    
+-    # 计算均线信号
+-    signals = calculate_ma_signals(data, short_window, long_window)
+-    
+-    # 计算收益
+-    returns_data = calculate_returns(data, signals, initial_capital)
+-    
+-    # 分析策略
+-    analyze_strategy(signals, returns_data)
+-    
+-    # 保存结果
+-    signals.to_csv("ma_cross_signals.csv")
+-    returns_data['cumulative_returns'].to_csv("ma_cross_cumulative_returns.csv")
+-    returns_data['capital_curve'].to_csv("ma_cross_capital_curve.csv")
+-    
+-    print("\n结果已保存到CSV文件:")
+-    print("- ma_cross_signals.csv: 买卖信号")
+-    print("- ma_cross_cumulative_returns.csv: 累计收益")
+-    print("- ma_cross_capital_curve.csv: 资金曲线")
+-    
+-    # 绘制图表（选择第一只股票）
+-    if len(demo_instruments) > 0:
+-        try:
+-            plot_results(data, signals, returns_data, demo_instruments[0])
+-            print("图表已保存为 ma_cross_strategy_results.png")
+-        except Exception as e:
+-            print(f"绘制图表失败: {e}")
+-    
+-    print("\n策略回测完成！")
+-
+-
+-if __name__ == "__main__":
+-    main() 
+\ No newline at end of file
+diff --git a/test/two_ema_stragety.py b/test/two_ema_stragety.py
+index a72e7e8..a9890c7 100644
+--- a/test/two_ema_stragety.py
++++ b/test/two_ema_stragety.py
+@@ -1,2 +1,98 @@
+-from qlib.contrib.strategy import 
+-from qlib.backtest import backtest
+\ No newline at end of file
++import pandas as pd
++
++from abc import ABC
++from typing import Dict, List, Text, Tuple, Union
++from qlib.data.dataset import Dataset
++from qlib.model.base import BaseModel
++from qlib.backtest.signal import Signal, create_signal_from
++from qlib.strategy.base import BaseStrategy
++from qlib.backtest.decision import Order, OrderDir, OrderHelper, TradeDecisionWO
++# from qlib.strategy import 
++# from qlib.backtest import backtest
++
++class InnerStrategy(BaseStrategy):
++    """
++    Inner strategy for order execution:
++    - Buy: if price < 200, buy all cash; else buy 200,000 worth.
++    - Sell: if price > 200, sell all; else sell half.
++    """
++    STOCK_CODE = "000858.SZ"
++
++    def generate_trade_decision(self, execute_result: list = None, action: str = None, amount: float = None):
++        # action: 'buy' or 'sell', amount: suggested amount (shares) from outer
++        position = self.trade_position
++        trade_step = self.trade_calendar.get_trade_step()
++        trade_start_time, trade_end_time = self.trade_calendar.get_step_time(trade_step)
++        order_helper = self.trade_exchange.get_order_helper()
++        orders = []
++        price = self.trade_exchange.get_deal_price(self.STOCK_CODE, trade_start_time, trade_end_time)
++        if action == 'buy':
++            cash = position.get_cash()
++            if price <= 0:
++                return TradeDecisionWO([], self)
++            if price < 200:
++                buy_amount = cash // price
++            else:
++                buy_amount = min(cash // price, 200000 // price)
++            buy_amount = int(buy_amount)
++            if buy_amount > 0:
++                order = order_helper.create(
++                    code=self.STOCK_CODE,
++                    amount=buy_amount,
++                    direction=OrderDir.BUY,
++                    start_time=trade_start_time,
++                    end_time=trade_end_time,
++                )
++                orders.append(order)
++        elif action == 'sell':
++            held_amount = position.get_stock_amount(self.STOCK_CODE)
++            if held_amount <= 0 or price <= 0:
++                return TradeDecisionWO([], self)
++            if price > 200:
++                sell_amount = held_amount
++            else:
++                sell_amount = held_amount // 2
++            sell_amount = int(sell_amount)
++            if sell_amount > 0:
++                order = order_helper.create(
++                    code=self.STOCK_CODE,
++                    amount=sell_amount,
++                    direction=OrderDir.SELL,
++                    start_time=trade_start_time,
++                    end_time=trade_end_time,
++                )
++                orders.append(order)
++        return TradeDecisionWO(orders, self)
++
++class OuterStrategy(BaseStrategy):
++    """
++    Outer strategy:
++    - If not holding Wuliangye, issues a buy order via inner strategy.
++    - If holding, checks if held for 25 days, if so, issues a sell order via inner strategy.
++    - Otherwise, holds.
++    """
++    STOCK_CODE = "000858.SZ"
++    HOLD_DAYS = 25
++    BAR = "day"
++
++    def __init__(self, *args, **kwargs):
++        super().__init__(*args, **kwargs)
++        self.inner_strategy = InnerStrategy()
++
++    def generate_trade_decision(self, execute_result: list = None):
++        position = self.trade_position
++        stock_list = position.get_stock_list()
++        trade_step = self.trade_calendar.get_trade_step()
++        trade_start_time, trade_end_time = self.trade_calendar.get_step_time(trade_step)
++        # Pass infra to inner strategy
++        self.inner_strategy.reset(level_infra=self.level_infra, common_infra=self.common_infra)
++        if self.STOCK_CODE in stock_list:
++            hold_days = position.get_stock_count(self.STOCK_CODE, self.BAR)
++            if hold_days >= self.HOLD_DAYS:
++                # Sell via inner strategy
++                return self.inner_strategy.generate_trade_decision(action='sell')
++        else:
++            # Buy via inner strategy
++            return self.inner_strategy.generate_trade_decision(action='buy')
++        # Otherwise, hold
++        return TradeDecisionWO([], self)
+\ No newline at end of file
diff --git a/mlruns/812028854715931404/e8bfc974f0864ad6bdaccc2b9156e975/artifacts/code_status.txt b/mlruns/812028854715931404/e8bfc974f0864ad6bdaccc2b9156e975/artifacts/code_status.txt
new file mode 100644
index 0000000..d9b6458
--- /dev/null
+++ b/mlruns/812028854715931404/e8bfc974f0864ad6bdaccc2b9156e975/artifacts/code_status.txt
@@ -0,0 +1,25 @@
+On branch main
+Your branch is up to date with 'origin/main'.
+
+Changes not staged for commit:
+  (use "git add/rm <file>..." to update what will be committed)
+  (use "git restore <file>..." to discard changes in working directory)
+	modified:   github/examples/benchmarks/LightGBM/workflow_config_lightgbm_Alpha1582.yaml
+	deleted:    test/README_MA_Strategy.md
+	modified:   test/damo1.py
+	modified:   test/demo2.ipynb
+	deleted:    test/ma_cross_strategy.py
+	deleted:    test/ma_cross_strategy_improved.py
+	deleted:    test/ma_strategy_demo.py
+	deleted:    test/simple_ma_strategy.py
+	modified:   test/two_ema_stragety.py
+
+Untracked files:
+  (use "git add <file>..." to include in what will be committed)
+	github/examples/mlruns/881301994755452456/157579a2201241aaafcff94e93d7da0e/
+	mlruns/
+	test/__pycache__/
+	test/buy_and_hold.py
+	test/workflow_by_code.py
+
+no changes added to commit (use "git add" and/or "git commit -a")
diff --git a/mlruns/812028854715931404/e8bfc974f0864ad6bdaccc2b9156e975/meta.yaml b/mlruns/812028854715931404/e8bfc974f0864ad6bdaccc2b9156e975/meta.yaml
new file mode 100644
index 0000000..0653000
--- /dev/null
+++ b/mlruns/812028854715931404/e8bfc974f0864ad6bdaccc2b9156e975/meta.yaml
@@ -0,0 +1,14 @@
+artifact_uri: file:D:\project\python\tradenote\mlruns/812028854715931404/e8bfc974f0864ad6bdaccc2b9156e975/artifacts
+end_time: 1750320836115
+entry_point_name: ''
+experiment_id: '812028854715931404'
+lifecycle_stage: active
+run_id: e8bfc974f0864ad6bdaccc2b9156e975
+run_name: mlflow_recorder
+source_name: ''
+source_type: 4
+source_version: ''
+start_time: 1750320835889
+status: 3
+tags: []
+user_id: abulimity
diff --git a/mlruns/812028854715931404/e8bfc974f0864ad6bdaccc2b9156e975/params/cmd-sys.argv b/mlruns/812028854715931404/e8bfc974f0864ad6bdaccc2b9156e975/params/cmd-sys.argv
new file mode 100644
index 0000000..db800eb
--- /dev/null
+++ b/mlruns/812028854715931404/e8bfc974f0864ad6bdaccc2b9156e975/params/cmd-sys.argv
@@ -0,0 +1 @@
+D:\project\python\tradenote\test\workflow_by_code.py
\ No newline at end of file
diff --git a/mlruns/812028854715931404/e8bfc974f0864ad6bdaccc2b9156e975/tags/mlflow.runName b/mlruns/812028854715931404/e8bfc974f0864ad6bdaccc2b9156e975/tags/mlflow.runName
new file mode 100644
index 0000000..25487e4
--- /dev/null
+++ b/mlruns/812028854715931404/e8bfc974f0864ad6bdaccc2b9156e975/tags/mlflow.runName
@@ -0,0 +1 @@
+mlflow_recorder
\ No newline at end of file
diff --git a/mlruns/812028854715931404/e8bfc974f0864ad6bdaccc2b9156e975/tags/mlflow.source.git.commit b/mlruns/812028854715931404/e8bfc974f0864ad6bdaccc2b9156e975/tags/mlflow.source.git.commit
new file mode 100644
index 0000000..288ce21
--- /dev/null
+++ b/mlruns/812028854715931404/e8bfc974f0864ad6bdaccc2b9156e975/tags/mlflow.source.git.commit
@@ -0,0 +1 @@
+0daea9b5bbb40120a1bc07c702d171abc1f219c7
\ No newline at end of file
diff --git a/mlruns/812028854715931404/e8bfc974f0864ad6bdaccc2b9156e975/tags/mlflow.source.name b/mlruns/812028854715931404/e8bfc974f0864ad6bdaccc2b9156e975/tags/mlflow.source.name
new file mode 100644
index 0000000..db800eb
--- /dev/null
+++ b/mlruns/812028854715931404/e8bfc974f0864ad6bdaccc2b9156e975/tags/mlflow.source.name
@@ -0,0 +1 @@
+D:\project\python\tradenote\test\workflow_by_code.py
\ No newline at end of file
diff --git a/mlruns/812028854715931404/e8bfc974f0864ad6bdaccc2b9156e975/tags/mlflow.source.type b/mlruns/812028854715931404/e8bfc974f0864ad6bdaccc2b9156e975/tags/mlflow.source.type
new file mode 100644
index 0000000..0c2c1fe
--- /dev/null
+++ b/mlruns/812028854715931404/e8bfc974f0864ad6bdaccc2b9156e975/tags/mlflow.source.type
@@ -0,0 +1 @@
+LOCAL
\ No newline at end of file
diff --git a/mlruns/812028854715931404/e8bfc974f0864ad6bdaccc2b9156e975/tags/mlflow.user b/mlruns/812028854715931404/e8bfc974f0864ad6bdaccc2b9156e975/tags/mlflow.user
new file mode 100644
index 0000000..b9cec6f
--- /dev/null
+++ b/mlruns/812028854715931404/e8bfc974f0864ad6bdaccc2b9156e975/tags/mlflow.user
@@ -0,0 +1 @@
+abulimity
\ No newline at end of file
diff --git a/mlruns/812028854715931404/faa5dd7cffc34bd595929c35c7b80a62/artifacts/code_cached.txt b/mlruns/812028854715931404/faa5dd7cffc34bd595929c35c7b80a62/artifacts/code_cached.txt
new file mode 100644
index 0000000..e69de29
diff --git a/mlruns/812028854715931404/faa5dd7cffc34bd595929c35c7b80a62/artifacts/code_diff.txt b/mlruns/812028854715931404/faa5dd7cffc34bd595929c35c7b80a62/artifacts/code_diff.txt
new file mode 100644
index 0000000..05b5475
--- /dev/null
+++ b/mlruns/812028854715931404/faa5dd7cffc34bd595929c35c7b80a62/artifacts/code_diff.txt
@@ -0,0 +1,1462 @@
+diff --git a/test/README_MA_Strategy.md b/test/README_MA_Strategy.md
+deleted file mode 100644
+index 5facaf7..0000000
+--- a/test/README_MA_Strategy.md
++++ /dev/null
+@@ -1,197 +0,0 @@
+-# 均线交叉策略 (Moving Average Crossover Strategy)
+-
+-## 策略概述
+-
+-这是一个基于qlib框架实现的均线交叉策略，核心逻辑是：
+-- **金叉买入**：短期均线上穿长期均线时买入
+-- **死叉卖出**：短期均线下穿长期均线时卖出
+-
+-## 文件说明
+-
+-### 1. `ma_cross_strategy.py`
+-完整的策略实现，包含：
+-- `MACrossStrategy` 类：继承自qlib的TopkDropoutStrategy
+-- 完整的回测框架
+-- 结果分析和保存
+-
+-### 2. `ma_cross_strategy_improved.py`
+-改进版本，包含：
+-- 更完善的数据获取逻辑
+-- 错误处理机制
+-- 简化版回测功能
+-
+-### 3. `simple_ma_strategy.py` ⭐ **推荐使用**
+-简单实用的版本，包含：
+-- 清晰的数据获取和处理
+-- 均线信号计算
+-- 收益计算和分析
+-- 可视化图表生成
+-- 结果保存功能
+-
+-## 使用方法
+-
+-### 环境准备
+-
+-1. 确保已安装qlib：
+-```bash
+-pip install pyqlib
+-```
+-
+-2. 下载qlib数据（如果还没有）：
+-```bash
+-# 下载中国股票数据
+-python -m qlib.data.dump_bin --csv_path ~/.qlib/qlib_data/cn_data --include_fields close,open,high,low,volume
+-```
+-
+-### 运行策略
+-
+-#### 方法1：运行简单版本（推荐）
+-```bash
+-cd test
+-python simple_ma_strategy.py
+-```
+-
+-#### 方法2：运行完整版本
+-```bash
+-cd test
+-python ma_cross_strategy.py
+-```
+-
+-#### 方法3：运行改进版本
+-```bash
+-cd test
+-python ma_cross_strategy_improved.py
+-```
+-
+-## 策略参数
+-
+-可以在代码中修改以下参数：
+-
+-```python
+-# 均线周期
+-short_window = 5    # 短期均线周期
+-long_window = 20    # 长期均线周期
+-
+-# 回测时间
+-start_date = "2020-01-01"
+-end_date = "2023-12-31"
+-
+-# 初始资金
+-initial_capital = 100000
+-
+-# 股票池
+-instruments = "csi300"  # 沪深300成分股
+-```
+-
+-## 输出结果
+-
+-运行策略后会生成以下文件：
+-
+-1. **CSV文件**：
+-   - `ma_cross_signals.csv`：买卖信号数据
+-   - `ma_cross_cumulative_returns.csv`：累计收益数据
+-   - `ma_cross_capital_curve.csv`：资金曲线数据
+-
+-2. **图表文件**：
+-   - `ma_cross_strategy_results.png`：策略结果可视化图表
+-
+-3. **控制台输出**：
+-   - 策略分析结果
+-   - 收益统计
+-   - 风险指标
+-
+-## 策略分析指标
+-
+-### 收益指标
+-- 总收益率
+-- 年化收益率
+-- 最终资金
+-
+-### 风险指标
+-- 年化波动率
+-- 夏普比率
+-- 胜率
+-- 最大回撤
+-
+-### 交易统计
+-- 买入信号数量
+-- 卖出信号数量
+-- 总交易次数
+-
+-## 策略逻辑详解
+-
+-### 1. 均线计算
+-```python
+-# 计算短期和长期均线
+-short_ma = price_data.rolling(window=short_window).mean()
+-long_ma = price_data.rolling(window=long_window).mean()
+-```
+-
+-### 2. 交叉信号判断
+-```python
+-# 计算均线差值
+-diff = short_ma - long_ma
+-
+-# 金叉：短期均线从下方穿越长期均线
+-if diff.iloc[i-1] < 0 and diff.iloc[i] > 0:
+-    signal = 1  # 买入信号
+-
+-# 死叉：短期均线从上方穿越长期均线
+-elif diff.iloc[i-1] > 0 and diff.iloc[i] < 0:
+-    signal = -1  # 卖出信号
+-```
+-
+-### 3. 收益计算
+-```python
+-# 策略收益（简化处理）
+-strategy_returns = signals * 0.01
+-
+-# 累计收益
+-cumulative_returns = strategy_returns.sum(axis=1).cumsum()
+-```
+-
+-## 注意事项
+-
+-1. **数据依赖**：确保qlib数据已正确下载和配置
+-2. **参数调优**：可以根据不同市场环境调整均线周期
+-3. **风险控制**：实际交易中需要加入止损和仓位管理
+-4. **交易成本**：当前版本未考虑交易费用，实际应用需要考虑
+-
+-## 扩展功能
+-
+-可以基于此策略进行以下扩展：
+-
+-1. **多均线策略**：使用多条均线进行更复杂的信号判断
+-2. **量价配合**：结合成交量指标优化信号
+-3. **止损机制**：添加动态止损策略
+-4. **仓位管理**：根据信号强度调整仓位大小
+-5. **多股票组合**：构建股票组合分散风险
+-
+-## 常见问题
+-
+-### Q: 如何修改股票池？
+-A: 在代码中修改 `instruments` 参数，例如：
+-```python
+-instruments = "csi500"  # 中证500
+-instruments = ["000001.SZ", "000002.SZ"]  # 指定股票列表
+-```
+-
+-### Q: 如何调整均线周期？
+-A: 修改 `short_window` 和 `long_window` 参数：
+-```python
+-short_window = 10  # 10日均线
+-long_window = 30   # 30日均线
+-```
+-
+-### Q: 如何查看详细的交易记录？
+-A: 查看生成的 `ma_cross_signals.csv` 文件，其中包含每日的买卖信号。
+-
+-## 联系方式
+-
+-如有问题或建议，请通过以下方式联系：
+-- 提交Issue到项目仓库
+-- 发送邮件到项目维护者
+-
+----
+-
+-**免责声明**：本策略仅供学习和研究使用，不构成投资建议。实际投资请谨慎决策，并承担相应风险。 
+\ No newline at end of file
+diff --git a/test/damo1.py b/test/damo1.py
+index 03102e1..7142dd1 100644
+--- a/test/damo1.py
++++ b/test/damo1.py
+@@ -1,5 +1,5 @@
+-# python scripts/get_data.py qlib_data --target_dir ../qlib_data/cn_data --region cn
+-
++# python github/scripts/get_data.py qlib_data --target_dir D:/sync/qlib/qlib_data/cn_data --region cn
++D:/sync/qlib/qlib_data/cn_data
+ import qlib
+ # region in [REG_CN, REG_US]
+ from qlib.constant import REG_CN
+diff --git a/test/demo2.ipynb b/test/demo2.ipynb
+index 66a0215..ad02df5 100644
+--- a/test/demo2.ipynb
++++ b/test/demo2.ipynb
+@@ -2,7 +2,7 @@
+  "cells": [
+   {
+    "cell_type": "code",
+-   "execution_count": 4,
++   "execution_count": 12,
+    "id": "6acb4a77",
+    "metadata": {},
+    "outputs": [
+@@ -10,39 +10,75 @@
+      "name": "stderr",
+      "output_type": "stream",
+      "text": [
+-      "[5344:MainThread](2025-06-18 14:41:03,895) INFO - qlib.Initialization - [config.py:420] - default_conf: client.\n",
+-      "[5344:MainThread](2025-06-18 14:41:03,900) INFO - qlib.Initialization - [__init__.py:74] - qlib successfully initialized based on client settings.\n",
+-      "[5344:MainThread](2025-06-18 14:41:03,903) INFO - qlib.Initialization - [__init__.py:76] - data_path={'__DEFAULT_FREQ': WindowsPath('D:/sync/qlib/qlib_data/cn_data')}\n"
++      "[13736:MainThread](2025-06-19 15:30:19,504) INFO - qlib.Initialization - [config.py:420] - default_conf: client.\n",
++      "[13736:MainThread](2025-06-19 15:30:19,506) INFO - qlib.Initialization - [__init__.py:74] - qlib successfully initialized based on client settings.\n",
++      "[13736:MainThread](2025-06-19 15:30:19,508) INFO - qlib.Initialization - [__init__.py:76] - data_path={'__DEFAULT_FREQ': WindowsPath('D:/sync/qlib/qlib_data/cn_data')}\n"
+      ]
+     }
+    ],
+    "source": [
+     "import qlib\n",
+-    "qlib.init(provider_uri=\"D:/sync/qlib/qlib_data/cn_data\", region=\"cn\")"
++    "qlib.init(provider_uri=r\"D:\\sync\\qlib\\qlib_data\\cn_data\", region=\"cn\")"
+    ]
+   },
+   {
+    "cell_type": "code",
+-   "execution_count": 12,
++   "execution_count": 14,
+    "id": "295df9af",
+    "metadata": {},
+    "outputs": [
+     {
+      "data": {
+       "text/plain": [
+-       "array([Timestamp('2020-09-21 00:00:00'), Timestamp('2020-09-22 00:00:00'),\n",
+-       "       Timestamp('2020-09-23 00:00:00'), Timestamp('2020-09-24 00:00:00'),\n",
+-       "       Timestamp('2020-09-25 00:00:00')], dtype=object)"
++       "array([Timestamp('2017-01-03 00:00:00'), Timestamp('2017-01-04 00:00:00'),\n",
++       "       Timestamp('2017-01-05 00:00:00'), Timestamp('2017-01-06 00:00:00'),\n",
++       "       Timestamp('2017-01-09 00:00:00')], dtype=object)"
+       ]
+      },
+-     "execution_count": 12,
++     "execution_count": 14,
+      "metadata": {},
+      "output_type": "execute_result"
+     }
+    ],
+    "source": [
+     "from qlib.data import D\n",
+-    "D.calendar(start_time='2020-09-21', end_time='2020-10-30', freq='day')"
++    "D.calendar(start_time=\"2017-01-01\", end_time=\"2020-08-01\",freq=\"day\")[:5]"
++   ]
++  },
++  {
++   "cell_type": "code",
++   "execution_count": 21,
++   "id": "da009afa",
++   "metadata": {},
++   "outputs": [
++    {
++     "ename": "error",
++     "evalue": "nothing to repeat at position 0",
++     "output_type": "error",
++     "traceback": [
++      "\u001b[31m---------------------------------------------------------------------------\u001b[39m",
++      "\u001b[31merror\u001b[39m                                     Traceback (most recent call last)",
++      "\u001b[36mCell\u001b[39m\u001b[36m \u001b[39m\u001b[32mIn[21]\u001b[39m\u001b[32m, line 4\u001b[39m\n\u001b[32m      2\u001b[39m nameDFilter = NameDFilter(name_rule_re=\u001b[33m'\u001b[39m\u001b[33m*000858\u001b[39m\u001b[33m'\u001b[39m)\n\u001b[32m      3\u001b[39m instruments = D.instruments(market=\u001b[33m'\u001b[39m\u001b[33mall\u001b[39m\u001b[33m'\u001b[39m,filter_pipe=[nameDFilter])\n\u001b[32m----> \u001b[39m\u001b[32m4\u001b[39m \u001b[43mD\u001b[49m\u001b[43m.\u001b[49m\u001b[43mlist_instruments\u001b[49m\u001b[43m(\u001b[49m\u001b[43minstruments\u001b[49m\u001b[43m=\u001b[49m\u001b[43minstruments\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mstart_time\u001b[49m\u001b[43m=\u001b[49m\u001b[33;43m'\u001b[39;49m\u001b[33;43m2015-01-01\u001b[39;49m\u001b[33;43m'\u001b[39;49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mend_time\u001b[49m\u001b[43m=\u001b[49m\u001b[33;43m'\u001b[39;49m\u001b[33;43m2016-02-15\u001b[39;49m\u001b[33;43m'\u001b[39;49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mas_list\u001b[49m\u001b[43m=\u001b[49m\u001b[38;5;28;43;01mTrue\u001b[39;49;00m\u001b[43m)\u001b[49m\n",
++      "\u001b[36mFile \u001b[39m\u001b[32md:\\project\\python\\tradenote\\.venv\\Lib\\site-packages\\qlib\\data\\data.py:1160\u001b[39m, in \u001b[36mBaseProvider.list_instruments\u001b[39m\u001b[34m(self, instruments, start_time, end_time, freq, as_list)\u001b[39m\n\u001b[32m   1159\u001b[39m \u001b[38;5;28;01mdef\u001b[39;00m\u001b[38;5;250m \u001b[39m\u001b[34mlist_instruments\u001b[39m(\u001b[38;5;28mself\u001b[39m, instruments, start_time=\u001b[38;5;28;01mNone\u001b[39;00m, end_time=\u001b[38;5;28;01mNone\u001b[39;00m, freq=\u001b[33m\"\u001b[39m\u001b[33mday\u001b[39m\u001b[33m\"\u001b[39m, as_list=\u001b[38;5;28;01mFalse\u001b[39;00m):\n\u001b[32m-> \u001b[39m\u001b[32m1160\u001b[39m     \u001b[38;5;28;01mreturn\u001b[39;00m \u001b[43mInst\u001b[49m\u001b[43m.\u001b[49m\u001b[43mlist_instruments\u001b[49m\u001b[43m(\u001b[49m\u001b[43minstruments\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mstart_time\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mend_time\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mfreq\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mas_list\u001b[49m\u001b[43m)\u001b[49m\n",
++      "\u001b[36mFile \u001b[39m\u001b[32md:\\project\\python\\tradenote\\.venv\\Lib\\site-packages\\qlib\\data\\data.py:719\u001b[39m, in \u001b[36mLocalInstrumentProvider.list_instruments\u001b[39m\u001b[34m(self, instruments, start_time, end_time, freq, as_list)\u001b[39m\n\u001b[32m    716\u001b[39m     \u001b[38;5;28;01mfrom\u001b[39;00m\u001b[38;5;250m \u001b[39m\u001b[34;01m.\u001b[39;00m\u001b[38;5;250m \u001b[39m\u001b[38;5;28;01mimport\u001b[39;00m \u001b[38;5;28mfilter\u001b[39m \u001b[38;5;28;01mas\u001b[39;00m F  \u001b[38;5;66;03m# pylint: disable=C0415\u001b[39;00m\n\u001b[32m    718\u001b[39m     filter_t = \u001b[38;5;28mgetattr\u001b[39m(F, filter_config[\u001b[33m\"\u001b[39m\u001b[33mfilter_type\u001b[39m\u001b[33m\"\u001b[39m]).from_config(filter_config)\n\u001b[32m--> \u001b[39m\u001b[32m719\u001b[39m     _instruments_filtered = \u001b[43mfilter_t\u001b[49m\u001b[43m(\u001b[49m\u001b[43m_instruments_filtered\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mstart_time\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mend_time\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mfreq\u001b[49m\u001b[43m)\u001b[49m\n\u001b[32m    720\u001b[39m \u001b[38;5;66;03m# as list\u001b[39;00m\n\u001b[32m    721\u001b[39m \u001b[38;5;28;01mif\u001b[39;00m as_list:\n",
++      "\u001b[36mFile \u001b[39m\u001b[32md:\\project\\python\\tradenote\\.venv\\Lib\\site-packages\\qlib\\data\\filter.py:192\u001b[39m, in \u001b[36mSeriesDFilter.__call__\u001b[39m\u001b[34m(self, instruments, start_time, end_time, freq)\u001b[39m\n\u001b[32m    190\u001b[39m \u001b[38;5;250m\u001b[39m\u001b[33;03m\"\"\"Call this filter to get filtered instruments list\"\"\"\u001b[39;00m\n\u001b[32m    191\u001b[39m \u001b[38;5;28mself\u001b[39m.filter_freq = freq\n\u001b[32m--> \u001b[39m\u001b[32m192\u001b[39m \u001b[38;5;28;01mreturn\u001b[39;00m \u001b[38;5;28;43mself\u001b[39;49m\u001b[43m.\u001b[49m\u001b[43mfilter_main\u001b[49m\u001b[43m(\u001b[49m\u001b[43minstruments\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mstart_time\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mend_time\u001b[49m\u001b[43m)\u001b[49m\n",
++      "\u001b[36mFile \u001b[39m\u001b[32md:\\project\\python\\tradenote\\.venv\\Lib\\site-packages\\qlib\\data\\filter.py:243\u001b[39m, in \u001b[36mSeriesDFilter.filter_main\u001b[39m\u001b[34m(self, instruments, start_time, end_time)\u001b[39m\n\u001b[32m    237\u001b[39m _all_calendar = Cal.calendar(start_time=start_time, end_time=end_time, freq=\u001b[38;5;28mself\u001b[39m.filter_freq)\n\u001b[32m    238\u001b[39m _filter_calendar = Cal.calendar(\n\u001b[32m    239\u001b[39m     start_time=\u001b[38;5;28mself\u001b[39m.filter_start_time \u001b[38;5;129;01mand\u001b[39;00m \u001b[38;5;28mmax\u001b[39m(\u001b[38;5;28mself\u001b[39m.filter_start_time, _all_calendar[\u001b[32m0\u001b[39m]) \u001b[38;5;129;01mor\u001b[39;00m _all_calendar[\u001b[32m0\u001b[39m],\n\u001b[32m    240\u001b[39m     end_time=\u001b[38;5;28mself\u001b[39m.filter_end_time \u001b[38;5;129;01mand\u001b[39;00m \u001b[38;5;28mmin\u001b[39m(\u001b[38;5;28mself\u001b[39m.filter_end_time, _all_calendar[-\u001b[32m1\u001b[39m]) \u001b[38;5;129;01mor\u001b[39;00m _all_calendar[-\u001b[32m1\u001b[39m],\n\u001b[32m    241\u001b[39m     freq=\u001b[38;5;28mself\u001b[39m.filter_freq,\n\u001b[32m    242\u001b[39m )\n\u001b[32m--> \u001b[39m\u001b[32m243\u001b[39m _all_filter_series = \u001b[38;5;28;43mself\u001b[39;49m\u001b[43m.\u001b[49m\u001b[43m_getFilterSeries\u001b[49m\u001b[43m(\u001b[49m\u001b[43minstruments\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43m_filter_calendar\u001b[49m\u001b[43m[\u001b[49m\u001b[32;43m0\u001b[39;49m\u001b[43m]\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43m_filter_calendar\u001b[49m\u001b[43m[\u001b[49m\u001b[43m-\u001b[49m\u001b[32;43m1\u001b[39;49m\u001b[43m]\u001b[49m\u001b[43m)\u001b[49m\n\u001b[32m    244\u001b[39m \u001b[38;5;28;01mfor\u001b[39;00m inst, timestamp \u001b[38;5;129;01min\u001b[39;00m instruments.items():\n\u001b[32m    245\u001b[39m     \u001b[38;5;66;03m# Construct a whole map of date\u001b[39;00m\n\u001b[32m    246\u001b[39m     _timestamp_series = \u001b[38;5;28mself\u001b[39m._toSeries(_all_calendar, timestamp)\n",
++      "\u001b[36mFile \u001b[39m\u001b[32md:\\project\\python\\tradenote\\.venv\\Lib\\site-packages\\qlib\\data\\filter.py:288\u001b[39m, in \u001b[36mNameDFilter._getFilterSeries\u001b[39m\u001b[34m(self, instruments, fstart, fend)\u001b[39m\n\u001b[32m    286\u001b[39m filter_calendar = Cal.calendar(start_time=fstart, end_time=fend, freq=\u001b[38;5;28mself\u001b[39m.filter_freq)\n\u001b[32m    287\u001b[39m \u001b[38;5;28;01mfor\u001b[39;00m inst, timestamp \u001b[38;5;129;01min\u001b[39;00m instruments.items():\n\u001b[32m--> \u001b[39m\u001b[32m288\u001b[39m     \u001b[38;5;28;01mif\u001b[39;00m \u001b[43mre\u001b[49m\u001b[43m.\u001b[49m\u001b[43mmatch\u001b[49m\u001b[43m(\u001b[49m\u001b[38;5;28;43mself\u001b[39;49m\u001b[43m.\u001b[49m\u001b[43mname_rule_re\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43minst\u001b[49m\u001b[43m)\u001b[49m:\n\u001b[32m    289\u001b[39m         _filter_series = pd.Series({timestamp: \u001b[38;5;28;01mTrue\u001b[39;00m \u001b[38;5;28;01mfor\u001b[39;00m timestamp \u001b[38;5;129;01min\u001b[39;00m filter_calendar})\n\u001b[32m    290\u001b[39m     \u001b[38;5;28;01melse\u001b[39;00m:\n",
++      "\u001b[36mFile \u001b[39m\u001b[32m~\\AppData\\Roaming\\uv\\python\\cpython-3.12.11-windows-x86_64-none\\Lib\\re\\__init__.py:167\u001b[39m, in \u001b[36mmatch\u001b[39m\u001b[34m(pattern, string, flags)\u001b[39m\n\u001b[32m    164\u001b[39m \u001b[38;5;28;01mdef\u001b[39;00m\u001b[38;5;250m \u001b[39m\u001b[34mmatch\u001b[39m(pattern, string, flags=\u001b[32m0\u001b[39m):\n\u001b[32m    165\u001b[39m \u001b[38;5;250m    \u001b[39m\u001b[33;03m\"\"\"Try to apply the pattern at the start of the string, returning\u001b[39;00m\n\u001b[32m    166\u001b[39m \u001b[33;03m    a Match object, or None if no match was found.\"\"\"\u001b[39;00m\n\u001b[32m--> \u001b[39m\u001b[32m167\u001b[39m     \u001b[38;5;28;01mreturn\u001b[39;00m \u001b[43m_compile\u001b[49m\u001b[43m(\u001b[49m\u001b[43mpattern\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mflags\u001b[49m\u001b[43m)\u001b[49m.match(string)\n",
++      "\u001b[36mFile \u001b[39m\u001b[32m~\\AppData\\Roaming\\uv\\python\\cpython-3.12.11-windows-x86_64-none\\Lib\\re\\__init__.py:307\u001b[39m, in \u001b[36m_compile\u001b[39m\u001b[34m(pattern, flags)\u001b[39m\n\u001b[32m    301\u001b[39m     \u001b[38;5;28;01mimport\u001b[39;00m\u001b[38;5;250m \u001b[39m\u001b[34;01mwarnings\u001b[39;00m\n\u001b[32m    302\u001b[39m     warnings.warn(\u001b[33m\"\u001b[39m\u001b[33mThe re.TEMPLATE/re.T flag is deprecated \u001b[39m\u001b[33m\"\u001b[39m\n\u001b[32m    303\u001b[39m             \u001b[33m\"\u001b[39m\u001b[33mas it is an undocumented flag \u001b[39m\u001b[33m\"\u001b[39m\n\u001b[32m    304\u001b[39m             \u001b[33m\"\u001b[39m\u001b[33mwithout an obvious purpose. \u001b[39m\u001b[33m\"\u001b[39m\n\u001b[32m    305\u001b[39m             \u001b[33m\"\u001b[39m\u001b[33mDon\u001b[39m\u001b[33m'\u001b[39m\u001b[33mt use it.\u001b[39m\u001b[33m\"\u001b[39m,\n\u001b[32m    306\u001b[39m             \u001b[38;5;167;01mDeprecationWarning\u001b[39;00m)\n\u001b[32m--> \u001b[39m\u001b[32m307\u001b[39m p = \u001b[43m_compiler\u001b[49m\u001b[43m.\u001b[49m\u001b[43mcompile\u001b[49m\u001b[43m(\u001b[49m\u001b[43mpattern\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mflags\u001b[49m\u001b[43m)\u001b[49m\n\u001b[32m    308\u001b[39m \u001b[38;5;28;01mif\u001b[39;00m flags & DEBUG:\n\u001b[32m    309\u001b[39m     \u001b[38;5;28;01mreturn\u001b[39;00m p\n",
++      "\u001b[36mFile \u001b[39m\u001b[32m~\\AppData\\Roaming\\uv\\python\\cpython-3.12.11-windows-x86_64-none\\Lib\\re\\_compiler.py:750\u001b[39m, in \u001b[36mcompile\u001b[39m\u001b[34m(p, flags)\u001b[39m\n\u001b[32m    748\u001b[39m \u001b[38;5;28;01mif\u001b[39;00m isstring(p):\n\u001b[32m    749\u001b[39m     pattern = p\n\u001b[32m--> \u001b[39m\u001b[32m750\u001b[39m     p = \u001b[43m_parser\u001b[49m\u001b[43m.\u001b[49m\u001b[43mparse\u001b[49m\u001b[43m(\u001b[49m\u001b[43mp\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mflags\u001b[49m\u001b[43m)\u001b[49m\n\u001b[32m    751\u001b[39m \u001b[38;5;28;01melse\u001b[39;00m:\n\u001b[32m    752\u001b[39m     pattern = \u001b[38;5;28;01mNone\u001b[39;00m\n",
++      "\u001b[36mFile \u001b[39m\u001b[32m~\\AppData\\Roaming\\uv\\python\\cpython-3.12.11-windows-x86_64-none\\Lib\\re\\_parser.py:979\u001b[39m, in \u001b[36mparse\u001b[39m\u001b[34m(str, flags, state)\u001b[39m\n\u001b[32m    976\u001b[39m state.flags = flags\n\u001b[32m    977\u001b[39m state.str = \u001b[38;5;28mstr\u001b[39m\n\u001b[32m--> \u001b[39m\u001b[32m979\u001b[39m p = \u001b[43m_parse_sub\u001b[49m\u001b[43m(\u001b[49m\u001b[43msource\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mstate\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mflags\u001b[49m\u001b[43m \u001b[49m\u001b[43m&\u001b[49m\u001b[43m \u001b[49m\u001b[43mSRE_FLAG_VERBOSE\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[32;43m0\u001b[39;49m\u001b[43m)\u001b[49m\n\u001b[32m    980\u001b[39m p.state.flags = fix_flags(\u001b[38;5;28mstr\u001b[39m, p.state.flags)\n\u001b[32m    982\u001b[39m \u001b[38;5;28;01mif\u001b[39;00m source.next \u001b[38;5;129;01mis\u001b[39;00m \u001b[38;5;129;01mnot\u001b[39;00m \u001b[38;5;28;01mNone\u001b[39;00m:\n",
++      "\u001b[36mFile \u001b[39m\u001b[32m~\\AppData\\Roaming\\uv\\python\\cpython-3.12.11-windows-x86_64-none\\Lib\\re\\_parser.py:460\u001b[39m, in \u001b[36m_parse_sub\u001b[39m\u001b[34m(source, state, verbose, nested)\u001b[39m\n\u001b[32m    458\u001b[39m start = source.tell()\n\u001b[32m    459\u001b[39m \u001b[38;5;28;01mwhile\u001b[39;00m \u001b[38;5;28;01mTrue\u001b[39;00m:\n\u001b[32m--> \u001b[39m\u001b[32m460\u001b[39m     itemsappend(\u001b[43m_parse\u001b[49m\u001b[43m(\u001b[49m\u001b[43msource\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mstate\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mverbose\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mnested\u001b[49m\u001b[43m \u001b[49m\u001b[43m+\u001b[49m\u001b[43m \u001b[49m\u001b[32;43m1\u001b[39;49m\u001b[43m,\u001b[49m\n\u001b[32m    461\u001b[39m \u001b[43m                       \u001b[49m\u001b[38;5;129;43;01mnot\u001b[39;49;00m\u001b[43m \u001b[49m\u001b[43mnested\u001b[49m\u001b[43m \u001b[49m\u001b[38;5;129;43;01mand\u001b[39;49;00m\u001b[43m \u001b[49m\u001b[38;5;129;43;01mnot\u001b[39;49;00m\u001b[43m \u001b[49m\u001b[43mitems\u001b[49m\u001b[43m)\u001b[49m)\n\u001b[32m    462\u001b[39m     \u001b[38;5;28;01mif\u001b[39;00m \u001b[38;5;129;01mnot\u001b[39;00m sourcematch(\u001b[33m\"\u001b[39m\u001b[33m|\u001b[39m\u001b[33m\"\u001b[39m):\n\u001b[32m    463\u001b[39m         \u001b[38;5;28;01mbreak\u001b[39;00m\n",
++      "\u001b[36mFile \u001b[39m\u001b[32m~\\AppData\\Roaming\\uv\\python\\cpython-3.12.11-windows-x86_64-none\\Lib\\re\\_parser.py:687\u001b[39m, in \u001b[36m_parse\u001b[39m\u001b[34m(source, state, verbose, nested, first)\u001b[39m\n\u001b[32m    685\u001b[39m     item = \u001b[38;5;28;01mNone\u001b[39;00m\n\u001b[32m    686\u001b[39m \u001b[38;5;28;01mif\u001b[39;00m \u001b[38;5;129;01mnot\u001b[39;00m item \u001b[38;5;129;01mor\u001b[39;00m item[\u001b[32m0\u001b[39m][\u001b[32m0\u001b[39m] \u001b[38;5;129;01mis\u001b[39;00m AT:\n\u001b[32m--> \u001b[39m\u001b[32m687\u001b[39m     \u001b[38;5;28;01mraise\u001b[39;00m source.error(\u001b[33m\"\u001b[39m\u001b[33mnothing to repeat\u001b[39m\u001b[33m\"\u001b[39m,\n\u001b[32m    688\u001b[39m                        source.tell() - here + \u001b[38;5;28mlen\u001b[39m(this))\n\u001b[32m    689\u001b[39m \u001b[38;5;28;01mif\u001b[39;00m item[\u001b[32m0\u001b[39m][\u001b[32m0\u001b[39m] \u001b[38;5;129;01min\u001b[39;00m _REPEATCODES:\n\u001b[32m    690\u001b[39m     \u001b[38;5;28;01mraise\u001b[39;00m source.error(\u001b[33m\"\u001b[39m\u001b[33mmultiple repeat\u001b[39m\u001b[33m\"\u001b[39m,\n\u001b[32m    691\u001b[39m                        source.tell() - here + \u001b[38;5;28mlen\u001b[39m(this))\n",
++      "\u001b[31merror\u001b[39m: nothing to repeat at position 0"
++     ]
++    }
++   ],
++   "source": [
++    "from qlib.data.filter import NameDFilter\n",
++    "nameDFilter = NameDFilter(name_rule_re='*000858')\n",
++    "instruments = D.instruments(market='all',filter_pipe=[nameDFilter])\n",
++    "D.list_instruments(instruments=instruments, start_time='2015-01-01', end_time='2016-02-15', as_list=True)\n"
+    ]
+   }
+  ],
+diff --git a/test/ma_cross_strategy.py b/test/ma_cross_strategy.py
+deleted file mode 100644
+index 719d849..0000000
+--- a/test/ma_cross_strategy.py
++++ /dev/null
+@@ -1,274 +0,0 @@
+-"""
+-均线交叉策略：金叉买入，死叉卖出
+-使用qlib框架实现
+-"""
+-
+-import qlib
+-from qlib.constant import REG_CN
+-from qlib.utils import init_instance_by_config
+-from qlib.workflow import R
+-from qlib.workflow.record_temp import SignalRecord, PortAnaRecord
+-from qlib.contrib.evaluate import backtest_daily
+-from qlib.contrib.strategy import TopkDropoutStrategy
+-import pandas as pd
+-import numpy as np
+-from typing import Dict, List, Tuple
+-
+-
+-class MACrossStrategy(TopkDropoutStrategy):
+-    """
+-    均线交叉策略
+-    金叉（短期均线上穿长期均线）买入
+-    死叉（短期均线下穿长期均线）卖出
+-    """
+-    
+-    def __init__(self, 
+-                 short_window: int = 5,
+-                 long_window: int = 20,
+-                 topk: int = 50,
+-                 n_drop: int = 5,
+-                 **kwargs):
+-        """
+-        初始化策略参数
+-        
+-        Args:
+-            short_window: 短期均线周期
+-            long_window: 长期均线周期
+-            topk: 选择前k只股票
+-            n_drop: 剔除前n只股票
+-        """
+-        super().__init__(topk=topk, n_drop=n_drop, **kwargs)
+-        self.short_window = short_window
+-        self.long_window = long_window
+-        
+-    def generate_trade_decision(self, score: pd.Series, trade_step: int) -> pd.Series:
+-        """
+-        生成交易决策
+-        
+-        Args:
+-            score: 股票评分
+-            trade_step: 交易步骤
+-            
+-        Returns:
+-            交易决策，1表示买入，-1表示卖出，0表示持有
+-        """
+-        # 获取当前持仓
+-        current_pos = self.get_current_position()
+-        
+-        # 计算均线信号
+-        signal = self._calculate_ma_signal(score.index.tolist(), trade_step)
+-        
+-        # 生成交易决策
+-        decision = pd.Series(0, index=score.index)
+-        
+-        # 金叉买入信号
+-        buy_signal = signal == 1
+-        decision[buy_signal] = 1
+-        
+-        # 死叉卖出信号
+-        sell_signal = signal == -1
+-        decision[sell_signal] = -1
+-        
+-        return decision
+-    
+-    def _calculate_ma_signal(self, instruments: List[str], trade_step: int) -> pd.Series:
+-        """
+-        计算均线交叉信号
+-        
+-        Args:
+-            instruments: 股票代码列表
+-            trade_step: 交易步骤
+-            
+-        Returns:
+-            信号序列：1表示金叉买入，-1表示死叉卖出，0表示无信号
+-        """
+-        # 获取历史数据
+-        data = self._get_historical_data(instruments, trade_step)
+-        
+-        signals = pd.Series(0, index=instruments)
+-        
+-        for instrument in instruments:
+-            if instrument in data.index:
+-                # 计算短期和长期均线
+-                short_ma = data.loc[instrument].rolling(window=self.short_window).mean()
+-                long_ma = data.loc[instrument].rolling(window=self.long_window).mean()
+-                
+-                # 计算交叉信号
+-                if len(short_ma) >= 2 and len(long_ma) >= 2:
+-                    # 当前和前一个时间点的均线差值
+-                    current_diff = short_ma.iloc[-1] - long_ma.iloc[-1]
+-                    prev_diff = short_ma.iloc[-2] - long_ma.iloc[-2]
+-                    
+-                    # 金叉：短期均线从下方穿越长期均线
+-                    if prev_diff < 0 and current_diff > 0:
+-                        signals[instrument] = 1
+-                    # 死叉：短期均线从上方穿越长期均线
+-                    elif prev_diff > 0 and current_diff < 0:
+-                        signals[instrument] = -1
+-        
+-        return signals
+-    
+-    def _get_historical_data(self, instruments: List[str], trade_step: int) -> pd.DataFrame:
+-        """
+-        获取历史价格数据
+-        
+-        Args:
+-            instruments: 股票代码列表
+-            trade_step: 交易步骤
+-            
+-        Returns:
+-            历史价格数据
+-        """
+-        # 这里简化处理，实际应该从qlib数据源获取
+-        # 在实际应用中，您需要使用qlib的数据接口
+-        try:
+-            # 获取最近的数据用于计算均线
+-            # 这里使用模拟数据，实际应该从qlib获取
+-            dates = pd.date_range(end=pd.Timestamp.now(), periods=50, freq='D')
+-            data = pd.DataFrame(
+-                np.random.randn(len(dates), len(instruments)) * 0.02 + 1.0,
+-                index=dates,
+-                columns=instruments
+-            )
+-            return data
+-        except Exception as e:
+-            print(f"获取历史数据失败: {e}")
+-            return pd.DataFrame()
+-
+-
+-def create_ma_cross_strategy_config():
+-    """
+-    创建均线交叉策略配置
+-    """
+-    strategy_config = {
+-        "class": "MACrossStrategy",
+-        "module_path": "test.ma_cross_strategy",
+-        "kwargs": {
+-            "short_window": 5,
+-            "long_window": 20,
+-            "topk": 50,
+-            "n_drop": 5,
+-        }
+-    }
+-    
+-    return strategy_config
+-
+-
+-def run_backtest():
+-    """
+-    运行回测
+-    """
+-    # 初始化qlib
+-    qlib.init(provider_uri='~/.qlib/qlib_data/cn_data', region=REG_CN)
+-    
+-    # 策略配置
+-    strategy_config = create_ma_cross_strategy_config()
+-    
+-    # 回测配置
+-    backtest_config = {
+-        "start_time": "2020-01-01",
+-        "end_time": "2023-12-31",
+-        "benchmark": "SH000300",  # 沪深300作为基准
+-        "account": 100000000,     # 初始资金1亿
+-        "exchange_kwargs": {
+-            "freq": "day",
+-            "limit_threshold": 0.095,
+-            "deal_price": "close",
+-            "open_cost": 0.0005,
+-            "close_cost": 0.0015,
+-            "min_cost": 5,
+-        }
+-    }
+-    
+-    # 创建策略实例
+-    strategy = init_instance_by_config(strategy_config)
+-    
+-    # 运行回测
+-    with R.start(experiment_name="ma_cross_strategy"):
+-        # 记录信号
+-        sr = SignalRecord(model=strategy, dataset=None, recorder=R.get_recorder())
+-        sr.generate()
+-        
+-        # 记录投资组合分析
+-        par = PortAnaRecord(recorder=R.get_recorder(), config=backtest_config, strategy=strategy)
+-        par.generate()
+-        
+-        # 获取回测结果
+-        report_normal, positions_normal = backtest_daily(
+-            account=backtest_config["account"],
+-            benchmark=backtest_config["benchmark"],
+-            start_time=backtest_config["start_time"],
+-            end_time=backtest_config["end_time"],
+-            strategy=strategy,
+-            exchange_kwargs=backtest_config["exchange_kwargs"]
+-        )
+-        
+-        return report_normal, positions_normal
+-
+-
+-def analyze_results(report: pd.DataFrame, positions: pd.DataFrame):
+-    """
+-    分析回测结果
+-    
+-    Args:
+-        report: 回测报告
+-        positions: 持仓信息
+-    """
+-    print("=" * 50)
+-    print("均线交叉策略回测结果")
+-    print("=" * 50)
+-    
+-    # 基本统计信息
+-    print(f"总收益率: {report['return'].sum():.2%}")
+-    print(f"年化收益率: {report['return'].mean() * 252:.2%}")
+-    print(f"最大回撤: {report['drawdown'].min():.2%}")
+-    print(f"夏普比率: {report['sharpe'].iloc[-1]:.2f}")
+-    print(f"胜率: {(report['return'] > 0).mean():.2%}")
+-    
+-    # 风险指标
+-    volatility = report['return'].std() * np.sqrt(252)
+-    print(f"年化波动率: {volatility:.2%}")
+-    
+-    # 最大回撤期间
+-    max_drawdown_idx = report['drawdown'].idxmin()
+-    print(f"最大回撤发生时间: {max_drawdown_idx}")
+-    
+-    # 收益分布
+-    print("\n收益分布统计:")
+-    print(f"平均日收益: {report['return'].mean():.2%}")
+-    print(f"收益标准差: {report['return'].std():.2%}")
+-    print(f"最小日收益: {report['return'].min():.2%}")
+-    print(f"最大日收益: {report['return'].max():.2%}")
+-    
+-    # 交易统计
+-    if 'trade_count' in report.columns:
+-        print(f"\n总交易次数: {report['trade_count'].sum()}")
+-        print(f"平均每日交易次数: {report['trade_count'].mean():.1f}")
+-
+-
+-def main():
+-    """
+-    主函数
+-    """
+-    print("开始运行均线交叉策略回测...")
+-    
+-    try:
+-        # 运行回测
+-        report, positions = run_backtest()
+-        
+-        # 分析结果
+-        analyze_results(report, positions)
+-        
+-        # 保存结果
+-        report.to_csv("ma_cross_strategy_report.csv")
+-        positions.to_csv("ma_cross_strategy_positions.csv")
+-        
+-        print("\n回测完成！结果已保存到CSV文件。")
+-        
+-    except Exception as e:
+-        print(f"回测过程中出现错误: {e}")
+-        print("请确保已正确安装qlib并下载了相应的数据。")
+-
+-
+-if __name__ == "__main__":
+-    main() 
+\ No newline at end of file
+diff --git a/test/ma_cross_strategy_improved.py b/test/ma_cross_strategy_improved.py
+deleted file mode 100644
+index d166c68..0000000
+--- a/test/ma_cross_strategy_improved.py
++++ /dev/null
+@@ -1,443 +0,0 @@
+-"""
+-改进的均线交叉策略：金叉买入，死叉卖出
+-使用qlib框架实现，包含完整的数据获取和信号计算
+-"""
+-
+-import qlib
+-from qlib.constant import REG_CN
+-from qlib.utils import init_instance_by_config
+-from qlib.workflow import R
+-from qlib.workflow.record_temp import SignalRecord, PortAnaRecord
+-from qlib.contrib.evaluate import backtest_daily
+-from qlib.contrib.strategy import TopkDropoutStrategy
+-from qlib.data import D
+-from qlib.data.dataset import DatasetH
+-from qlib.data.dataset.handler import DataHandlerLP
+-import pandas as pd
+-import numpy as np
+-from typing import Dict, List, Tuple
+-import warnings
+-warnings.filterwarnings('ignore')
+-
+-
+-class MACrossStrategyImproved(TopkDropoutStrategy):
+-    """
+-    改进的均线交叉策略
+-    金叉（短期均线上穿长期均线）买入
+-    死叉（短期均线下穿长期均线）卖出
+-    """
+-    
+-    def __init__(self, 
+-                 short_window: int = 5,
+-                 long_window: int = 20,
+-                 topk: int = 50,
+-                 n_drop: int = 5,
+-                 universe: str = "csi300",
+-                 **kwargs):
+-        """
+-        初始化策略参数
+-        
+-        Args:
+-            short_window: 短期均线周期
+-            long_window: 长期均线周期
+-            topk: 选择前k只股票
+-            n_drop: 剔除前n只股票
+-            universe: 股票池
+-        """
+-        super().__init__(topk=topk, n_drop=n_drop, **kwargs)
+-        self.short_window = short_window
+-        self.long_window = long_window
+-        self.universe = universe
+-        self.instruments = None
+-        self.price_cache = {}
+-        
+-    def generate_trade_decision(self, score: pd.Series, trade_step: int) -> pd.Series:
+-        """
+-        生成交易决策
+-        
+-        Args:
+-            score: 股票评分
+-            trade_step: 交易步骤
+-            
+-        Returns:
+-            交易决策，1表示买入，-1表示卖出，0表示持有
+-        """
+-        # 获取当前持仓
+-        current_pos = self.get_current_position()
+-        
+-        # 计算均线信号
+-        signal = self._calculate_ma_signal(score.index.tolist(), trade_step)
+-        
+-        # 生成交易决策
+-        decision = pd.Series(0, index=score.index)
+-        
+-        # 金叉买入信号
+-        buy_signal = signal == 1
+-        decision[buy_signal] = 1
+-        
+-        # 死叉卖出信号
+-        sell_signal = signal == -1
+-        decision[sell_signal] = -1
+-        
+-        return decision
+-    
+-    def _calculate_ma_signal(self, instruments: List[str], trade_step: int) -> pd.Series:
+-        """
+-        计算均线交叉信号
+-        
+-        Args:
+-            instruments: 股票代码列表
+-            trade_step: 交易步骤
+-            
+-        Returns:
+-            信号序列：1表示金叉买入，-1表示死叉卖出，0表示无信号
+-        """
+-        signals = pd.Series(0, index=instruments)
+-        
+-        # 获取当前日期
+-        current_date = self._get_current_date(trade_step)
+-        
+-        for instrument in instruments:
+-            try:
+-                # 获取历史价格数据
+-                price_data = self._get_price_data(instrument, current_date)
+-                
+-                if price_data is not None and len(price_data) >= self.long_window:
+-                    # 计算短期和长期均线
+-                    short_ma = price_data['close'].rolling(window=self.short_window).mean()
+-                    long_ma = price_data['close'].rolling(window=self.long_window).mean()
+-                    
+-                    # 计算交叉信号
+-                    if len(short_ma) >= 2 and len(long_ma) >= 2:
+-                        # 当前和前一个时间点的均线差值
+-                        current_diff = short_ma.iloc[-1] - long_ma.iloc[-1]
+-                        prev_diff = short_ma.iloc[-2] - long_ma.iloc[-2]
+-                        
+-                        # 金叉：短期均线从下方穿越长期均线
+-                        if prev_diff < 0 and current_diff > 0:
+-                            signals[instrument] = 1
+-                        # 死叉：短期均线从上方穿越长期均线
+-                        elif prev_diff > 0 and current_diff < 0:
+-                            signals[instrument] = -1
+-                            
+-            except Exception as e:
+-                print(f"计算{instrument}均线信号时出错: {e}")
+-                continue
+-        
+-        return signals
+-    
+-    def _get_price_data(self, instrument: str, current_date: str) -> pd.DataFrame:
+-        """
+-        获取股票价格数据
+-        
+-        Args:
+-            instrument: 股票代码
+-            current_date: 当前日期
+-            
+-        Returns:
+-            价格数据DataFrame
+-        """
+-        try:
+-            # 计算开始日期（获取足够的历史数据来计算均线）
+-            start_date = pd.Timestamp(current_date) - pd.Timedelta(days=self.long_window * 2)
+-            
+-            # 从qlib获取数据
+-            data = D.features(
+-                instruments=[instrument],
+-                start_time=start_date.strftime('%Y-%m-%d'),
+-                end_time=current_date,
+-                freq='day',
+-                fields=['$close', '$open', '$high', '$low', '$volume']
+-            )
+-            
+-            if data is not None and not data.empty:
+-                # 重命名列
+-                data.columns = ['close', 'open', 'high', 'low', 'volume']
+-                return data
+-            else:
+-                return None
+-                
+-        except Exception as e:
+-            print(f"获取{instrument}价格数据失败: {e}")
+-            return None
+-    
+-    def _get_current_date(self, trade_step: int) -> str:
+-        """
+-        根据交易步骤获取当前日期
+-        
+-        Args:
+-            trade_step: 交易步骤
+-            
+-        Returns:
+-            当前日期字符串
+-        """
+-        # 这里简化处理，实际应该从qlib的日历获取
+-        # 假设从2020-01-01开始，每个trade_step代表一天
+-        start_date = pd.Timestamp('2020-01-01')
+-        current_date = start_date + pd.Timedelta(days=trade_step)
+-        return current_date.strftime('%Y-%m-%d')
+-
+-
+-def create_dataset_config():
+-    """
+-    创建数据集配置
+-    """
+-    dataset_config = {
+-        "class": "DatasetH",
+-        "module_path": "qlib.data.dataset",
+-        "kwargs": {
+-            "handler": {
+-                "class": "DataHandlerLP",
+-                "module_path": "qlib.data.dataset.handler",
+-                "kwargs": {
+-                    "start_time": "2020-01-01",
+-                    "end_time": "2023-12-31",
+-                    "fit_start_time": "2020-01-01",
+-                    "fit_end_time": "2023-12-31",
+-                    "instruments": "csi300",
+-                    "infer_processors": [
+-                        {
+-                            "class": "RobustZScoreNorm",
+-                            "module_path": "qlib.data.dataset.processor",
+-                            "kwargs": {
+-                                "fields_group": "feature",
+-                                "clip_outlier": True,
+-                            },
+-                        },
+-                        {
+-                            "class": "Fillna",
+-                            "module_path": "qlib.data.dataset.processor",
+-                            "kwargs": {
+-                                "fields_group": "feature",
+-                            },
+-                        },
+-                    ],
+-                    "learn_processors": [
+-                        {
+-                            "class": "DropnaLabel",
+-                            "module_path": "qlib.data.dataset.processor",
+-                        },
+-                        {
+-                            "class": "CSRankNorm",
+-                            "module_path": "qlib.data.dataset.processor",
+-                            "kwargs": {
+-                                "fields_group": "label",
+-                            },
+-                        },
+-                    ],
+-                    "instruments": "csi300",
+-                },
+-            },
+-            "segments": {
+-                "train": ("2020-01-01", "2022-12-31"),
+-                "valid": ("2023-01-01", "2023-06-30"),
+-                "test": ("2023-07-01", "2023-12-31"),
+-            },
+-        },
+-    }
+-    
+-    return dataset_config
+-
+-
+-def create_ma_cross_strategy_config():
+-    """
+-    创建均线交叉策略配置
+-    """
+-    strategy_config = {
+-        "class": "MACrossStrategyImproved",
+-        "module_path": "test.ma_cross_strategy_improved",
+-        "kwargs": {
+-            "short_window": 5,
+-            "long_window": 20,
+-            "topk": 50,
+-            "n_drop": 5,
+-            "universe": "csi300",
+-        }
+-    }
+-    
+-    return strategy_config
+-
+-
+-def run_backtest():
+-    """
+-    运行回测
+-    """
+-    # 初始化qlib
+-    qlib.init(provider_uri='~/.qlib/qlib_data/cn_data', region=REG_CN)
+-    
+-    # 策略配置
+-    strategy_config = create_ma_cross_strategy_config()
+-    
+-    # 回测配置
+-    backtest_config = {
+-        "start_time": "2020-01-01",
+-        "end_time": "2023-12-31",
+-        "benchmark": "SH000300",  # 沪深300作为基准
+-        "account": 100000000,     # 初始资金1亿
+-        "exchange_kwargs": {
+-            "freq": "day",
+-            "limit_threshold": 0.095,
+-            "deal_price": "close",
+-            "open_cost": 0.0005,
+-            "close_cost": 0.0015,
+-            "min_cost": 5,
+-        }
+-    }
+-    
+-    # 创建策略实例
+-    strategy = init_instance_by_config(strategy_config)
+-    
+-    # 运行回测
+-    with R.start(experiment_name="ma_cross_strategy_improved"):
+-        # 记录信号
+-        sr = SignalRecord(model=strategy, dataset=None, recorder=R.get_recorder())
+-        sr.generate()
+-        
+-        # 记录投资组合分析
+-        par = PortAnaRecord(recorder=R.get_recorder(), config=backtest_config, strategy=strategy)
+-        par.generate()
+-        
+-        # 获取回测结果
+-        report_normal, positions_normal = backtest_daily(
+-            account=backtest_config["account"],
+-            benchmark=backtest_config["benchmark"],
+-            start_time=backtest_config["start_time"],
+-            end_time=backtest_config["end_time"],
+-            strategy=strategy,
+-            exchange_kwargs=backtest_config["exchange_kwargs"]
+-        )
+-        
+-        return report_normal, positions_normal
+-
+-
+-def analyze_results(report: pd.DataFrame, positions: pd.DataFrame):
+-    """
+-    分析回测结果
+-    
+-    Args:
+-        report: 回测报告
+-        positions: 持仓信息
+-    """
+-    print("=" * 50)
+-    print("均线交叉策略回测结果")
+-    print("=" * 50)
+-    
+-    # 基本统计信息
+-    print(f"总收益率: {report['return'].sum():.2%}")
+-    print(f"年化收益率: {report['return'].mean() * 252:.2%}")
+-    print(f"最大回撤: {report['drawdown'].min():.2%}")
+-    
+-    if 'sharpe' in report.columns:
+-        print(f"夏普比率: {report['sharpe'].iloc[-1]:.2f}")
+-    
+-    print(f"胜率: {(report['return'] > 0).mean():.2%}")
+-    
+-    # 风险指标
+-    volatility = report['return'].std() * np.sqrt(252)
+-    print(f"年化波动率: {volatility:.2%}")
+-    
+-    # 最大回撤期间
+-    max_drawdown_idx = report['drawdown'].idxmin()
+-    print(f"最大回撤发生时间: {max_drawdown_idx}")
+-    
+-    # 收益分布
+-    print("\n收益分布统计:")
+-    print(f"平均日收益: {report['return'].mean():.2%}")
+-    print(f"收益标准差: {report['return'].std():.2%}")
+-    print(f"最小日收益: {report['return'].min():.2%}")
+-    print(f"最大日收益: {report['return'].max():.2%}")
+-    
+-    # 交易统计
+-    if 'trade_count' in report.columns:
+-        print(f"\n总交易次数: {report['trade_count'].sum()}")
+-        print(f"平均每日交易次数: {report['trade_count'].mean():.1f}")
+-
+-
+-def create_simple_backtest():
+-    """
+-    创建简化版回测，用于演示
+-    """
+-    print("创建简化版均线交叉策略回测...")
+-    
+-    # 初始化qlib
+-    qlib.init(provider_uri='~/.qlib/qlib_data/cn_data', region=REG_CN)
+-    
+-    # 获取股票列表
+-    instruments = D.list_instruments(instruments="csi300", start_time="2020-01-01", end_time="2023-12-31")
+-    
+-    print(f"获取到 {len(instruments)} 只股票")
+-    
+-    # 选择前10只股票进行演示
+-    demo_instruments = instruments[:10]
+-    
+-    # 获取价格数据
+-    data = D.features(
+-        instruments=demo_instruments,
+-        start_time="2020-01-01",
+-        end_time="2023-12-31",
+-        freq='day',
+-        fields=['$close']
+-    )
+-    
+-    print(f"获取到价格数据，形状: {data.shape}")
+-    
+-    # 计算均线
+-    short_ma = data.rolling(window=5).mean()
+-    long_ma = data.rolling(window=20).mean()
+-    
+-    # 计算交叉信号
+-    signals = pd.DataFrame(0, index=data.index, columns=data.columns)
+-    
+-    for col in data.columns:
+-        # 计算均线差值
+-        diff = short_ma[col] - long_ma[col]
+-        
+-        # 计算交叉信号
+-        for i in range(1, len(diff)):
+-            if diff.iloc[i-1] < 0 and diff.iloc[i] > 0:
+-                signals.iloc[i, signals.columns.get_loc(col)] = 1  # 金叉买入
+-            elif diff.iloc[i-1] > 0 and diff.iloc[i] < 0:
+-                signals.iloc[i, signals.columns.get_loc(col)] = -1  # 死叉卖出
+-    
+-    # 统计信号
+-    buy_signals = (signals == 1).sum().sum()
+-    sell_signals = (signals == -1).sum().sum()
+-    
+-    print(f"\n信号统计:")
+-    print(f"买入信号数量: {buy_signals}")
+-    print(f"卖出信号数量: {sell_signals}")
+-    
+-    # 计算简单收益（假设每次信号都产生1%的收益）
+-    returns = signals * 0.01
+-    cumulative_returns = returns.sum(axis=1).cumsum()
+-    
+-    print(f"\n累计收益: {cumulative_returns.iloc[-1]:.2%}")
+-    
+-    return signals, cumulative_returns
+-
+-
+-def main():
+-    """
+-    主函数
+-    """
+-    print("开始运行均线交叉策略回测...")
+-    
+-    try:
+-        # 运行简化版回测
+-        signals, cumulative_returns = create_simple_backtest()
+-        
+-        # 保存简化版结果
+-        signals.to_csv("ma_cross_signals.csv")
+-        cumulative_returns.to_csv("ma_cross_cumulative_returns.csv")
+-        
+-        print("\n简化版回测完成！")
+-        print("信号数据已保存到 ma_cross_signals.csv")
+-        print("累计收益已保存到 ma_cross_cumulative_returns.csv")
+-        
+-    except Exception as e:
+-        print(f"回测过程中出现错误: {e}")
+-        print("请确保已正确安装qlib并下载了相应的数据。")
+-
+-
+-if __name__ == "__main__":
+-    main() 
+\ No newline at end of file
+diff --git a/test/ma_strategy_demo.py b/test/ma_strategy_demo.py
+deleted file mode 100644
+index 1fa4fb4..0000000
+Binary files a/test/ma_strategy_demo.py and /dev/null differ
+diff --git a/test/simple_ma_strategy.py b/test/simple_ma_strategy.py
+deleted file mode 100644
+index 8d03f6b..0000000
+--- a/test/simple_ma_strategy.py
++++ /dev/null
+@@ -1,298 +0,0 @@
+-"""
+-简单实用的均线交叉策略
+-金叉买入，死叉卖出
+-"""
+-
+-import qlib
+-from qlib.constant import REG_CN
+-from qlib.data import D
+-import pandas as pd
+-import numpy as np
+-import matplotlib.pyplot as plt
+-from datetime import datetime, timedelta
+-
+-
+-def init_qlib():
+-    """初始化qlib"""
+-    try:
+-        qlib.init(provider_uri='~/.qlib/qlib_data/cn_data', region=REG_CN)
+-        print("qlib初始化成功")
+-        return True
+-    except Exception as e:
+-        print(f"qlib初始化失败: {e}")
+-        print("请确保已安装qlib并下载了数据")
+-        return False
+-
+-
+-def get_stock_data(instruments, start_date, end_date):
+-    """
+-    获取股票数据
+-    
+-    Args:
+-        instruments: 股票代码列表
+-        start_date: 开始日期
+-        end_date: 结束日期
+-    
+-    Returns:
+-        股票价格数据
+-    """
+-    try:
+-        data = D.features(
+-            instruments=instruments,
+-            start_time=start_date,
+-            end_time=end_date,
+-            freq='day',
+-            fields=['$close', '$open', '$high', '$low', '$volume']
+-        )
+-        
+-        if data is not None and not data.empty:
+-            # 重命名列
+-            data.columns = ['close', 'open', 'high', 'low', 'volume']
+-            return data
+-        else:
+-            print("未获取到数据")
+-            return None
+-            
+-    except Exception as e:
+-        print(f"获取数据失败: {e}")
+-        return None
+-
+-
+-def calculate_ma_signals(data, short_window=5, long_window=20):
+-    """
+-    计算均线交叉信号
+-    
+-    Args:
+-        data: 价格数据
+-        short_window: 短期均线周期
+-        long_window: 长期均线周期
+-    
+-    Returns:
+-        信号DataFrame，1表示买入，-1表示卖出，0表示无信号
+-    """
+-    signals = pd.DataFrame(0, index=data.index, columns=data.columns)
+-    
+-    for col in data.columns:
+-        if col == 'close':
+-            continue
+-            
+-        # 计算均线
+-        short_ma = data[col].rolling(window=short_window).mean()
+-        long_ma = data[col].rolling(window=long_window).mean()
+-        
+-        # 计算均线差值
+-        diff = short_ma - long_ma
+-        
+-        # 计算交叉信号
+-        for i in range(1, len(diff)):
+-            if pd.notna(diff.iloc[i-1]) and pd.notna(diff.iloc[i]):
+-                # 金叉：短期均线从下方穿越长期均线
+-                if diff.iloc[i-1] < 0 and diff.iloc[i] > 0:
+-                    signals.iloc[i, signals.columns.get_loc(col)] = 1
+-                # 死叉：短期均线从上方穿越长期均线
+-                elif diff.iloc[i-1] > 0 and diff.iloc[i] < 0:
+-                    signals.iloc[i, signals.columns.get_loc(col)] = -1
+-    
+-    return signals
+-
+-
+-def calculate_returns(data, signals, initial_capital=100000):
+-    """
+-    计算策略收益
+-    
+-    Args:
+-        data: 价格数据
+-        signals: 信号数据
+-        initial_capital: 初始资金
+-    
+-    Returns:
+-        收益数据
+-    """
+-    # 计算日收益率
+-    returns = data.pct_change()
+-    
+-    # 策略收益（假设每次信号产生1%的收益）
+-    strategy_returns = signals * 0.01
+-    
+-    # 累计收益
+-    cumulative_returns = strategy_returns.sum(axis=1).cumsum()
+-    
+-    # 资金曲线
+-    capital_curve = initial_capital * (1 + cumulative_returns)
+-    
+-    return {
+-        'strategy_returns': strategy_returns,
+-        'cumulative_returns': cumulative_returns,
+-        'capital_curve': capital_curve
+-    }
+-
+-
+-def analyze_strategy(signals, returns_data):
+-    """
+-    分析策略表现
+-    
+-    Args:
+-        signals: 信号数据
+-        returns_data: 收益数据
+-    """
+-    print("=" * 50)
+-    print("均线交叉策略分析结果")
+-    print("=" * 50)
+-    
+-    # 信号统计
+-    buy_signals = (signals == 1).sum().sum()
+-    sell_signals = (signals == -1).sum().sum()
+-    
+-    print(f"买入信号数量: {buy_signals}")
+-    print(f"卖出信号数量: {sell_signals}")
+-    print(f"总信号数量: {buy_signals + sell_signals}")
+-    
+-    # 收益统计
+-    cumulative_returns = returns_data['cumulative_returns']
+-    capital_curve = returns_data['capital_curve']
+-    
+-    total_return = cumulative_returns.iloc[-1]
+-    annual_return = total_return / (len(cumulative_returns) / 252)
+-    
+-    print(f"\n收益统计:")
+-    print(f"总收益率: {total_return:.2%}")
+-    print(f"年化收益率: {annual_return:.2%}")
+-    print(f"最终资金: {capital_curve.iloc[-1]:,.0f}")
+-    
+-    # 风险统计
+-    daily_returns = returns_data['strategy_returns'].sum(axis=1)
+-    volatility = daily_returns.std() * np.sqrt(252)
+-    sharpe_ratio = annual_return / volatility if volatility > 0 else 0
+-    
+-    print(f"\n风险统计:")
+-    print(f"年化波动率: {volatility:.2%}")
+-    print(f"夏普比率: {sharpe_ratio:.2f}")
+-    print(f"胜率: {(daily_returns > 0).mean():.2%}")
+-
+-
+-def plot_results(data, signals, returns_data, stock_code):
+-    """
+-    绘制结果图表
+-    
+-    Args:
+-        data: 价格数据
+-        signals: 信号数据
+-        returns_data: 收益数据
+-        stock_code: 股票代码
+-    """
+-    fig, axes = plt.subplots(3, 1, figsize=(12, 10))
+-    
+-    # 绘制价格和均线
+-    axes[0].plot(data.index, data[stock_code], label='收盘价', alpha=0.7)
+-    short_ma = data[stock_code].rolling(window=5).mean()
+-    long_ma = data[stock_code].rolling(window=20).mean()
+-    axes[0].plot(data.index, short_ma, label='5日均线', alpha=0.8)
+-    axes[0].plot(data.index, long_ma, label='20日均线', alpha=0.8)
+-    
+-    # 标记买卖信号
+-    buy_signals = signals[stock_code] == 1
+-    sell_signals = signals[stock_code] == -1
+-    
+-    axes[0].scatter(data.index[buy_signals], data.loc[buy_signals, stock_code], 
+-                   color='red', marker='^', s=100, label='买入信号', alpha=0.8)
+-    axes[0].scatter(data.index[sell_signals], data.loc[sell_signals, stock_code], 
+-                   color='green', marker='v', s=100, label='卖出信号', alpha=0.8)
+-    
+-    axes[0].set_title(f'{stock_code} 价格走势与均线交叉信号')
+-    axes[0].legend()
+-    axes[0].grid(True, alpha=0.3)
+-    
+-    # 绘制累计收益
+-    axes[1].plot(returns_data['cumulative_returns'].index, 
+-                returns_data['cumulative_returns'].values, 
+-                label='累计收益', color='blue')
+-    axes[1].set_title('策略累计收益')
+-    axes[1].legend()
+-    axes[1].grid(True, alpha=0.3)
+-    
+-    # 绘制资金曲线
+-    axes[2].plot(returns_data['capital_curve'].index, 
+-                returns_data['capital_curve'].values, 
+-                label='资金曲线', color='green')
+-    axes[2].set_title('资金曲线')
+-    axes[2].legend()
+-    axes[2].grid(True, alpha=0.3)
+-    
+-    plt.tight_layout()
+-    plt.savefig('ma_cross_strategy_results.png', dpi=300, bbox_inches='tight')
+-    plt.show()
+-
+-
+-def main():
+-    """
+-    主函数
+-    """
+-    print("开始运行均线交叉策略...")
+-    
+-    # 初始化qlib
+-    if not init_qlib():
+-        return
+-    
+-    # 策略参数
+-    start_date = "2020-01-01"
+-    end_date = "2023-12-31"
+-    short_window = 5
+-    long_window = 20
+-    initial_capital = 100000
+-    
+-    # 获取股票列表
+-    try:
+-        instruments = D.list_instruments(instruments="csi300", start_time=start_date, end_time=end_date)
+-        print(f"获取到 {len(instruments)} 只股票")
+-        
+-        # 选择前5只股票进行演示
+-        demo_instruments = instruments[:5]
+-        print(f"选择演示股票: {demo_instruments}")
+-        
+-    except Exception as e:
+-        print(f"获取股票列表失败: {e}")
+-        # 使用默认股票列表
+-        demo_instruments = ['000001.SZ', '000002.SZ', '000858.SZ', '002415.SZ', '600036.SH']
+-        print(f"使用默认股票列表: {demo_instruments}")
+-    
+-    # 获取价格数据
+-    data = get_stock_data(demo_instruments, start_date, end_date)
+-    
+-    if data is None:
+-        print("无法获取数据，程序退出")
+-        return
+-    
+-    print(f"获取到价格数据，形状: {data.shape}")
+-    
+-    # 计算均线信号
+-    signals = calculate_ma_signals(data, short_window, long_window)
+-    
+-    # 计算收益
+-    returns_data = calculate_returns(data, signals, initial_capital)
+-    
+-    # 分析策略
+-    analyze_strategy(signals, returns_data)
+-    
+-    # 保存结果
+-    signals.to_csv("ma_cross_signals.csv")
+-    returns_data['cumulative_returns'].to_csv("ma_cross_cumulative_returns.csv")
+-    returns_data['capital_curve'].to_csv("ma_cross_capital_curve.csv")
+-    
+-    print("\n结果已保存到CSV文件:")
+-    print("- ma_cross_signals.csv: 买卖信号")
+-    print("- ma_cross_cumulative_returns.csv: 累计收益")
+-    print("- ma_cross_capital_curve.csv: 资金曲线")
+-    
+-    # 绘制图表（选择第一只股票）
+-    if len(demo_instruments) > 0:
+-        try:
+-            plot_results(data, signals, returns_data, demo_instruments[0])
+-            print("图表已保存为 ma_cross_strategy_results.png")
+-        except Exception as e:
+-            print(f"绘制图表失败: {e}")
+-    
+-    print("\n策略回测完成！")
+-
+-
+-if __name__ == "__main__":
+-    main() 
+\ No newline at end of file
+diff --git a/test/two_ema_stragety.py b/test/two_ema_stragety.py
+index a72e7e8..a9890c7 100644
+--- a/test/two_ema_stragety.py
++++ b/test/two_ema_stragety.py
+@@ -1,2 +1,98 @@
+-from qlib.contrib.strategy import 
+-from qlib.backtest import backtest
+\ No newline at end of file
++import pandas as pd
++
++from abc import ABC
++from typing import Dict, List, Text, Tuple, Union
++from qlib.data.dataset import Dataset
++from qlib.model.base import BaseModel
++from qlib.backtest.signal import Signal, create_signal_from
++from qlib.strategy.base import BaseStrategy
++from qlib.backtest.decision import Order, OrderDir, OrderHelper, TradeDecisionWO
++# from qlib.strategy import 
++# from qlib.backtest import backtest
++
++class InnerStrategy(BaseStrategy):
++    """
++    Inner strategy for order execution:
++    - Buy: if price < 200, buy all cash; else buy 200,000 worth.
++    - Sell: if price > 200, sell all; else sell half.
++    """
++    STOCK_CODE = "000858.SZ"
++
++    def generate_trade_decision(self, execute_result: list = None, action: str = None, amount: float = None):
++        # action: 'buy' or 'sell', amount: suggested amount (shares) from outer
++        position = self.trade_position
++        trade_step = self.trade_calendar.get_trade_step()
++        trade_start_time, trade_end_time = self.trade_calendar.get_step_time(trade_step)
++        order_helper = self.trade_exchange.get_order_helper()
++        orders = []
++        price = self.trade_exchange.get_deal_price(self.STOCK_CODE, trade_start_time, trade_end_time)
++        if action == 'buy':
++            cash = position.get_cash()
++            if price <= 0:
++                return TradeDecisionWO([], self)
++            if price < 200:
++                buy_amount = cash // price
++            else:
++                buy_amount = min(cash // price, 200000 // price)
++            buy_amount = int(buy_amount)
++            if buy_amount > 0:
++                order = order_helper.create(
++                    code=self.STOCK_CODE,
++                    amount=buy_amount,
++                    direction=OrderDir.BUY,
++                    start_time=trade_start_time,
++                    end_time=trade_end_time,
++                )
++                orders.append(order)
++        elif action == 'sell':
++            held_amount = position.get_stock_amount(self.STOCK_CODE)
++            if held_amount <= 0 or price <= 0:
++                return TradeDecisionWO([], self)
++            if price > 200:
++                sell_amount = held_amount
++            else:
++                sell_amount = held_amount // 2
++            sell_amount = int(sell_amount)
++            if sell_amount > 0:
++                order = order_helper.create(
++                    code=self.STOCK_CODE,
++                    amount=sell_amount,
++                    direction=OrderDir.SELL,
++                    start_time=trade_start_time,
++                    end_time=trade_end_time,
++                )
++                orders.append(order)
++        return TradeDecisionWO(orders, self)
++
++class OuterStrategy(BaseStrategy):
++    """
++    Outer strategy:
++    - If not holding Wuliangye, issues a buy order via inner strategy.
++    - If holding, checks if held for 25 days, if so, issues a sell order via inner strategy.
++    - Otherwise, holds.
++    """
++    STOCK_CODE = "000858.SZ"
++    HOLD_DAYS = 25
++    BAR = "day"
++
++    def __init__(self, *args, **kwargs):
++        super().__init__(*args, **kwargs)
++        self.inner_strategy = InnerStrategy()
++
++    def generate_trade_decision(self, execute_result: list = None):
++        position = self.trade_position
++        stock_list = position.get_stock_list()
++        trade_step = self.trade_calendar.get_trade_step()
++        trade_start_time, trade_end_time = self.trade_calendar.get_step_time(trade_step)
++        # Pass infra to inner strategy
++        self.inner_strategy.reset(level_infra=self.level_infra, common_infra=self.common_infra)
++        if self.STOCK_CODE in stock_list:
++            hold_days = position.get_stock_count(self.STOCK_CODE, self.BAR)
++            if hold_days >= self.HOLD_DAYS:
++                # Sell via inner strategy
++                return self.inner_strategy.generate_trade_decision(action='sell')
++        else:
++            # Buy via inner strategy
++            return self.inner_strategy.generate_trade_decision(action='buy')
++        # Otherwise, hold
++        return TradeDecisionWO([], self)
+\ No newline at end of file
diff --git a/mlruns/812028854715931404/faa5dd7cffc34bd595929c35c7b80a62/artifacts/code_status.txt b/mlruns/812028854715931404/faa5dd7cffc34bd595929c35c7b80a62/artifacts/code_status.txt
new file mode 100644
index 0000000..091c5f6
--- /dev/null
+++ b/mlruns/812028854715931404/faa5dd7cffc34bd595929c35c7b80a62/artifacts/code_status.txt
@@ -0,0 +1,23 @@
+On branch main
+Your branch is up to date with 'origin/main'.
+
+Changes not staged for commit:
+  (use "git add/rm <file>..." to update what will be committed)
+  (use "git restore <file>..." to discard changes in working directory)
+	deleted:    test/README_MA_Strategy.md
+	modified:   test/damo1.py
+	modified:   test/demo2.ipynb
+	deleted:    test/ma_cross_strategy.py
+	deleted:    test/ma_cross_strategy_improved.py
+	deleted:    test/ma_strategy_demo.py
+	deleted:    test/simple_ma_strategy.py
+	modified:   test/two_ema_stragety.py
+
+Untracked files:
+  (use "git add <file>..." to include in what will be committed)
+	mlruns/
+	test/__pycache__/
+	test/buy_and_hold.py
+	test/workflow_by_code.py
+
+no changes added to commit (use "git add" and/or "git commit -a")
diff --git a/mlruns/812028854715931404/faa5dd7cffc34bd595929c35c7b80a62/meta.yaml b/mlruns/812028854715931404/faa5dd7cffc34bd595929c35c7b80a62/meta.yaml
new file mode 100644
index 0000000..89bf6d3
--- /dev/null
+++ b/mlruns/812028854715931404/faa5dd7cffc34bd595929c35c7b80a62/meta.yaml
@@ -0,0 +1,14 @@
+artifact_uri: file:D:\project\python\tradenote\mlruns/812028854715931404/faa5dd7cffc34bd595929c35c7b80a62/artifacts
+end_time: 1750318869853
+entry_point_name: ''
+experiment_id: '812028854715931404'
+lifecycle_stage: active
+run_id: faa5dd7cffc34bd595929c35c7b80a62
+run_name: mlflow_recorder
+source_name: ''
+source_type: 4
+source_version: ''
+start_time: 1750318869631
+status: 3
+tags: []
+user_id: abulimity
diff --git a/mlruns/812028854715931404/faa5dd7cffc34bd595929c35c7b80a62/params/cmd-sys.argv b/mlruns/812028854715931404/faa5dd7cffc34bd595929c35c7b80a62/params/cmd-sys.argv
new file mode 100644
index 0000000..db800eb
--- /dev/null
+++ b/mlruns/812028854715931404/faa5dd7cffc34bd595929c35c7b80a62/params/cmd-sys.argv
@@ -0,0 +1 @@
+D:\project\python\tradenote\test\workflow_by_code.py
\ No newline at end of file
diff --git a/mlruns/812028854715931404/faa5dd7cffc34bd595929c35c7b80a62/tags/mlflow.runName b/mlruns/812028854715931404/faa5dd7cffc34bd595929c35c7b80a62/tags/mlflow.runName
new file mode 100644
index 0000000..25487e4
--- /dev/null
+++ b/mlruns/812028854715931404/faa5dd7cffc34bd595929c35c7b80a62/tags/mlflow.runName
@@ -0,0 +1 @@
+mlflow_recorder
\ No newline at end of file
diff --git a/mlruns/812028854715931404/faa5dd7cffc34bd595929c35c7b80a62/tags/mlflow.source.git.commit b/mlruns/812028854715931404/faa5dd7cffc34bd595929c35c7b80a62/tags/mlflow.source.git.commit
new file mode 100644
index 0000000..288ce21
--- /dev/null
+++ b/mlruns/812028854715931404/faa5dd7cffc34bd595929c35c7b80a62/tags/mlflow.source.git.commit
@@ -0,0 +1 @@
+0daea9b5bbb40120a1bc07c702d171abc1f219c7
\ No newline at end of file
diff --git a/mlruns/812028854715931404/faa5dd7cffc34bd595929c35c7b80a62/tags/mlflow.source.name b/mlruns/812028854715931404/faa5dd7cffc34bd595929c35c7b80a62/tags/mlflow.source.name
new file mode 100644
index 0000000..db800eb
--- /dev/null
+++ b/mlruns/812028854715931404/faa5dd7cffc34bd595929c35c7b80a62/tags/mlflow.source.name
@@ -0,0 +1 @@
+D:\project\python\tradenote\test\workflow_by_code.py
\ No newline at end of file
diff --git a/mlruns/812028854715931404/faa5dd7cffc34bd595929c35c7b80a62/tags/mlflow.source.type b/mlruns/812028854715931404/faa5dd7cffc34bd595929c35c7b80a62/tags/mlflow.source.type
new file mode 100644
index 0000000..0c2c1fe
--- /dev/null
+++ b/mlruns/812028854715931404/faa5dd7cffc34bd595929c35c7b80a62/tags/mlflow.source.type
@@ -0,0 +1 @@
+LOCAL
\ No newline at end of file
diff --git a/mlruns/812028854715931404/faa5dd7cffc34bd595929c35c7b80a62/tags/mlflow.user b/mlruns/812028854715931404/faa5dd7cffc34bd595929c35c7b80a62/tags/mlflow.user
new file mode 100644
index 0000000..b9cec6f
--- /dev/null
+++ b/mlruns/812028854715931404/faa5dd7cffc34bd595929c35c7b80a62/tags/mlflow.user
@@ -0,0 +1 @@
+abulimity
\ No newline at end of file
diff --git a/mlruns/812028854715931404/meta.yaml b/mlruns/812028854715931404/meta.yaml
new file mode 100644
index 0000000..e29d5f3
--- /dev/null
+++ b/mlruns/812028854715931404/meta.yaml
@@ -0,0 +1,6 @@
+artifact_location: file:D:\project\python\tradenote\mlruns/812028854715931404
+creation_time: 1750314275938
+experiment_id: '812028854715931404'
+last_update_time: 1750314275938
+lifecycle_stage: active
+name: buy_and_hold_test
diff --git a/test/buy_and_hold.py b/test/buy_and_hold.py
new file mode 100644
index 0000000..d160ae1
--- /dev/null
+++ b/test/buy_and_hold.py
@@ -0,0 +1,47 @@
+from qlib.strategy.base import BaseStrategy
+from qlib.backtest.decision import OrderDir, TradeDecisionWO
+
+class BuyHold(BaseStrategy):
+    """
+    买入并持固定天数策略：
+    检查交易目标股票是否已经持有，如果没有，则买入，如果已经持仓，检查是否持有达到固定天数，达到则卖出全部仓位
+    """
+    STOCK_CODE = "sz000858"
+    HOLD_DAYS = 25
+    BAR = "day"
+
+    def generate_trade_decision(self, execute_result: list = None):
+        position = self.trade_position
+        stock_list = position.get_stock_list()
+        trade_step = self.trade_calendar.get_trade_step()
+        trade_start_time, trade_end_time = self.trade_calendar.get_step_time(trade_step)
+        order_helper = self.trade_exchange.get_order_helper()
+        orders = []
+        if self.STOCK_CODE in stock_list:
+            hold_days = position.get_stock_count(self.STOCK_CODE, self.BAR)
+            amount = position.get_stock_amount(self.STOCK_CODE)
+            if hold_days >= self.HOLD_DAYS and amount > 0:
+                order = order_helper.create(
+                    code=self.STOCK_CODE,
+                    amount=amount,
+                    direction=OrderDir.SELL,
+                    start_time=trade_start_time,
+                    end_time=trade_end_time,
+                )
+                orders.append(order)
+        else:
+            cash = position.get_cash()
+            price = self.trade_exchange.get_deal_price(self.STOCK_CODE, trade_start_time, trade_end_time)
+            if price > 0:
+                amount = int(cash // price)
+                if amount > 0:
+                    order = order_helper.create(
+                        code=self.STOCK_CODE,
+                        amount=amount,
+                        direction=OrderDir.BUY,
+                        start_time=trade_start_time,
+                        end_time=trade_end_time,
+                    )
+                    orders.append(order)
+        return TradeDecisionWO(orders, self)
+    
\ No newline at end of file
diff --git a/test/workflow_by_code.py b/test/workflow_by_code.py
new file mode 100644
index 0000000..692901e
--- /dev/null
+++ b/test/workflow_by_code.py
@@ -0,0 +1,45 @@
+from qlib.workflow import R
+from qlib.workflow.record_temp import PortAnaRecord
+from test.buy_and_hold import BuyHold  # 假设你的策略在 test/buy_and_hold.py
+
+# 1. 初始化 Qlib（确保已下载好数据并正确初始化）
+import qlib
+qlib.init(provider_uri="D:/sync/qlib/qlib_data/cn_data", region="cn")
+
+# 2. 配置回测参数
+port_analysis_config = {
+    "executor": {
+        "class": "SimulatorExecutor",
+        "module_path": "qlib.backtest.executor",
+        "kwargs": {
+            "time_per_step": "day",
+            "generate_portfolio_metrics": True,
+        },
+    },
+    "strategy": {
+        "class": "BuyHold",  # 你的策略类名
+        "module_path": "test.buy_and_hold",  # 路径为你的策略文件
+        "kwargs": {},  # 如果有参数可在此传递
+    },
+    "backtest": {
+        "start_time": "2017-01-01",
+        "end_time": "2020-08-01",
+        "account": 1000000,
+        "benchmark": "SH000300",
+        # "instruments": "sz000858",  # 显式指定
+        "exchange_kwargs": {
+            "freq": "day",
+            "limit_threshold": 0.095,
+            "deal_price": "close",
+            "open_cost": 0.0005,
+            "close_cost": 0.0015,
+            "min_cost": 5,
+        },
+    },
+}
+
+# 3. 启动回测
+with R.start(experiment_name="buy_and_hold_test"):
+    rec = R.get_recorder()
+    par = PortAnaRecord(rec, port_analysis_config, "day")
+    par.generate()
\ No newline at end of file
